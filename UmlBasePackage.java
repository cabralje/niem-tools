
/**
 *   Manage the packages
 */
abstract class UmlBasePackage extends UmlItem {
  /**
   *  returns a new package named 'name' created under 'parent'
   * 
   *  In case it cannot be created (the name is already used or
   *  invalid, 'parent' cannot contain it etc ...) return 0 in C++
   *  and produce a RuntimeException in Java
   */
  public static UmlPackage create(UmlPackage parent, String name) throws RuntimeException
  {
    return (UmlPackage) parent.create_(anItemKind.aPackage, name);
  }

  /**
   *  returns the kind of the item
   */
  public anItemKind kind() {
    return anItemKind.aPackage;
  }

  /**
   *  returns the optional associated diagram
   */
  public UmlDiagram associatedDiagram() {
    read_if_needed_();
    
    return _assoc_diagram;
  }

  /**
   *  sets the associated diagram, arg may be null to unset it
   * 
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_AssociatedDiagram(UmlDiagram d) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setAssocDiagramCmd,
  		  (d == null) ? (long) 0 : d.identifier_());
    UmlCom.check();
    
    _assoc_diagram = d;
  
  }

  /**
   *  Import a project in the current package
   *  fn is the pathname of the .prj file of the project to import
   *  or an empty string (the project will be set through a dialog)
   *  Return the new UmlPackage containing the imported project, or
   *  0/null on error
   */
  public UmlPackage importProject(String fn) {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.importProjectCmd, fn);
    return (UmlPackage) UmlBaseItem.read_();
  }

  /**
   *  returns the path where the C++ source files are generated by the
   *  c++ generator.
   */
  public String cppSrcDir() {
    read_if_needed_();
    
    return _cpp_src_dir;
  }

  /**
   *  to set the path where the C++ source files are generated by the
   *  C++ generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_CppSrcDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setCppSrcDirCmd, s);
    UmlCom.check();
  
    _cpp_src_dir = s;
  }

  /**
   *  returns the path where the C++ header files are generated by the
   *  C++ generator.
   */
  public String cppHDir() {
    read_if_needed_();
    
    return _cpp_h_dir;
  }

  /**
   *  to set the path where the C++ header files are generated by the
   *  C++ generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_CppHDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setCppHDirCmd, s);
    UmlCom.check();
  
    _cpp_h_dir = s;
  }

  /**
   * returns the namespace name associed to the package
   */
  public String cppNamespace() {
    read_if_needed_();
    
    return _cpp_namespace;
  }

  /**
   * to set the namespace name associed to the package.
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_CppNamespace(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setCppNamespaceCmd, s);
    UmlCom.check();
  
    _cpp_namespace = s;
  }

  /**
   *  returns the sub package of 'p' package having the c++ namespace 'n'
   *  (including 'p' itself), else 0
   */
  public static UmlPackage findCppNamespace(String n, UmlBasePackage p)
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._findCppNamespaceCmd,
  		  (p != null) ? p.identifier_() : 0, n);
    
    return (UmlPackage) UmlBaseItem.read_();  
  }

  /**
   *  returns the path where the JAVA files are generated by the
   *  JAVA generator.
   */
  public String javaDir() {
    read_if_needed_();
    
    return _java_dir;
  }

  /**
   *  to set the path where the JAVA files are generated by the
   *  JAVA generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_JavaDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setJavaDirCmd, s);
    UmlCom.check();
  
    _java_dir = s;
  }

  /**
   * returns the java package name associed to the package
   */
  public String javaPackage() {
    read_if_needed_();
    
    return _java_package;
  }

  /**
   *  to set the java package name associed to the package.
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_JavaPackage(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setJavaPackageCmd, s);
    UmlCom.check();
  
    _java_package = s;
  }

  /**
   *  returns the sub package of 'p' package having the java package 'n'
   *  (including 'p' itself), else 0
   */
  public static UmlPackage findJavaPackage(String n, UmlBasePackage p)
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._findJavaPackageCmd,
  		  (p != null) ? p.identifier_() : 0, n);
    
    return (UmlPackage) UmlBaseItem.read_();  
  }

  /**
   *  returns the path where the PHP files are generated by the
   *  PHP generator.
   */
  public String phpDir() {
    read_if_needed_();
    
    return _php_dir;
  }

  /**
   *  to set the path where the PHP files are generated by the
   *  PHP generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_PhpDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setPhpDirCmd, s);
    UmlCom.check();
  
    _php_dir = s;
  }

  /**
   *  return the namespace name associed to the package
   */
  public String phpNamespace() {
    read_if_needed_();
  
    return _php_namespace;
  }

  /**
   *  the namespace name associed to the package.
   * 
   *  On error : return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_PhpNamespace(String v) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setPhpNamespaceCmd, v);
    UmlCom.check();
  
    _php_namespace = v;
  }

  /**
   *  returns a sub package of the current one having the php namespace 'n'
   *  (including the current one), else 0/null
   */
  public UmlPackage findPhpNamespace(String n) {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._findPhpNamespaceCmd, identifier_(), n);
    return (UmlPackage) UmlBaseItem.read_();
  }

  /**
   *  returns the path where the PYTHON files are generated by the
   *  PYTHON generator.
   */
  public String pythonDir() {
    read_if_needed_();
    
    return _python_dir;
  }

  /**
   *  to set the path where the PYTHON files are generated by the
   *  PYTHON generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_PythonDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setPythonDirCmd, s);
    UmlCom.check();
  
    _python_dir = s;
  }

  /**
   * returns the python package name associed to the package
   */
  public String pythonPackage() {
    read_if_needed_();
    
    return _python_package;
  }

  /**
   *  to set the python package name associed to the package.
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_PythonPackage(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setPythonPackageCmd, s);
    UmlCom.check();
  
    _python_package = s;
  }

  /**
   *  returns the sub package of 'p' package having the python package 'n'
   *  (including 'p' itself), else 0
   */
  public static UmlPackage findPythonPackage(String n, UmlBasePackage p)
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._findPythonPackageCmd,
  		  (p != null) ? p.identifier_() : 0, n);
    
    return (UmlPackage) UmlBaseItem.read_();  
  }

  /**
   *  returns the path where the IDL files are generated by the
   *  IDL generator.
   */
  public String idlDir() {
    read_if_needed_();
    
    return _idl_dir;
  }

  /**
   *  to set the path where the IDL files are generated by the
   *  IDL generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_IdlDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setIdlDirCmd, s);
    UmlCom.check();
  
    _idl_dir = s;
  }

  /**
   * returns the module name associed to the package
   */
  public String idlModule() {
    read_if_needed_();
    
    return _idl_module;
  }

  /**
   *  to set the module name associed to the package.
   *  
   *  On error return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_IdlModule(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setIdlModuleCmd, s);
    UmlCom.check();
  
    _idl_module = s;
  }

  /**
   *  returns the sub package of 'p' package having the IDL module 'n'
   *  (including 'p' itself), else 0
   */
  public static UmlPackage findIdlModule(String n, UmlBasePackage p)
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._findIdlModuleCmd,
  		  (p != null) ? p.identifier_() : 0, n);
    
    return (UmlPackage) UmlBaseItem.read_();  
  }

  /**
   *  returns the path where the MySql files are generated by the
   *  Mysql generator.
   */
  public String mysqlDir() {
    read_if_needed_();
  
    return _mysql_dir;
  }

  /**
   *  to set the path where the MySQL files are generated by the
   *  Mysql generator, may be relative even the 'root' path is not
   *  (already) an absolute path
   * 
   *  On error : return FALSE in C++, produce a RuntimeException in Java
   */
  public void set_MysqlDir(String s) throws RuntimeException {
    UmlCom.send_cmd(identifier_(), OnInstanceCmd.setMysqlDirCmd, s);
    UmlCom.check();
  
    _mysql_dir = s;
  }

  /**
   *   Returns the project
   */
  public static UmlPackage getProject()
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._getProjectCmd);
    
    return (UmlPackage) UmlBaseItem.read_();  
  }

  /**
   * return TRUE in case something is modified (i.e. the project must be saved)
   */
  public static boolean isProjectModified()
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._isProjectModifiedCmd);
    
    return UmlCom.read_bool();
  }

  /**
   * save the project if needed
   */
  public static void saveProject()
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._saveProjectCmd);
  }

  /**
   * Does nothing in case an edition is on going under BOUML. Else :
   * close the current project (in case it is not saved the last modifications are lost),
   * load the specified one, and all the communications with the plug-outs including the
   * current one are closed.
   */
  public static void loadProject(String p)
  {
    UmlCom.send_cmd(CmdFamily.miscGlobalCmd, MiscGlobalCmd._loadCmd, p);
  }

  /**
   *  Force consistency concerning the profiles and their stereotypes
   */
  public static void updateProfiles()
  {
    UmlCom.send_cmd(CmdFamily.packageGlobalCmd, PackageGlobalCmd._updateProfileCmd);
  }

  /**
   *  to unload the object to free memory, it will be reloaded automatically
   *  if needed. Recursively done for the sub items if 'rec' is TRUE. 
   * 
   *  if 'del' is true the sub items are deleted in C++, and removed from the
   *  internal dictionnary in C++ and Java (to allow it to be garbaged),
   *  you will have to call Children() to re-access to them
   */
  public void unload(boolean rec, boolean del) {
    _assoc_diagram = null;
    _cpp_src_dir = null;
    _cpp_h_dir = null;
    _cpp_namespace = null;
    _java_dir = null;
    _java_package = null;
    _php_dir = null;
    _python_dir = null;
    _python_package = null;
    _mysql_dir = null;
    _idl_dir = null;
    _idl_module = null;
    super.unload(rec, del);
  }

  private UmlDiagram _assoc_diagram;
  private String _cpp_src_dir;
  private String _cpp_h_dir;
  private String _cpp_namespace;

  private String _java_dir;
  private String _java_package;

  private String _php_dir;
  private String _php_namespace;

  private String _python_dir;

  private String _python_package;

  private String _idl_dir;
  private String _idl_module;

  private String _mysql_dir;

  protected void read_uml_() {
    _assoc_diagram = (UmlDiagram) UmlBaseItem.read_();
    super.read_uml_();
  }

  protected void read_cpp_() {
    _cpp_src_dir = UmlCom.read_string();
    _cpp_h_dir = UmlCom.read_string();
    _cpp_namespace = UmlCom.read_string();
  }

  protected void read_java_() {
    _java_dir = UmlCom.read_string();
    _java_package = UmlCom.read_string();
  }

  protected void read_php_() {
    _php_dir = UmlCom.read_string();
    _php_namespace = UmlCom.read_string();
  }

  /**
   * internal, do NOT use it
   */
  protected void read_python_() {
    _python_dir = UmlCom.read_string();
    _python_package = UmlCom.read_string();
  }

  protected void read_idl_() {
    _idl_dir = UmlCom.read_string();
    _idl_module = UmlCom.read_string();
  }

  /**
   * internal, do NOT use it
   */
  protected void read_mysql_() {
    _mysql_dir = UmlCom.read_string();
  }

  /**
   *  the constructor, do not call it yourself !!!!!!!!!!
   */
  protected UmlBasePackage(long id, String n) { super(id, n); }

};
