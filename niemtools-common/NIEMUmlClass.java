
/*
 *   NIEMtools - This is a plug_out that extends the BOUML UML tool with support for the National Information Exchange Model (NIEM) defined at http://niem.gov.
 *   Specifically, it enables a UML Common Information Model (CIM), an abstract class mode, to be mapped into a
 *   UML Platform Specific Model (PSM), the NIEM reference/subset/extension model, and a UML Platform Specific Model (NIEM), NIEM XML Schema.
 *
 *   NOTE: This plug_out requires that the BOUML project include a simple NIEM profile that provides the stereotypes required for mapping.
 *   
 *   Copyright (C) 2017 James E. Cabral Jr., MTG Management Consultants LLC, jcabral@mtgmc.com, http://github.com/cabralje
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.io.File; 
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
//import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.XMLConstants;
// DOM
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

// DOM
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

//OpenCSV library
import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

class NiemTools {

	private static final String ERROR_RESPONSE = "cbrn:MessageStatus";
	// Debugging options
	//private static Boolean _TRACE = true;
	private static final Boolean _TRACE = false;
	private static Boolean _IMPORT_CODE_DESCRIPTIONS = true;
	// private static final Boolean _IMPORT_CODE_DESCRIPTIONS = false;

	// JSON
	private static final String JSON_SCHEMA_URI = "http://json-schema.org/draft-04/schema#";
	private static final String JSON_SCHEMA_FILE_TYPE = ".schema.json";
	private static final String OPENAPI_FILE_TYPE = ".openapi.json";
	// XML
	private static final String XML_URI = XMLConstants.XML_NS_URI;
	private static final String XML_PREFIX = XMLConstants.XML_NS_PREFIX;
	private static final String XSD_PREFIX = "xs";
	private static final String XSD_URI = XMLConstants.W3C_XML_SCHEMA_NS_URI;
	private static final String XSD_FILE_TYPE = ".xsd";
	private static final String XML_FILE_TYPE = ".xml";
	private static final String HTML_FILE_TYPE = ".html";
	private static final String XSI_PREFIX = "xsi";
	private static final String XSI_URI = XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;
	private static final String NAMESPACE_DELIMITER = ":";
	private static final String NAMESPACE_ATTRIBUTE = XMLConstants.XMLNS_ATTRIBUTE;
	private static final String XML_HEADER = "<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n";
	private static final String[] XML_TYPE_NAMES = { "anyURI", "base64Binary", "boolean", "byte", "date", "dateTime",
			"decimal", "double", "duration", "ENTITIES", "ENTITY", "float", "gDay", "gMonth", "gMonthDay", "gYear",
			"gYearMonth", "hexBinary", "ID", "IDREF", "IDREFS", "int", "integer", "language", "long", "Name", "NCName",
			"negativeInteger", "NMTOKEN", "NMTOKENS", "nonNegativeInteger", "nonPositiveInteger", "normalizedString",
			"NOTATION", "positiveInteger", "QName", "short", "string", "time", "token", "unsignedByte", "unsignedInt",
			"unsignedLong", "unsignedShort" };
	private static final String XML_ATTRIBUTION = "<!-- Generated by BOUML niemtools plug_out (https://github.com/cabralje/niem-tools) -->\n";
	// XML Catalog
	private static final String XML_CATALOG_URI = "urn:oasis:names:tc:entity:xmlns:xml:catalog";
	private static final String XML_CATALOG_HEADER = "<!DOCTYPE catalog PUBLIC \"-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN\" \"http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd\">\n";
	// Web services
	private static final String SOAP_PREFIX = "soap";
	private static final String SOAP_URI = "http://schemas.xmlsoap.org/wsdl/soap/";
	private static final String SOAP_HTTP_BINDING_URI = "http://schemas.xmlsoap.org/soap/http";
	private static final String WSDL_SCHEMA_PREFIX = "wsdl";
	private static final String WSDL_SCHEMA_URI = "http://schemas.xmlsoap.org/wsdl/";
	private static final String WSDL_FILE_TYPE = ".wsdl";
	private static final String WSP_PREFIX = "wsp";
	private static final String WSP_URI = "http://schemas.xmlsoap.org/ws/2004/09/policy";
	private static final String WSP_POLICY = "MyPolicy";
	private static final String WSU_PREFIX = "wsu";
	private static final String WSU_URI = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";
	private static final String WSRMP_PREFIX = "wsrmp";
	private static final String WSRMP_URI = "http://docs.oasis-open.org/ws-rx/wsrmp/200702";
	private static final String[] HTTP_METHODS = { "get", "put", "post", "update"};
	// Genericode
	private static final String GC_PREFIX = "gc";
	private static final String GC_URI = "http://docs.oasis-open.org/codelist/ns/genericode/1.0/";
	private static final String GC_LOCATION = "https://docs.oasis-open.org/codelist/cs-genericode-1.0/xsd/genericode.xsd";
	private static final String GC_FILE_TYPE = ".gc";
	private static final String GC_APPINFO_PREFIX = "gca";
	private static final String GC_APPINFO_URI = "http://example.org/namespace/genericode-appinfo";
	// NIEM code lists
	private static final String CODELIST_URI = "http://reference.niem.gov/niem/specification/code-lists/1.0/";
	private static final String CODELIST_APPINFO_PREFIX = "clsa";
	private static final String CODELIST_APPINFO_URI = "http://reference.niem.gov/niem/specification/code-lists/1.0/code-lists-schema-appinfo/";
	private static final String CODELIST_CODE = "code";
	private static final String CODELIST_DEFINITION = "definition";
	// NIEM naming and design rules
	private static final String NC_PREFIX = "nc";
	private static final String NDR_URI = "http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/";
	private static final String AUGMENTATION_TYPE_NAME = "AugmentationType";
	private static final String AUGMENTATION_POINT_NAME = "AugmentationPoint";
	private static final String SIMPLE_OBJECT_ATTRIBUTE_GROUP = "@SimpleObjectAttributeGroup";
	private static final String OBJECT_TYPE_NAME = "ObjectType";
	private static final String STRUCTURES_PREFIX = "structures";
	private static final String NIEM_VERSION_DEFAULT = "4.0";
	// NIEM conformance targets
	private static final String CT_PREFIX = "ct";
	private static final String CT_URI = "http://release.niem.gov/niem/conformanceTargets/3.0/";
	// NIEM terms
	private static final String TERM_PREFIX = "term";
	private static final String TERM_URI = "http://release.niem.gov/niem/localTerminology/3.0/";
	// NIEM model package descriptions
	private static final String MPD_URI = "http://reference.niem.gov/niem/specification/model-package-description/3.0/";
	private static final String MPD_CATALOG_URI = "http://reference.niem.gov/niem/resource/mpd/catalog/3.0/";
	private static final String MPD_CATALOG_LOCATION = "https://tools.niem.gov/IEPD/mpd-catalog-3.0.xsd";
	// private static final String MPD_CATALOG_LOCATION =
	// "../../mpd-toolkit-3.0/mpd-catalog-3.0.xsd";
	private static final String MPD_NC_URI = "http://release.niem.gov/niem/niem-core/3.0/";
	private static final String MPD_STRUCTURES_URI = "http://release.niem.gov/niem/structures/3.0/";
	// NIEM subset schema generation tool (SSGT)
	private static final String WANTLIST_URI = "http://niem.gov/niem/wantlist/2.2";
	// Niem-tools UML modeling
	private static final String NIEM_PACKAGE = "NIEM";
	private static final String NIEM_REFERENCE_PACKAGE = "NIEMReference";
	private static final String NIEM_SUBSET_PACKAGE = "NIEMSubset";
	private static final String NIEM_EXTENSION_PACKAGE = "NIEMExtension";
	private static final String MAPPING_SPREADSHEET_TITLE = "NIEM Mapping";
	private static final String ATTRIBUTE_PREFIX = "@";
	private static final String REFERENCE_PREFIX = "^";
	private static final String HASH_DELIMITER = ",";
	private static final String CODELIST_DELIMITER = ";";
	private static final String CODELIST_DEFINITION_DELIMITER = "=";
	private static final String NOTES_PROPERTY = "Notes";
	private static final String NILLABLE_PROPERTY = "isNillable";
	private static final String URI_PROPERTY = "URI";
	private static final String PREFIX_PROPERTY = "prefix";
	private static final String SUBSTITUTION_PROPERTY = "substitutesFor";
	private static final String CODELIST_PROPERTY = "codeList";
	private static final String FILE_PATH_PROPERTY = "path";
	private static final String MESSAGE_ELEMENT_PROPERTY = "messageElement";
	private static final String WSDL_SUFFIX = "WSDL";
	//private static final String JSON_SUFFIX = "JSON";	
	private static final String MESSAGE_WRAPPERS_FILE_NAME = "MessageWrappers";
	private static final String LOCAL_PREFIX = "local";
	private static final String LOCAL_URI = "local";
	private static final String ABSTRACT_TYPE_NAME = "abstract";
	private static final String ANY_ELEMENT_NAME = "any";
	// Niem-tools web services
	private static final String WSDL_PREFIX = "tns";
	private static final String WRAPPER_PREFIX = "wrapper";
	private static final String RESPONSE_MESSAGE_SUFFIX = "Response";
	private static final String REQUEST_MESSAGE_SUFFIX = "Request";
	// IEPD Properties
	public static final String IEPD_EXTERNAL_SCHEMAS_PROPERTY = "externalSchemas";
	public static final String IEPD_CHANGE_LOG_FILE_PROPERTY = "IEPDChangeLogFile";
	public static final String IEPD_READ_ME_FILE_PROPERTY = "IEPDReadMeFile";
	public static final String IEPD_CONTACT_PROPERTY = "IEPDContact";
	public static final String IEPD_EMAIL_PROPERTY = "IEPDEmail";
	public static final String IEPD_LICENSE_URL_PROPERTY = "IEPDLicense";
	public static final String IEPD_TERMS_URL_PROPERTY = "IEPDTermsOfService";
	public static final String IEPD_ORGANIZATION_PROPERTY = "IEPDOrganization";
	public static final String IEPD_STATUS_PROPERTY = "IEPDStatus";
	public static final String IEPD_VERSION_PROPERTY = "IEPDVersion";
	public static final String IEPD_NAME_PROPERTY = "IEPDName";
	public static final String IEPD_URI_PROPERTY = "IEPDURI";
	public static final String IEPD_CHANGE_LOG_FILE_DEFAULT = "changelog.txt";
	public static final String IEPD_READ_ME_FILE_DEFAULT = "readme.txt";
	public static final String IEPD_CONTACT_DEFAULT = "Contact";
	public static final String IEPD_EMAIL_DEFAULT = "email@example.com";
	public static final String IEPD_LICENSE_URL_DEFAULT = "https://opensource.org/licenses/BSD-3-Clause";
	public static final String IEPD_TERMS_URL_DEFAULT = "example.com/terms";
	public static final String IEPD_ORGANIZATION_DEFAULT = "Organization";
	public static final String IEPD_STATUS_DEFAULT = "Draft";
	public static final String IEPD_VERSION_DEFAULT = "1.0";
	public static final String IEPD_NAME_DEFAULT = "IEPD";
	public static final String IEPD_URI_DEFAULT = "http://local";
	public static final String IEPD_EXTERNAL_SCHEMAS_DEFAULT = "cac=urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2=http://docs.oasis-open.org/ubl/os-UBL-2.1/xsd/common/UBL-CommonAggregateComponents-2.1.xsd,"
			+ "cbc=urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2=http://docs.oasis-open.org/ubl/os-UBL-2.1/xsd/common/UBL-CommonBasicComponents-2.1.xsd,"
			+ "ds=http://www.w3.org/2000/09/xmldsig#=https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd";
	// File locations
	private static final String NIEM_DIR = "niem";
	private static final String WANTLIST_FILE = "wantlist.xml";
	private static final String XML_CATALOG_FILE = "xml-catalog.xml";
	private static final String MPD_CATALOG_FILE = "mpd-catalog.xml";
	private static final String CONFORMANCE_ASSERTION_FILE = "conformance-assertion.pdf";
	// Niem stereotype configuration
	public static final String NIEM_STEREOTYPE_TYPE = "niem-profile:niem";
	public static final String WEBSERVICE_STEREOTYPE_TYPE = "niem-profile:webservice";
	
	private static final String STEREOTYPE_DELIMITER = ":";
	// private static final String NIEM_STEREOTYPE_LABEL = "niem:niem";
	// NIEM mapping spreadsheet column headings, NIEM profile profile stereotype
	private static final String[][] NIEM_STEREOTYPE_MAP = { { "Model Class", "", }, // 0
			{ "Model Attribute", "", }, // 1
			{ "Model Multiplicity", "", }, // 2
			{ "Model Definition", "", }, // 3
			{ "NIEM XPath", "XPath" }, // 4
			{ "NIEM Type", "Type" }, // 5
			{ "NIEM Property, " + REFERENCE_PREFIX + "Reference, (Representation)", "Property" }, // 6
			{ "NIEM Base Type", "BaseType" }, // 7
			{ "NIEM Multiplicity", "Multiplicity" }, // 8
			{ "Old XPath", "OldXPath" }, // 9
			{ "Old Multiplicity", "OldMultiplicity" }, // 10
			{ "NIEM Mapping Notes", "Notes" }, // 11
			{ "Code List Code=Definition;", "CodeList" } }; // 12

	// private static final String NIEM_STEREOTYPE_CLASS = NIEM_STEREOTYPE_TYPE +
	// STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[0][1];
	// private static final String NIEM_STEREOTYPE_ATTRIBUTE = NIEM_STEREOTYPE_TYPE
	// + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[1][1];
	// private static final String NIEM_STEREOTYPE_MODEL_MULTIPLICITY =
	// NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[2][1];
	// private static final String NIEM_STEREOTYPE_DEFINITION = NIEM_STEREOTYPE_TYPE
	// + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[3][1];
	private static final String NIEM_STEREOTYPE_XPATH = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[4][1];
	private static final String NIEM_STEREOTYPE_TYPENAME = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[5][1];
	private static final String NIEM_STEREOTYPE_PROPERTY = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[6][1];
	private static final String NIEM_STEREOTYPE_BASE_TYPE = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[7][1];
	private static final String NIEM_STEREOTYPE_MULTIPLICITY = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[8][1];
	// private static final String NIEM_STEREOTYPE_OLD_XPATH = NIEM_STEREOTYPE_TYPE
	// + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[9][1];
	// private static final String NIEM_STEREOTYPE_OLD_MULTIPLICITY =
	// NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[10][1];
	private static final String NIEM_STEREOTYPE_NOTES = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[11][1];
	private static final String NIEM_STEREOTYPE_CODE_LIST = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[12][1];

	private static final String HTTP_METHODS_PROPERTY = WEBSERVICE_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + "HTTPMethods";
	
	private static Set<String> externalPrefixes = new HashSet<String>();
	private static Map<String, String> externalSchemaURL = new HashMap<String, String>();

	private static UmlClass referenceAbstractType = null;
	private static UmlClass subsetAbstractType = null;
	private static UmlClass subsetAugmentationType = null;
	private static UmlClass subsetObjectType = null;
	private static UmlClass subsetSimpleObjectAttributeGroup = null;
	public static int importPass;
	public static String importPath;
	private static Map<String, UmlClassInstance> NiemElements = new HashMap<String, UmlClassInstance>();
	private static Map<String, List<UmlClassInstance>> NiemElementsInType = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, Namespace> Namespaces = new HashMap<String, Namespace>();
	private static Map<String, String> Prefixes = new HashMap<String, String>();
	private static Map<String, UmlClass> NiemTypes = new HashMap<String, UmlClass>();
	private static Map<String, List<UmlClassInstance>> Substitutions = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, UmlClassInstance> SubsetElements = new HashMap<String, UmlClassInstance>();
	private static Map<String, List<UmlClassInstance>> SubsetElementsInType = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, UmlClass> SubsetTypes = new HashMap<String, UmlClass>();

	private static Map<String, UmlClassInstance> ExtensionElements = new HashMap<String, UmlClassInstance>();
	private static Map<String, List<UmlClassInstance>> ExtensionElementsInType = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, UmlClass> ExtensionTypes = new HashMap<String, UmlClass>();

	private static UmlPackage subsetPackage = null, extensionPackage = null, referencePackage = null;
	private static XPath xPath = XPathFactory.newInstance().newXPath();

	private static Set<String> CodeListNamespaces = new HashSet<String>();

	/** returns an element added to reference or extension model */
	private static UmlClassInstance addElement(UmlPackage modelPackage, String elementSchemaURI, String elementName,
			String baseTypeSchemaURI, String baseTypeName, String description, String notes) {

		if (elementName.equals("") || elementName.equals("??"))
			return null;

		// get element if it exists
		UmlClassInstance element = getElement(modelPackage, elementSchemaURI, elementName);

		// if not, create element
		if (element == null) {

			// find base type - default to abstract type if type name not defined
			UmlClass baseType = null;
			if (baseTypeName != null)
				if (modelPackage == referencePackage)
					baseType = getType(referencePackage, baseTypeSchemaURI, baseTypeName);
				else
					baseType = getType(null, baseTypeSchemaURI, baseTypeName);

			if (baseType == null) {
				if (baseTypeName != null)
					UmlCom.trace("addElement: error - base type " + baseTypeName + " not in model with URI "
							+ baseTypeSchemaURI);
				baseType = (modelPackage == referencePackage) ? referenceAbstractType : subsetAbstractType;
			}
			// create element
			UmlClassView nsClassView = getNamespace(modelPackage, getPrefix(elementName), elementSchemaURI);
			if (nsClassView == null) {
				UmlCom.trace("addElement: error - no prefix or schema for element " + elementName);
				return null;
			}
			try {
				element = UmlClassInstance.create(nsClassView, filterUMLElement(getName(elementName)), baseType);
			} catch (RuntimeException e) {
				UmlCom.trace("addElement: error adding element " + elementName + " of type " + baseType.name());
				return null;
			}
			element.set_Description(description);
			String uri = getURI(elementSchemaURI, elementName);
			setURI(element, uri);
			if (modelPackage == referencePackage)
				NiemElements.put(uri, element);
			else if (modelPackage == subsetPackage)
				SubsetElements.put(uri, element);
			else if (modelPackage == extensionPackage)
				ExtensionElements.put(uri, element);
			trace("addElement: added " + elementName);
		}

		// add notes
		setNotes(element, notes);
		return element;
	}

	/** returns an element in type added to reference model or extension */
	private static UmlAttribute addElementInType(UmlClass type, UmlClassInstance element, String multiplicity) {

		// return null if element or type do not exist
		if (type == null || element == null)
			return null;

		// get element in type if it exists
		// trace("addElementInTypes: inserting element " + element.name() + " to type "
		// + type.name());
		String elementInTypeName = getPrefixedName(element);
		String typeName = getPrefixedName(type);
		UmlAttribute elementInType = getElementInType(type, elementInTypeName, multiplicity);

		// create element in type
		if (elementInType == null)
			try {
				elementInType = UmlAttribute.create(type, elementInTypeName);
			} catch (RuntimeException re) {
				// trace("addElementInType: error - element " + elementInTypeName + " already
				// exists in type " + type.name());
				return null;
			}

		// copy element properties
		setURI(elementInType, getURI(element));
		if (element.description() != null)
			elementInType.set_Description(element.description());
		if (multiplicity != null)
			elementInType.set_Multiplicity(multiplicity);

		// relate element in type to element
		relateElementInType(elementInType, element);

		// insert element in type list
		List<UmlClassInstance> elementInTypeList = getElementsInType(getModel(type), getURI(type));
		if (!elementInTypeList.contains(element)) {
			elementInTypeList.add(element);
			trace("addElementInTypes: inserted " + elementInTypeName + " to " + typeName);
		}
		return elementInType;
	}

	/** returns a type added to the reference or extension models */
	private static UmlClass addType(UmlPackage modelPackage, String typeSchemaURI, String typeName, String description,
			String notes) {
		// trace("addType: adding " + typeName + " to schema " + typeSchemaURI);
		UmlClass type = getType(modelPackage, typeSchemaURI, typeName);
		if (type == null) {
			// create type
			UmlClassView nsClassView = getNamespace(modelPackage, getPrefix(typeName), typeSchemaURI);
			if (nsClassView == null) {
				UmlCom.trace("addType: error - no prefix or schema for type " + typeName);
				return null;
			}
			try {
				type = UmlClass.create(nsClassView, filterUMLType(getName(typeName)));
			} catch (RuntimeException re) {
				UmlCom.trace("addType: error adding type " + typeName);
				return null;
			}
			String uri = getURI(typeSchemaURI, typeName);
			setURI(type, uri);
			if (modelPackage == referencePackage)
				NiemTypes.put(uri, type);
			else if (modelPackage == subsetPackage)
				SubsetTypes.put(uri, type);
			else if (modelPackage == extensionPackage)
				ExtensionTypes.put(uri, type);
			trace("addType: added " + typeName);
		}
		setDescription(type, description);
		setNotes(type, notes);
		return type;
	}

	/** caches namespaces and prefixes for external schemas */
	private static void cacheExternalSchemas() {
		String externalSchemas = getProperty(IEPD_EXTERNAL_SCHEMAS_PROPERTY);
		String[] external = externalSchemas.split(",");
		for (int schemaIndex = 0; schemaIndex < external.length; schemaIndex++) {
			String[] part = external[schemaIndex].split("=");
			if (part.length > 2) {
				String prefix = part[0].trim();
				String schemaURI = part[1].trim();
				String schemaLocation = part[2].trim();
				externalPrefixes.add(prefix);
				Prefixes.put(prefix, schemaURI);
				externalSchemaURL.put(schemaURI, schemaLocation);
			}
		}
		// trace("cacheExternalSchemas: external schemas cached");
	}

	/**
	 * caches elements, types and elements in types of NIEM reference, subset or
	 * extension model
	 */
	private static void cacheModel(UmlPackage modelPackage) {
		if (modelPackage == null)
			return;

		UmlCom.trace("cacheModel: caching model " + modelPackage.name());
		// Cache namespaces, types and elements
		String schemaURI;
		Map<String, UmlClassInstance> Elements = null;
		Map<String, List<UmlClassInstance>> ElementsInType = null;
		Map<String, UmlClass> Types = null;

		if (modelPackage == referencePackage) {
			Elements = NiemElements;
			ElementsInType = NiemElementsInType;
			Types = NiemTypes;
		} else if (modelPackage == subsetPackage) {
			Elements = SubsetElements;
			ElementsInType = SubsetElementsInType;
			Types = SubsetTypes;
		} else if (modelPackage == extensionPackage) {
			Elements = ExtensionElements;
			ElementsInType = ExtensionElementsInType;
			Types = ExtensionTypes;
		} else
			return;

		trace("cacheModel: caching namespaces, types and elements");
		for (UmlItem classView : modelPackage.children()) {
			if (classView.kind() != anItemKind.aClassView)
				continue;
			schemaURI = getURI(classView);
			String prefix = classView.propertyValue(PREFIX_PROPERTY);
			if (!Prefixes.containsKey(prefix))
				Prefixes.put(prefix, schemaURI);
			Namespace ns = Namespaces.get(schemaURI);
			if ((ns == null) && (schemaURI != null)) {
				// create namespace
				ns = new Namespace(schemaURI);
				Namespaces.put(schemaURI, ns);
			}
			if (modelPackage == referencePackage)
				ns.referenceClassView = (UmlClassView) classView;
			else
				ns.nsClassView = (UmlClassView) classView;

			if (modelPackage == referencePackage || modelPackage == extensionPackage)
				ns.filepath = classView.propertyValue(FILE_PATH_PROPERTY);

			// cache types and elements
			for (UmlItem item : classView.children()) {
				String uri = getURI(item);
				if (uri != null) {
					switch (item.kind().value()) {
					case anItemKind._aClass:
						if (!Types.containsKey(uri))
							Types.put(uri, (UmlClass) item);
						break;
					case anItemKind._aClassInstance:
						UmlClassInstance element = (UmlClassInstance) item;
						if (!Elements.containsKey(uri))
							Elements.put(uri, element);
						String headElement = element.propertyValue(SUBSTITUTION_PROPERTY);
						if (headElement != null) {
							List<UmlClassInstance> enlist = (List<UmlClassInstance>) (Substitutions.get(headElement));
							if (enlist == null) {
								enlist = new ArrayList<UmlClassInstance>();
								Substitutions.put(headElement, enlist);
							}
							if (!enlist.contains(element))
								enlist.add(element);
						}
						break;
					default:
						break;
					}
				}
			}
		}

		// Cache elements in types
		trace("cacheModel: caching elements in types");
		for (UmlClass type : Types.values()) {
			String typeURI = getURI(type);
			List<UmlClassInstance> list = (List<UmlClassInstance>) (ElementsInType.get(typeURI));
			if (list == null) {
				list = new ArrayList<UmlClassInstance>();
				ElementsInType.put(typeURI, list);
			}
			for (UmlItem attribute : type.children())
				if (attribute.kind() == anItemKind.anAttribute) {
					// trace("cacheModel: caching " + getURI(attribute));
					UmlClassInstance element = (UmlClassInstance) Elements.get(getURI(attribute));
					if (!list.contains(element))
						list.add(element);
				}
		}

		trace("cacheModel: store caches and add simple and abstract types");
		if (modelPackage == referencePackage) {
			NiemElements = Elements;
			NiemElementsInType = ElementsInType;
			NiemTypes = Types;

			// add local namespace and abstract type
			getNamespace(referencePackage, LOCAL_PREFIX, LOCAL_URI);
			referenceAbstractType = addType(referencePackage, LOCAL_URI,
					getPrefixedName(LOCAL_PREFIX, ABSTRACT_TYPE_NAME), null, null);

			// add XML namespace, simple types and any element
			getNamespace(referencePackage, XML_PREFIX, XML_URI);
			for (String typeName : XML_TYPE_NAMES)
				addType(referencePackage, XSD_URI, getPrefixedName(XSD_PREFIX, typeName), null, null);
			addElement(referencePackage, XSD_URI, getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME), null, null, null,
					null);
		} else if (modelPackage == subsetPackage) {
			SubsetElements = Elements;
			SubsetElementsInType = ElementsInType;
			SubsetTypes = Types;
			subsetAbstractType = copyType(getPrefixedName(LOCAL_PREFIX, ABSTRACT_TYPE_NAME));
			subsetAugmentationType = copyType(getPrefixedName(STRUCTURES_PREFIX, AUGMENTATION_TYPE_NAME));
			subsetObjectType = copyType(getPrefixedName(STRUCTURES_PREFIX, OBJECT_TYPE_NAME));
			subsetSimpleObjectAttributeGroup = copyType(
					getPrefixedName(STRUCTURES_PREFIX, SIMPLE_OBJECT_ATTRIBUTE_GROUP));
			getNamespace(subsetPackage, XSD_PREFIX, XSD_URI);
			copyElement(getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME));
			copyType("xs:NCName"); // JSON-LD @id is type xs:NCName
		} else if (modelPackage == extensionPackage) {
			ExtensionElements = Elements;
			ExtensionElementsInType = ElementsInType;
			ExtensionTypes = Types;
		}
		trace("cacheModels: model " + modelPackage.name() + " cached");
	}

	/** returns an element copied from reference model to subset */
	private static UmlClassInstance copyElement(String elementName) {

		// return subset element if it exists
		String schemaURI = getSchemaURI(elementName);
		UmlClassInstance element = getElement(subsetPackage, schemaURI, elementName);
		if (element != null)
			return element;

		// if element doesn't exist in reference model, return error
		UmlClassInstance sourceElement = getElement(referencePackage, schemaURI, elementName);
		if (sourceElement == null) {
			UmlCom.trace("copyElement: error - element " + elementName + " not in reference model");
			return null;
		}

		// copy base type if not already in subset
		UmlClass sourceBaseType = getBaseType(sourceElement);
		String baseTypeName = getPrefixedName(sourceBaseType);
		UmlClass baseType = getType(subsetPackage, getSchemaURI(baseTypeName), baseTypeName);
		if (baseType == null)
			baseType = copyType(baseTypeName);

		// if namespace doesn't exist, create it
		UmlClassView nsClassView = getNamespace(subsetPackage, getPrefix(elementName), schemaURI);
		if (nsClassView == null) {
			UmlCom.trace("addElement: error - no prefix or schema for element " + elementName);
			return null;
		}

		// create element
		try {
			element = UmlClassInstance.create(nsClassView, filterUMLElement(getName(elementName)), baseType);
		} catch (RuntimeException e) {
			UmlCom.trace("copyElement: error copying element " + elementName + " to subset");
			return null;
		}
		element.set_Description(sourceElement.description());
		String uri = getURI(schemaURI, elementName);
		setURI(element, uri);
		SubsetElements.put(uri, element);
		trace("copyElement: element " + elementName + " copied to subset");
		return element;
	}

	/** returns an element in type copied from reference model to subset */
	private static UmlAttribute copyElementInType(UmlClass type, UmlClassInstance element, String multiplicity) {
		String elementInTypeName = getPrefixedName(element);
		String typeName = getPrefixedName(type);
		UmlAttribute attribute = getElementInType(type, elementInTypeName, multiplicity);
		if (attribute == null)
			try {
				attribute = UmlAttribute.create(type, elementInTypeName);
			} catch (RuntimeException re) {
				trace("copyElementInType: error - attribute already exists " + element + " " + re.toString());
			}
		if (attribute == null)
			UmlCom.trace("copyElementInType: error copying element " + elementInTypeName + " in " + typeName);
		else {
			attribute.set_Description(element.description());
			setURI(attribute, getURI(element));
			relateElementInType(attribute, element);
			attribute.set_Multiplicity(multiplicity);
		}
		trace("addElementInTypes: inserted " + elementInTypeName + " to " + typeName);
		return attribute;
	}

	/** returns a type copied from the reference model to subset */
	private static UmlClass copyType(String typeName) {

		if ((typeName == null) || (typeName.equals("")))
			return null;
		String schemaURI = getSchemaURI(typeName);
		if (schemaURI == null) {
			UmlCom.trace("copyType: error - schema for type " + typeName + " not in reference model");
			return null;
		}

		// return subset type if it exists
		UmlClass type = getType(subsetPackage, schemaURI, typeName);
		if (type != null)
			return type;

		// find reference type
		UmlClass sourceType = getType(referencePackage, schemaURI, typeName);
		if (sourceType == null) {
			UmlCom.trace("copyType: error - type " + typeName + " not in reference model");
			return null;
		}

		// if subset namespace doesn't exist, create it
		UmlClassView nsClassView = getNamespace(subsetPackage, getPrefix(typeName), schemaURI);
		if (nsClassView == null) {
			UmlCom.trace("copyType: error - no prefix or schema for type " + typeName);
			return null;
		}

		// create type
		// trace("copyType: copying type " + typeName + " to subset schema " +
		// nsClassView.name());
		try {
			type = UmlClass.create(nsClassView, filterUMLType(getName(typeName)));
		} catch (RuntimeException e) {
			trace("copyType: error - type already exists " + typeName + " " + e.toString());
			return null;
		}

		// copy type properties
		if (sourceType.description() != null)
			type.set_Description(sourceType.description());
		setURI(type, getURI(sourceType));
		String codeList = sourceType.propertyValue(CODELIST_PROPERTY);
		if (codeList != null)
			type.set_PropertyValue(CODELIST_PROPERTY, codeList);
		SubsetTypes.put(getURI(type), type);

		// copy and relate to base type
		UmlClass sourceBaseType = getBaseType(sourceType);
		if (sourceBaseType != null) {
			String baseTypeName = getPrefixedName(sourceBaseType);
			UmlClass baseType = copyType(baseTypeName);
			if (baseType != null)
				relateBaseType(type, baseType);
		}

		// copy elements and attributes in type
		for (UmlItem item : sourceType.children())
			if (isAttribute(item)) {
				UmlClassInstance sourceElement = getElementByURI(referencePackage, getURI(item));
				if (sourceElement == null) {
					UmlCom.trace("copyType: error - no element for uri " + getURI(item) + " in reference model");
					continue;
				}
				String attributeName = getPrefixedName(sourceElement);
				UmlClassInstance element = copyElement(attributeName);
				if (element == null)
					UmlCom.trace("copyType: error - no attribute " + attributeName);
				else
					copyElementInType(type, element, ((UmlAttribute) item).multiplicity());
			}

		// copy and relate to attribute groups
		UmlClass attributeGroupType = getAttributeGroup(sourceType);
		if (attributeGroupType != null) {
			String attributeGroupName = getPrefixedName(attributeGroupType);
			UmlClass attributeGroup = copyType(attributeGroupName);
			if (attributeGroup == null)
				UmlCom.trace("copyType: error - no attribute group " + attributeGroupName);
			else
				relateAttributeGroup(type, attributeGroupType);
		}
		trace("copyType: type copied " + typeName);
		return type;
	}

	/** exports a Genericode code list */
	private static void exportCodeLists(UmlPackage modelPackage, String dir) {

		String version = getProperty(IEPD_VERSION_PROPERTY);
		DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date();
		String today = dateFormat.format(date);

		// export code lists for extension elements
		for (UmlItem item : modelPackage.children()) {
			if (item.kind() != anItemKind.aClassView)
				continue;
			UmlClassView classView = (UmlClassView) item;
			//classView.sort();
			for (UmlItem item2 : classView.children()) {
				if (item2.kind() != anItemKind.aClassInstance)
					continue;
				UmlClassInstance element = (UmlClassInstance) item2;
				String elementName = getName(element);
				String codeList = element.propertyValue(CODELIST_PROPERTY);
				if (codeList == null || codeList.trim().equals(""))
					continue;
				String codeListURI = getExtensionSchema(elementName);
				CodeListNamespaces.add(elementName);

				// export code list
				trace("exportCodeList: exporting code list " + elementName + GC_FILE_TYPE);
				try {
					File file = Paths.get(dir, elementName + GC_FILE_TYPE).toFile();
					File parentFile = file.getParentFile();
					if (parentFile != null)
						parentFile.mkdirs();
					FileWriter fw = new FileWriter(file);
					fw.write(XML_HEADER + XML_ATTRIBUTION + "<gc:CodeList ");
					writeXmlNs(fw, CT_PREFIX, CT_URI);
					writeXmlNs(fw, GC_PREFIX, GC_URI);
					writeXmlNs(fw, GC_APPINFO_PREFIX, GC_APPINFO_URI);
					writeXmlNs(fw, XSI_PREFIX, XSI_URI);
					writeXmlAttribute(fw, XSI_PREFIX + ":schemaLocation", GC_URI + " " + GC_LOCATION);
					fw.write(">" + "<Annotation>" + "<AppInfo>" + "<gca:ConformanceTargets ct:conformanceTargets=\""
							+ CODELIST_URI + "#GenericodeCodeListDocument\"/>" + "</AppInfo>" + "</Annotation>"
							+ "<Identification>" + "<ShortName>" + elementName + "</ShortName>" + "<Version>" + version
							+ "</Version>" + "<CanonicalUri>" + codeListURI + "</CanonicalUri>" + "<CanonicalVersionUri>"
							+ codeListURI + "/" + today + "</CanonicalVersionUri>" + "</Identification>" + "<ColumnSet>"
							+ "<Column Id=\"" + CODELIST_CODE + "\" Use=\"required\">" + "<ShortName>" + CODELIST_CODE
							+ "</ShortName>" + "<CanonicalUri>" + CODELIST_URI + "column/" + CODELIST_CODE + "</CanonicalUri>"
							+ "<Data Type=\"normalizedString\" Lang=\"en\"/>" + "</Column>" + "<Column Id=\""
							+ CODELIST_DEFINITION + "\" Use=\"optional\">" + "<ShortName>" + CODELIST_DEFINITION
							+ "</ShortName>" + "<CanonicalUri>" + CODELIST_URI + "column/" + CODELIST_DEFINITION
							+ "</CanonicalUri>" + "<Data Type=\"normalizedString\" Lang=\"en\"/>" + "</Column>"
							+ "<Key Id=\"codeKey\">" + "<ShortName>CodeKey</ShortName>" + "<ColumnRef Ref=\"" + CODELIST_CODE
							+ "\"/>" + "</Key>" + "</ColumnSet>" + "<SimpleCodeList>");
					if (codeList.contains(CODELIST_DELIMITER)) {
						String[] codes = codeList.split(CODELIST_DELIMITER);
						for (String code : codes) {
							String[] pairs = code.split(CODELIST_DEFINITION_DELIMITER);
							fw.write("<Row><Value ColumnRef=\"" + CODELIST_CODE + "\"><SimpleValue>" + pairs[0].trim()
									+ "</SimpleValue></Value>");
							if (pairs.length > 1)
								fw.write("<Value ColumnRef=\"" + CODELIST_DEFINITION + "\"><SimpleValue>" + pairs[1].trim()
										+ "</SimpleValue></Value>");
							fw.write("</Row>");
						}
					}
					fw.write("</SimpleCodeList></gc:CodeList>");
					fw.close();

				} catch (IOException e) {
					UmlCom.trace("exportCodeList: IO exception: " + e.toString());
				} catch (RuntimeException e) {
					UmlCom.trace("exportCodeList: Runtime Exception: " + e.toString());
				}
			}
		}
	}

	/**
	 * return JSON property description of an element with name elementName and
	 * multiplicity
	 */
	private static String exportJsonElementInTypeSchema(String elementName, String multiplicity, String localPrefix, boolean isAttribute) {
		String elementName2 = null;
		String minOccurs = getMinOccurs(multiplicity);
		String maxOccurs = getMaxOccurs(multiplicity);
		if (isAttribute) {
			if (elementName.equals(getPrefixedName(STRUCTURES_PREFIX, "@id")) || elementName.equals(getPrefixedName(STRUCTURES_PREFIX, "@ref"))) {
				elementName = "xs:NCName";
				elementName2 = "@id";
			} else {
				elementName = filterAttributePrefix(elementName);
				elementName2 = elementName;
			}
		} else
			elementName2 = elementName;
		String elementSchema = "";
		elementSchema += "\"" + elementName2 + "\": {\n";
		if (maxOccurs.equals("1"))
			elementSchema += "\"$ref\": \"" + exportJsonPointer(elementName, localPrefix) + "\"\n";
		else {
			elementSchema += "\"oneOf\": [";
			if (minOccurs.equals("0") || minOccurs.equals("1")) {
				elementSchema += "{\n" + "\"$ref\": \"" + exportJsonPointer(elementName, localPrefix) + "\"\n"
						+ "},\n";
			}
			elementSchema += "{\n" + "\"items\": {\n" + "\"$ref\": \""
					+ exportJsonPointer(elementName, localPrefix) + "\"\n" + "},\n" + "\n\"minItems\": "
					+ minOccurs + ",\n";
			if (!maxOccurs.equals("unbounded"))
				elementSchema += "\n\"maxItems\": " + maxOccurs + ",\n";
			elementSchema += "\"type\": \"array\"\n" + "}\n" + "]\n";
		}
		elementSchema += "}";
		return elementSchema;
	}

	/** return JSON schema element definition */
	private static String exportJsonElementSchema(UmlClassInstance element, String prefix) {
		String elementName = filterAttributePrefix(getPrefixedName(element));
		TreeSet<String> jsonDefinition = new TreeSet<String>();
		String description = element.description();
		if (description != null && description.equals(""))
			jsonDefinition.add("\"description\": \"" + filterQuotes(description) + "\"");
		UmlClass baseType = getBaseType(element);

		// if derived from XSD primitive, use the primitive as base type
		UmlClass baseType2 = baseType;
		UmlClass nextBaseType = getBaseType(baseType);
		while (nextBaseType != null) {
			baseType2 = nextBaseType;
			nextBaseType = getBaseType(baseType2);
		}
		if (getPrefix(baseType2).equals(XSD_PREFIX))
			baseType = baseType2;
		jsonDefinition.add("\"$ref\": \"" + exportJsonPointer(getPrefixedName(baseType), prefix) + "\"");
		String elementSchema = "\"" + elementName + "\": {\n" + String.join(",", jsonDefinition) + "\n}\n";
		return elementSchema;
	}

	/** return JSON Pointer to a type with name typeName */
	private static String exportJsonPointer(String tagName, String localPrefix) {
		if (tagName == null)
			return "";
		String prefix = getPrefix(tagName);
		if (prefix == null)
			return "";
		if (isExternalPrefix(prefix))
			return "";
		else if (localPrefix != null && prefix.equals(localPrefix))
			return "#/definitions/" + tagName;
		if (isNiemPrefix(prefix) && !isNiemPrefix(localPrefix))
			return NIEM_DIR + "/" + prefix + JSON_SCHEMA_FILE_TYPE + "#/definitions/" + tagName;
		else if (!isNiemPrefix(prefix) && isNiemPrefix(localPrefix))
			return "../" + prefix + JSON_SCHEMA_FILE_TYPE + "#/definitions/" + tagName;
		else
			return "" + prefix + JSON_SCHEMA_FILE_TYPE + "#/definitions/" + tagName;
	}

	/** return JSON type definition corresponding to an XML Schema primitive type */
	private static String exportJsonPrimitiveSchema(UmlClass type) {
		String jsonType = "\"" + getPrefixedName(type) + "\": {\n";
		switch (getName(type)) {
		case "boolean":
			jsonType += "\"type\": \"boolean\"\n";
			break;

			// numeric types
		case "decimal":
		case "double":
		case "float":
			jsonType += "\"type\": \"number\"\n";
			break;
		case "int":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": –2147483648,\n";
			jsonType += "\"maximum\": 2147483647\n";
			break;
		case "integer":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0\n";
			break;
		case "long":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": -9223372036854775808,\n";
			jsonType += "\"maximum\": 9223372036854775807\n";
			break;
		case "unsignedLong":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": 0,\n";
			jsonType += "\"maximum\": 18446744073709551615\n";
			break;
		case "unsignedInt":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": 0,\n";
			jsonType += "\"maximum\": 4294967295\n";
			break;
		case "short":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": -32768,\n";
			jsonType += "\"maximum\": 32767\n";
			break;
		case "unsignedShort":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": 0,\n";
			jsonType += "\"maximum\": 65535\n";
			break;
		case "byte":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": -128,\n";
			jsonType += "\"maximum\": 127\n";
			break;
		case "unsignedByte":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": 0,\n";
			jsonType += "\"maximum\": 255\n";
			break;
		case "negativeInteger":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"maximum\": -1\n";
			break;
		case "nonNegativeInteger":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": 0\n";
			break;
		case "nonPositiveInteger":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"maximum\": 0\n";
			break;
		case "positiveInteger":
			jsonType += "\"type\": \"number\",\n";
			jsonType += "\"multipleOf\": 1.0,\n";
			jsonType += "\"minimum\": 1\n";
			break;

			// date/time types
		case "date":
		case "dateTime":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"format\": \"date-time\"\n";
			break;
		case "time":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^([0-9]{2}):([0-9]{2}):([0-9]{2}([.][0-9]{1,6})?)([+-]([0-9]{2}):([0-9]{2}))?$\"\n";
			break;
		case "duration":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^[-+]?P(([0-9]d+Y)|([0-9]+M)|([0-9]+D)|(T([0-9]+H)|([0-9]+M)|([0-9]+([.][0-9]{1,6})?S)))$\"\n";
			break;
		case "gDay":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^---[0-3][0-9]$\"\n";
			break;
		case "gMonth":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^--[0-1][0-9]$\"\n";
			break;
		case "gMonthDay":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^--[0-1][0-9]-[0-3][0-9]$\"\n";
			break;
		case "gYear":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^[0-9]{4}$\"\n";
			break;
		case "gYearMonth":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^[0-9]{4}-[0-1][0-9]$\"\n";
			break;

			// string types
		case "token":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^\\\\S*$\"\n";
			break;
		case "normalizedString":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^\\\\s?(\\\\S+\\\\s?)+\\\\s?$\"\n";
			break;
		case "NMTOKEN":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^[-.:_A-Za-z0-9]+$\"\n";
			break;
		case "NMTOKENS":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^([-.:_A-Za-z0-9]+\\\\s)+$\"\n";
			break;
		case "NAME":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^[_:A-Za-z][-.:_A-Za-z0-9]*$\"\n";
			break;
		case "language":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$\"\n";
			break;
		case "hexBinary":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^([A-Z0-9]{2})*$\"\n";
			break;
		case "base64Binary":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^[A-Za-z0-9+/=\\\\s]*$\"\n";
			break;

			// reference types
		case "anyURI":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"format\": \"uri\"\n";
			break;
		case "ID":
		case "IDREF":
		case "NCNAME":
		case "ENTITY":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^[_A-Za-z][-._A-Za-z0-9]*$\"\n";
			break;
		case "IDREFS":
		case "ENTITIES":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^([_A-Za-z][-._A-Za-z0-9]*\\\\s)*$\"\n";
			break;
		case "NOTATION":
		case "QName":
			jsonType += "\"type\": \"string\",\n";
			jsonType += "\"pattern\": \"^[_A-Za-z][-._A-Za-z0-9]*:[_A-Za-z][-._A-Za-z0-9]*$\"\n";
			break;

		default:
			jsonType += "\"type\": \"string\"\n";
		}
		jsonType += "}\n";
		return jsonType;
	}

	/** return JSON schema type definition */
	private static String exportJsonTypeSchema(UmlClass type, String prefix) {
		// add properties
		// type.sortChildren();
		TreeSet<String> jsonRequiredElementsInType = new TreeSet<String>();
		TreeSet<String> jsonElementsInType = new TreeSet<String>();
		String anyElement = getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME);
		Boolean anyJSON = false;
		UmlClass type2 = type, baseType2 = null;
		while (type2 != null) {
			for (UmlItem item4 : type2.children()) {
				if (item4.kind() == anItemKind.anAttribute) {
					UmlAttribute attribute = (UmlAttribute) item4;
					UmlClassInstance element = getElementByURI(null, getURI(attribute));
					if (element == null)
						continue;
					String elementName = getPrefixedName(element);
					boolean elementIsAttribute = isAttribute(element);
					trace("exportSchema: exporting element in type " + elementName);
					if (elementName.equals(anyElement)) {
						anyJSON = true;
						continue;
					}
					// if (complexContent)
					String multiplicity = attribute.multiplicity();
					UmlClass elementBaseType = getBaseType(element);
					// if (elementBaseType == null && elementName.endsWith(AUGMENTATION_TYPE_NAME))
					// elementBaseType = subsetAugmentationType;

					if (Substitutions.containsKey(elementName)) {
						// relax minoccurs if substitutions
						String multiplicity2 = "0," + getMaxOccurs(multiplicity);
						// add head element if not abstract
						if ((elementBaseType != subsetAbstractType)) {
							String jsonElementInType = exportJsonElementInTypeSchema(elementName, multiplicity2, prefix, elementIsAttribute);
							if (jsonElementInType != null)
								jsonElementsInType.add(jsonElementInType);
						}
						List<UmlClassInstance> enlist = (List<UmlClassInstance>) (Substitutions.get(elementName));
						// add substitution elements
						for (UmlClassInstance element2 : enlist) {
							String jsonElementInType = exportJsonElementInTypeSchema(getPrefixedName(element2), multiplicity2, prefix, isAttribute(element2));
							if (jsonElementInType != null)
								jsonElementsInType.add(jsonElementInType);
						}
					} else if ((elementBaseType != subsetAbstractType)) {
						String jsonElementInType = exportJsonElementInTypeSchema(elementName, multiplicity, prefix, elementIsAttribute);
						if (jsonElementInType != null)
							jsonElementsInType.add(jsonElementInType);
						if (Integer.parseInt(getMinOccurs(multiplicity)) > 0)
							jsonRequiredElementsInType.add("\"" + elementName + "\"");
					}
				}
				if (item4.kind() == anItemKind.aRelation) {
					UmlRelation relation = (UmlRelation) item4;
					if (relation.relationKind() == aRelationKind.aGeneralisation) // base type
						baseType2 = relation.roleType();
					if (relation.relationKind() == aRelationKind.aDirectionalAggregation) { // attributeGroup
						UmlClass sourceBaseType = relation.roleType();
						for (UmlItem item5 : sourceBaseType.children()) {
							if (item5.kind() != anItemKind.anAttribute)
							//	if (getName(item5).equals("@id") || getName(item5).equals("@ref"))
									continue;
							UmlAttribute attribute = (UmlAttribute) item5;
							UmlClassInstance element = getElementByURI(null, getURI(attribute));
							if (element == null || !isAttribute(element))
								continue;
							String elementName = getPrefixedName(element);
							UmlClass elementBaseType = getBaseType(element);
							String multiplicity = attribute.multiplicity();
							String minOccurs = getMinOccurs(multiplicity);
							if ((elementBaseType != subsetAbstractType) && (elementBaseType != referenceAbstractType)) {
								String jsonElementInType = exportJsonElementInTypeSchema(elementName, multiplicity, prefix, isAttribute(element));
								if (jsonElementInType != null)
									jsonElementsInType.add(jsonElementInType);
								if (Integer.parseInt(minOccurs) > 0)
									jsonRequiredElementsInType.add("\"" + elementName + "\"");
							}
						}
					}
				}
			}
			type2 = baseType2;
			baseType2 = null;
		}
		// get code list
		String codeList = type.propertyValue(CODELIST_PROPERTY);
		Set<String> enums = new HashSet<String>();
		if (codeList != null && codeList.equals("")) {
			for (String code : codeList.split(CODELIST_DELIMITER)) {
				if (code.equals(""))
					continue;
				String[] codeParams = code.replace("&", "&amp;").split(CODELIST_DEFINITION_DELIMITER);
				String codeValue = codeParams[0].trim();
				if (!codeValue.equals(""))
					enums.add("\"" + codeValue + "\"");
			}
		}
		// define JSON type
		TreeSet<String> jsonDefinition = new TreeSet<String>();
		String description = type.description();
		if (description != null && !description.equals(""))
			jsonDefinition.add("\"description\": \"" + filterQuotes(description) + "\"");
		//UmlClass baseType = getBaseType(type);
		//if (baseType != null)
		//	jsonDefinition.add("\"$ref\": \"" + exportJsonTypePointer(getPrefixedName(baseType), prefix) + "\"");
		jsonDefinition.add("\"type\": \"object\"");
		jsonDefinition.add("\"additionalProperties\" : " + anyJSON);
		if (codeList != null && codeList.equals(""))
			jsonDefinition.add("\"enums\": [" + String.join(",", enums) + "]");
		if (jsonElementsInType != null)
			jsonDefinition.add("\"properties\": {\n" + String.join(",", jsonElementsInType) + "\n}");
		if (jsonRequiredElementsInType != null)
			jsonDefinition.add("\"required\" : [" + String.join(", ", jsonRequiredElementsInType) + "]");
		String typeSchema = "\"" + getPrefixedName(type) + "\": {\n" + String.join(",", jsonDefinition) + "\n}\n";
		return typeSchema;
	}

	/** exports a NIEM MPD catalog */
	private static void exportMPDCatalog(String xmlDir, Set<String> CodeListNamespaces, Set<String> messages)
			throws IOException {
		DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date();
		String today = dateFormat.format(date);

		UmlCom.trace("Generating MPD catalog");
		File file = Paths.get(xmlDir, MPD_CATALOG_FILE).toFile();
		File parentFile = file.getParentFile();
		if (parentFile != null)
			parentFile.mkdirs();
		FileWriter xml = new FileWriter(file);
		xml.write(XML_HEADER);
		xml.write("<c:Catalog");
		for (Entry<String, String> entry : Prefixes.entrySet()) {
			String prefix = entry.getKey();
			if (prefix.equals(NC_PREFIX))
				writeXmlNs(xml, prefix, MPD_NC_URI);
			else if (prefix.equals(STRUCTURES_PREFIX))
				writeXmlNs(xml, prefix, MPD_STRUCTURES_URI);
			else
				writeXmlNs(xml, prefix, Prefixes.get(prefix));
		}
		writeXmlNs(xml, "c", MPD_CATALOG_URI);
		writeXmlAttribute(xml, XSI_PREFIX + ":schemaLocation", MPD_CATALOG_URI + " " + MPD_CATALOG_LOCATION);
		xml.write(">");
		xml.write("<c:MPD c:mpdURI=\"" + getExtensionSchema("") + "\"");
		writeXmlAttribute(xml, "c:mpdClassURIList", MPD_URI + "#MPD " + MPD_URI + "#IEPD");
		xml.write(" c:mpdName=\"" + getProperty(IEPD_NAME_PROPERTY) + "\" c:mpdVersionID=\""
				+ getProperty(IEPD_VERSION_PROPERTY) + "\">");
		xml.write("<c:MPDInformation>" +
				"<c:AuthoritativeSource>" + 
				"<nc:EntityOrganization>" + 
				"<nc:OrganizationName>" + getProperty(IEPD_ORGANIZATION_PROPERTY) + "</nc:OrganizationName>" +
				"<nc:OrganizationPrimaryContactInformation>" +
				"<nc:ContactEmailID>" + getProperty(IEPD_EMAIL_PROPERTY) + "</nc:ContactEmailID>" +
				"<nc:ContactWebsiteURI>" + getProperty(IEPD_CONTACT_PROPERTY) + "</nc:ContactWebsiteURI>" +
				"</nc:OrganizationPrimaryContactInformation>" +
				"</nc:EntityOrganization>" +
				"</c:AuthoritativeSource>" + 
				"<c:CreationDate>" + today + "</c:CreationDate>" + 
				"<c:StatusText>" + getProperty(IEPD_STATUS_PROPERTY) + "</c:StatusText>" +
				"</c:MPDInformation>");
		for (String message : messages) {
			UmlClassInstance element = null;
			if (isNiemElement(message))
				element = getElement(subsetPackage, getSchemaURI(message), message);
			else
				element = getElement(extensionPackage, getSchemaURI(message), message);
			xml.write("<c:IEPConformanceTarget structures:id=\"" + getName(message) + "\">");
			if (element == null)
				UmlCom.trace("exportMPDCatalog: error - no root element " + message);
			else
				xml.write("<nc:DescriptionText>" + element.description() + "</nc:DescriptionText>");
			xml.write("<c:HasDocumentElement c:qualifiedNameList=\"" + message + "\"/>" + "<c:XMLSchemaValid>"
					+ "<c:XMLCatalog c:pathURI=\"" + XML_CATALOG_FILE + "\"/>" + "</c:XMLSchemaValid>"
					+ "<c:IEPSampleXMLDocument c:pathURI=\"" + getName(message) + XML_FILE_TYPE + "\"/>"
					+ "</c:IEPConformanceTarget>");
		}
		xml.write("<c:ReadMe c:pathURI=\"" + getProperty(IEPD_READ_ME_FILE_PROPERTY) + "\"/>"
				+ "<c:MPDChangeLog c:pathURI=\"" + getProperty(IEPD_CHANGE_LOG_FILE_PROPERTY) + "\"/>"
				+ "<c:Wantlist c:pathURI=\"" + Paths.get(NIEM_DIR, WANTLIST_FILE).toString() + "\"/>"
				+ "<c:ConformanceAssertion c:pathURI=\"" + CONFORMANCE_ASSERTION_FILE + " \"/>");

		for (Entry<String, String> entry : Prefixes.entrySet()) {
			String prefix = entry.getKey();
			String schemaURI = Prefixes.get(prefix);
			if (schemaURI != null) {
				Namespace ns = Namespaces.get(schemaURI);
				if (ns != null) {
					if ((ns.referenceClassView == null) && (ns.filepath != null))
						xml.write("<c:ExtensionSchemaDocument c:pathURI=\"" + ns.filepath + "\"/>");
				}
			}
		}
		for (String codeList : CodeListNamespaces)
			xml.write("<c:BusinessRulesArtifact c:pathURI=\"" + codeList + GC_FILE_TYPE + "\"/>\n");
		xml.write("<c:ReadMe c:pathURI=\"" + getProperty(IEPD_READ_ME_FILE_PROPERTY) + "\"/>");
		xml.write("<c:MPDChangeLog c:pathURI=\"" + getProperty(IEPD_CHANGE_LOG_FILE_PROPERTY) + "\"/>");
		xml.write("</c:MPD></c:Catalog>");
		xml.close();
		trace("exportMPDCatalog: done generating MPD catalog");
	}

	/** exports OpenAPI/Swagger 2.0 service definition */
	private static void exportOpenAPI(String jsonDir, String openapiDir, Map<String, UmlClass> ports, Set<String> messageNamespaces)
					throws IOException {

		// export JSON-LD namespace definitions
		TreeSet<String> jsonNamespaces = new TreeSet<String>();
		for (String nsPrefix : messageNamespaces)
			if (!nsPrefix.equals(LOCAL_PREFIX))
				jsonNamespaces.add("\n" + getJsonPair(nsPrefix, Prefixes.get(nsPrefix) + "#"));
		jsonNamespaces.add("\n" + getJsonPair(CODELIST_APPINFO_PREFIX, CODELIST_APPINFO_URI + "#"));
		jsonNamespaces.add("\n" + getJsonPair(CT_PREFIX, CT_URI + "#"));
		jsonNamespaces.add("\n" + getJsonPair(TERM_PREFIX, TERM_URI + "#"));

		// generate OpenAPI definitions
		UmlCom.trace("Generating OpenAPIs");
		for (UmlClass port : ports.values()) {
			String portName = port.name();
			// write OpenAPI paths
			TreeSet<String> openapiPaths = new TreeSet<String>();

			// for each path
			TreeSet<String> jsonDefinitions = new TreeSet<String>();
			TreeSet<String> jsonProperties = new TreeSet<String>();

			// get relative path
			Path openapiPath = Paths.get(openapiDir, portName + OPENAPI_FILE_TYPE);
			Path jsonPath = Paths.get(jsonDir);
			String relativePath = openapiPath.getParent().relativize(jsonPath).toString().replaceAll("\\\\", "/") + "/";
			trace("exportOpenAPI: relative path to json: " + relativePath);
			
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					TreeSet<String> openapiOperations = new TreeSet<String>();
					LinkedHashSet<String> openapiPathParameters = new LinkedHashSet<String>();
					LinkedHashSet<String> openapiBodyParameters = new LinkedHashSet<String>();
					LinkedHashSet<String> openapiResponses = new LinkedHashSet<String>();
					UmlOperation operation = (UmlOperation) item;
					String operationName = operation.name();
					String httpMethod = operation.propertyValue(HTTP_METHODS_PROPERTY).toLowerCase();

					trace("exportOpenAPI: generating document/literal input wrapper for " + operationName);
					UmlClass outputType = null, inputType = null;
					UmlParameter[] params = operation.params();
					if (params != null) {
						TreeSet<String> jsonRequiredElementsInType = new TreeSet<String>();
						TreeSet<String> jsonElementsInType = new TreeSet<String>();
						String elementName = operationName + "Request";
						String inputTypeName = elementName + "Type";
						for (UmlParameter param : params) {
							String paramName = param.name;							
							if (!paramName.equals("") && !paramName.equals("body")) {
								// URL parameters
								String paramType = param.type.toString();
								switch (paramType) {
								case "string":
								case "int":
									break;
								default:
									paramType = "string";
								}
								String mult = param.multiplicity;
								mult = convertMultiplicity(mult);
								//String minOccurs = getMinOccurs(mult);
								String maxOccurs = getMaxOccurs(mult);
								String required = (maxOccurs.equals("0")) ? "false" : "true";
								openapiPathParameters.add("           {\n" + 
										"            \"name\": \"" + paramName + "\",\n" + 
										"            \"in\": \"path\",\n" + 
								//		"            \"description\": \"" + param.type.toString() + "\",\n" + 
										"            \"required\": " + required + ",\n" + 
										"            \"type\": \"" + paramType + "\"\n" + 
								//		"            \"format\": \"int64\"\n" + 
										"          }");
								continue;
							}
							// body parameters
							try {
								inputType = param.type.type;
							} catch (Exception e) {
								UmlCom.trace("exportOpenAPI: error - no input message for " + operationName);
							}
							if (inputType == null || !inputType.stereotype().equals(NIEM_STEREOTYPE_TYPE))
								continue;
							String inputMessage = inputType.propertyValue(NIEM_STEREOTYPE_XPATH);
							if (inputMessage == null || inputMessage.equals(""))
								continue;
							trace("exportOpenAPI: input Message: " + inputMessage + " from operation " + operationName);
							messageNamespaces.add(getPrefix(inputMessage));
							String mult = param.multiplicity;

						mult = convertMultiplicity(mult);
						//String maxOccurs = getMaxOccurs(mult);
						if (!isExternalPrefix(getPrefix(inputMessage)))
							jsonElementsInType.add(exportOpenAPIElementInTypeSchema(relativePath, inputMessage, mult, null, false));
						if (Integer.parseInt(getMinOccurs(mult)) > 0)
							jsonRequiredElementsInType.add("\"" + inputMessage + "\"");
						// for each input parameter
						openapiBodyParameters.add("{\n" + 
								"            \"name\": \"" + elementName + "\",\n" + 
								"            \"in\": \"body\",\n" + 
								"            \"description\": \"" + operationName + " request\",\n" + 
								"            \"required\": true,\n" + 
								"            \"schema\": {\n" + 
								"              \"$ref\": \"#/definitions/" + elementName + "\"\n" + 
								"            }\r\n" + 
								"          }");
						}
					// export type wrapper
					TreeSet<String> jsonDefinition = new TreeSet<String>();
					//String description = "";
					//if (description != null && !description.equals(""))
					//	jsonDefinition.add("\"description\": \"" + filterQuotes(description) + "\"");
					jsonDefinition.add("\"type\": \"object\"");
					if (jsonElementsInType != null)
						jsonDefinition.add("\"properties\": {\n" + String.join(",", jsonElementsInType) + "\n}");
					if (jsonRequiredElementsInType != null)
						jsonDefinition.add("\"required\" : [" + String.join(", ", jsonRequiredElementsInType) + "]");
					String typeSchema = "\"" + inputTypeName + "\": {\n" + String.join(",", jsonDefinition) + "\n}\n";

					// export element wrapper
					String elementSchema = "\"" + elementName + "\": {\n" + "\"$ref\": \"#/definitions/" + inputTypeName + "\"" + "\n}\n";
					jsonProperties.add(elementSchema);
					jsonDefinitions.add(typeSchema);
					}
					trace("exportOpenAPI: generating document/literal output wrappers for " + operationName);
					try {
						outputType = operation.returnType().type;
					} catch (Exception e) {
						UmlCom.trace("exportOpenAPI: error - no output message for " + operationName + " " + e.toString());
					}
					if (outputType == null || !outputType.stereotype().equals(NIEM_STEREOTYPE_TYPE))
						continue;
					String outputMessage = outputType.propertyValue(NIEM_STEREOTYPE_XPATH);
					if (outputMessage == null || outputMessage.equals(""))
						continue;
					trace("exportOpenAPI: output Message: " + outputMessage + " from operation " + operationName);
					ArrayList<String> outputs = new ArrayList<String>();
					if (outputMessage != null)
						outputs.add(outputMessage);
					if (ERROR_RESPONSE != null)
						outputs.add(ERROR_RESPONSE);
					for (String message : outputs) {
						TreeSet<String> jsonRequiredElementsInType = new TreeSet<String>();
						TreeSet<String> jsonElementsInType = new TreeSet<String>();
						String elementName = (message.equals(ERROR_RESPONSE) ? "Error" : operationName) + "Response";
						String outputTypeName = elementName + "Type";
						String mult = "1";
						if (!isExternalPrefix(getPrefix(message))) {
							jsonElementsInType.add(exportOpenAPIElementInTypeSchema(relativePath, message, mult, null, false));
							jsonRequiredElementsInType.add("\"" + message + "\"");
						}

						// export type wrapper
						TreeSet<String> jsonDefinition = new TreeSet<String>();
						//String description = "";
						//if (description != null && !description.equals(""))
						//	jsonDefinition.add("\"description\": \"" + filterQuotes(description) + "\"");
						jsonDefinition.add("\"type\": \"object\"");
						if (jsonElementsInType != null)
							jsonDefinition.add("\"properties\": {\n" + String.join(",", jsonElementsInType) + "\n}");
						if (jsonRequiredElementsInType != null)
							jsonDefinition.add("\"required\" : [" + String.join(", ", jsonRequiredElementsInType) + "]");
						String typeSchema = "\"" + outputTypeName + "\": {\n" + String.join(",", jsonDefinition) + "\n}\n";
						jsonDefinitions.add(typeSchema);

						// export element wrapper
						String elementSchema = "\"" + elementName + "\": {\n" + "\"$ref\": \"#/definitions/" + outputTypeName + "\"" + "\n}\n";
						jsonProperties.add(elementSchema);

						// add successful response
						openapiResponses.add("\n"
								+ "          \"200\": {\n" + 
								"            \"description\": \"" + operationName + " response\",\n" + 
								"            \"schema\": {\n" + 
								"                \"$ref\": \"#/definitions/" + operationName + "Response" + "\"\n" + 
								"            }\n" + 
								"          }");
						// add error response
						if (ERROR_RESPONSE != null) 
							openapiResponses.add("\n"
									+ "          \"default\": {\n" + 
									"            \"description\": \"unexpected error\",\n" + 
									"            \"schema\": {\n" + 
									"              \"$ref\": \"#/definitions/" + ERROR_RESPONSE + "\"\n" + 
									"            }\n" + 
									"          }\n");

						for (String method : HTTP_METHODS) {
							if (httpMethod.contains(method)) {
								LinkedHashSet<String> openapiParameters = openapiPathParameters;
								switch (method) {
								case "put":
								case "post":
									openapiParameters.addAll(openapiBodyParameters);
								default:
									openapiOperations.add("\n"
											+ "      \"" + method + "\": {\n" + 
											"        \"description\": \"" + operation.description() + "\\n\",\n" + 
											"        \"operationId\": \"" + operationName + "\",\n" + 
											"        \"parameters\": [" + 
											"        " + String.join(",", openapiParameters) + "\n" + 
											"        ],\n" + 
											"        \"responses\": {" +
											"        " + String.join(",", openapiResponses) + "\n" +
											"        }"  +
											"\n      }");
								}
								openapiOperations.add("\n"
										+ "      \"" + method + "\": {\n" + 
										"        \"description\": \"" + operation.description() + "\\n\",\n" + 
										"        \"operationId\": \"" + operationName + "\",\n" + 
										"        \"parameters\": [" + 
										"        " + String.join(",", openapiPathParameters) + "\n" + 
										"        ],\n" + 
										"        \"responses\": {" +
										"        " + String.join(",", openapiResponses) + "\n" +
										"        }"  +
										"\n      }");
							}
						}

						openapiPaths.add("\n"
								+ "    \"/" + operationName +"\": {" + String.join(",", openapiOperations) + "\n      }");

						// write OpenAPI file
						jsonDefinitions.addAll(jsonProperties);
						try {
							File file = openapiPath.toFile();
							File parentFile = file.getParentFile();
							if (parentFile != null)
								parentFile.mkdirs();
							FileWriter fw = new FileWriter(file);
							trace("OpenAPI: " + portName + OPENAPI_FILE_TYPE);
							fw.write("{\n" + 
									//		jsonContext + ",\n" + 
									"  \"swagger\": \"2.0\",\n" + 
									"  \"info\": {\n" + 
									"    \"version\": \"" + getProperty(IEPD_VERSION_PROPERTY) + "\",\n" + 
									"    \"title\": \"" + portName + "\",\n" + 
									"    \"description\": \"" + port.description() + "\",\n" + 
									"    \"termsOfService\": \"" + getProperty(IEPD_TERMS_URL_PROPERTY) + "\",\n" + 
									"    \"contact\": {\n" + 
									"      \"name\": \"" + getProperty(IEPD_ORGANIZATION_PROPERTY) + "\",\n" +
									"      \"email\": \"" + getProperty(IEPD_EMAIL_PROPERTY) + "\",\n" + 
									"      \"url\": \"" + getProperty(IEPD_CONTACT_PROPERTY) + "\"\n" + 
									"    },\n" + 
									"    \"license\": {\n" + 
									"      \"name\": \"" + getProperty(IEPD_LICENSE_URL_PROPERTY) + "\",\n" + 
									"      \"url\": \"" + getProperty(IEPD_LICENSE_URL_PROPERTY) + "\"\n" + 
									"    }\n" + 
									"  },\n" + 
									"  \"host\": \"host.example.com\",\n" + 
									"  \"basePath\": \"/api\",\n" +
									"  \"schemes\": [\n" + 
									"    \"http\"\n" + 
									"  ],\n" + 
									"  \"consumes\": [\n" + 
									"    \"application/json\"\n" + 
									"  ],\n" + 
									"  \"produces\": [\n" + 
									"    \"application/json\"\n" + 
									"  ]," + 
									"  \"paths\": {" + 
									"  " + String.join(",", openapiPaths) + "\n" + 
									"      },\n" +
									"  \"definitions\": {\n" + String.join(",\n", jsonDefinitions) + "\n}" + 
									"}\n");
							fw.close();
						} catch (Exception e1) {
							UmlCom.trace("exportOpenAPI: error exporting OpenAPI JSON " + e1.toString());
						}
					}
				}
			}
		}
	}

	/** convert multiplicity from UML representation to XML representation */
	private static String convertMultiplicity(String mult) {
		mult=mult.replaceAll("\\.\\.",",").replaceAll("\\*", "unbounded");
		return mult;
	}

	/**
	 * return OpenAPI property description of an element with name elementName and
	 * multiplicity
	 */
	private static String exportOpenAPIElementInTypeSchema(String relativePath, String elementName, String multiplicity, String localPrefix, boolean isAttribute) {
		String elementName2 = null;
		String minOccurs = getMinOccurs(multiplicity);
		String maxOccurs = getMaxOccurs(multiplicity);
		if (isAttribute) {
			if (elementName.equals(getPrefixedName(STRUCTURES_PREFIX, "@id")) || elementName.equals(getPrefixedName(STRUCTURES_PREFIX, "@ref"))) {
				elementName = "xs:NCName";
				elementName2 = "@id";
			} else {
				elementName = filterAttributePrefix(elementName);
				elementName2 = elementName;
			}
		} else
			elementName2 = elementName;
		String elementSchema = "";
		elementSchema += "\"" + elementName2 + "\": {\n";
		if (maxOccurs.equals("1"))
			elementSchema += "\"$ref\": \"" + relativePath + exportJsonPointer(elementName, localPrefix) + "\"\n";
		else {
			elementSchema += "\"items\": {\n" + "\"$ref\": \""
					+ relativePath + exportJsonPointer(elementName, localPrefix) + "\"\n" + "},\n" + "\n\"minItems\": "
					+ minOccurs + ",\n";
			if (!maxOccurs.equals("unbounded"))
				elementSchema += "\n\"maxItems\": " + maxOccurs + ",\n";
			elementSchema += "\"type\": \"array\"\n";
		}
		elementSchema += "}\n";
		return elementSchema;
	}

	/** exports NIEM extension and exchange schema */
	private static void exportSchemas(UmlPackage modelPackage, String xmlDir, String jsonDir) {

		boolean exportXML = (xmlDir != null);
		boolean exportJSON = (jsonDir != null);

		// export each schema
		for (UmlItem thisPackage : modelPackage.children()) {
			if (thisPackage.kind() != anItemKind.aClassView)
				continue;
			UmlClassView classView = (UmlClassView) thisPackage;
			// classView.sort();
			String prefix = classView.propertyValue(PREFIX_PROPERTY);
			if (prefix == null || prefix.equals("")) {
				UmlCom.trace("exportSchemas: prefix for " + thisPackage.name() + " is not set");
				continue;
			}
			if (isExternalPrefix(prefix))
				continue;
			String nsSchemaURI = getURI(classView);
			trace("exportSchemas: exporting schema " + prefix);

			// build list of referenced namespaces
			TreeSet<String> schemaNamespaces = new TreeSet<String>();
			schemaNamespaces.add(XSD_PREFIX);

			TreeSet<String> xmlTypes = new TreeSet<String>();
			TreeSet<String> jsonDefinitions = new TreeSet<String>();
			TreeSet<String> xmlElements = new TreeSet<String>();
			TreeSet<String> jsonProperties = new TreeSet<String>();
			TreeSet<String> jsonRequired = new TreeSet<String>();

			trace("exportSchemas: exporting types and elements");
			String xmlType = null;
			String jsonType = null;
			for (UmlItem item : classView.children()) {
				// add types and attribute groups
				if (item.kind() == anItemKind.aClass) {
					UmlClass type = (UmlClass) item;
					
					// add referenced namespaces
					schemaNamespaces.add(getPrefix(type));
					UmlClass baseType = getBaseType(type);
					if (baseType != null)
						schemaNamespaces.add(getPrefix(baseType));
					for (UmlItem item2 : type.children())
						if (item2.kind() == anItemKind.anAttribute) {
							UmlClassInstance element = getElementByURI(null, getURI(item2));
							if (element != null)
								schemaNamespaces.add(getPrefix(element));
						}
					
					// get type schema
					xmlType = exportXmlTypeSchema(type);
					if (xmlType != null)
						xmlTypes.add(xmlType);
					jsonType = (prefix.equals(XSD_PREFIX)) ? exportJsonPrimitiveSchema(type)
							: exportJsonTypeSchema(type, prefix);
					if (jsonType != null)
						jsonDefinitions.add(jsonType);
				}
				// add elements and attributes
				String xmlElement = null;
				String jsonElement = null;
				if (item.kind() == anItemKind.aClassInstance) {
					UmlClassInstance element = (UmlClassInstance) item;
					UmlClass baseType = getBaseType(element);
					
					// add referenced namespaces
					schemaNamespaces.add(getPrefix(element));
					if (baseType != null)
						schemaNamespaces.add(getPrefix(baseType));
					String headElement = element.propertyValue(SUBSTITUTION_PROPERTY);
					if (headElement != null)
						schemaNamespaces.add(getPrefix(headElement));
					
					// get element schema
					xmlElement = exportXmlElementSchema(element);
					if (xmlElement != null)
						xmlElements.add(xmlElement);
					if (baseType != subsetAbstractType) {
						schemaNamespaces.add(getPrefix(element));
						jsonElement = exportJsonElementSchema(element, prefix);
						if (jsonElement != null)
							jsonDefinitions.add(jsonElement);
						String messageElement = element.propertyValue(MESSAGE_ELEMENT_PROPERTY);
						if (messageElement != null && !messageElement.equals("")) {
							jsonProperties.add(jsonElement);
							jsonRequired.add("\"" + getPrefixedName(element) + "\"");
						}
					}
				}
			}

			// export XML file
			if (exportXML) {
				// Open XSD file for each extension schema and write header
				trace("exportSchemas: schema " + xmlDir + "/" + prefix + XSD_FILE_TYPE);
				Namespace ns = Namespaces.get(nsSchemaURI);
				if (ns.filepath == null) {
					UmlCom.trace("exportSchemas: error - no path for schema " + nsSchemaURI);
					continue;
				}
				String filename = Paths.get(xmlDir, ns.filepath).toString();
				trace("exportSchemas: referenced namespaces in " + filename + ": " + schemaNamespaces.toString());
				exportXMLSchema(xmlDir, filename, nsSchemaURI, xmlTypes, xmlElements, schemaNamespaces);
			}
		
			// export JSON file
			if (exportJSON) {
				// export JSON-LD namespace definitions
				TreeSet<String> jsonNamespaces = new TreeSet<String>();
				for (String nsPrefix : schemaNamespaces)
					if (!nsPrefix.equals(LOCAL_PREFIX))
						jsonNamespaces.add("\n" + getJsonPair(nsPrefix, Prefixes.get(nsPrefix) + "#"));
				jsonNamespaces.add("\n" + getJsonPair(CODELIST_APPINFO_PREFIX, CODELIST_APPINFO_URI + "#"));
				jsonNamespaces.add("\n" + getJsonPair(CT_PREFIX, CT_URI + "#"));
				jsonNamespaces.add("\n" + getJsonPair(TERM_PREFIX, TERM_URI + "#"));
				
				try {
					// Open JSON schema file for each extension schema and write header
					File file = Paths.get(jsonDir, prefix + JSON_SCHEMA_FILE_TYPE).toFile();
					File parentFile = file.getParentFile();
					if (parentFile != null)
						parentFile.mkdirs();
					trace("exportSchemas: schema " + file.toString());
					FileWriter json = new FileWriter(file);
					json.write("{\n" + 
							getJsonPair("$id", nsSchemaURI) + ",\n" +
							getJsonPair("$schema", JSON_SCHEMA_URI) + ",\n" +
							getJsonPair("type", "object") + ",\n" +
							"\"additionalProperties\" : false" + ",\n" +
							"\"@context\" : {\n" + String.join(",\n", jsonNamespaces) + "},\n" +
							"\"definitions\": {\n" + String.join(",\n", jsonDefinitions) + "\n}" + ",\n" +
							"\"properties\" : {\n" + String.join(",\n", jsonProperties) + "\n}" + ",\n" +
							"\"required\" : [\n" + String.join(",\n", jsonRequired) + "]" + "\n" +
						"}");
					json.close();
				} catch (Exception e1) {
					UmlCom.trace("exportSchemas: error exporting JSON file " + e1.toString());
				}
			}
		}
	}

	/** exports a WSDL definitions file */
	private static void exportWSDL(String xmlDir, String wsdlDir, Map<String, UmlClass> ports, Set<String> messageNamespaces)
			throws IOException {

		String WSDLURI = getProperty(IEPD_URI_PROPERTY) + WSDL_SUFFIX;
		String WRAPPERURI = getProperty(IEPD_URI_PROPERTY) + MESSAGE_WRAPPERS_FILE_NAME;

		UmlCom.trace("Generating document/literal wrapper schema");
		TreeSet<String> xmlTypes = new TreeSet<String>();
		TreeSet<String> xmlElements = new TreeSet<String>();
		for (UmlClass port: ports.values()) {
			for (UmlItem item2 : port.children()) {
				if (item2.kind() != anItemKind.anOperation)
					continue;
				UmlOperation operation = (UmlOperation) item2;
				String operationName = operation.name();
				trace("exportWSDL: generating document/literal wrapper for " + operationName);
				UmlClass outputType = null, inputType = null;
				UmlParameter[] params = operation.params();
				if (params != null) {
					String elementName = operationName + "Request";
					String inputTypeName = elementName + "Type";
					String inputTypeSchema = "<xs:complexType name=\"" + inputTypeName + "\">" + "<xs:sequence>";
					for (UmlParameter param : params) {
						// ignore RESTful parameters
						if (!param.name.equals("") && !param.name.equals("body"))
							continue;
						try {
							inputType = param.type.type;
						} catch (Exception e) {
							UmlCom.trace("exportWSDL: error - no input message for " + operationName);
						}
						if (inputType == null || !inputType.stereotype().equals(NIEM_STEREOTYPE_TYPE))
							continue;
						String inputMessage = inputType.propertyValue(NIEM_STEREOTYPE_XPATH);
						if (inputMessage == null || inputMessage.equals(""))
							continue;
						trace("exportWSDL: input Message: " + inputMessage + " from operation " + operationName);
						messageNamespaces.add(getPrefix(inputMessage));
						String mult = param.multiplicity;
						String minOccurs = "1";
						String maxOccurs = "1";
						if (!(mult.equals(""))) {
							if (mult.contains("..")) {
								String[] occurs = mult.split("\\.\\.");
								minOccurs = occurs[0];
								maxOccurs = occurs[1];
							} else
								minOccurs = maxOccurs = mult;
						}
						if (maxOccurs.equals("*"))
							maxOccurs = "unbounded";
						if (isExternalPrefix(getPrefix(inputMessage)))
							inputTypeSchema += "<!--xs:element ref=\"" + inputMessage + "\" minOccurs=\"" + minOccurs
									+ "\" maxOccurs=\"" + maxOccurs + "\"/-->\n";
						else
							inputTypeSchema += "<xs:element ref=\"" + inputMessage + "\" minOccurs=\"" + minOccurs
									+ "\" maxOccurs=\"" + maxOccurs + "\"/>\n";
					}
					inputTypeSchema += "</xs:sequence>" + "</xs:complexType>";
					xmlTypes.add(inputTypeSchema);
					xmlElements.add("<xs:element name=\"" + elementName + "\" type=\"" +
							getPrefixedName(WRAPPER_PREFIX, inputTypeName) + "\"/>");

				}

				try {
					outputType = operation.returnType().type;
				} catch (Exception e) {
					UmlCom.trace("exportWSDL: error - no output message for " + operationName + " " + e.toString());
				}
				if (outputType == null || !outputType.stereotype().equals(NIEM_STEREOTYPE_TYPE))
					continue;
				String outputMessage = outputType.propertyValue(NIEM_STEREOTYPE_XPATH);
				if (outputMessage == null || outputMessage.equals(""))
					continue;
				trace("exportWSDL: output Message: " + outputMessage + " from operation " + operationName);
				String elementName = operationName + "Response";
				String outputTypeName = elementName + "Type";
				String outputTypeSchema = "<xs:complexType name=\"" + outputTypeName + "\">" + "<xs:sequence>";
				if (isExternalPrefix(getPrefix(outputMessage)))
					outputTypeSchema += "<!--xs:element ref=\"" + outputMessage + "\"/-->";
				else
					outputTypeSchema += "<xs:element ref=\"" + outputMessage + "\"/>";
				outputTypeSchema += "</xs:sequence>" + "</xs:complexType>";
				xmlTypes.add(outputTypeSchema);
				xmlElements.add("<xs:element name=\"" + elementName + "\" type=\"" + 
				getPrefixedName(WRAPPER_PREFIX, outputTypeName) + "\"/>");
			}
		}
		
		// export message wrapper
		Prefixes.put(WRAPPER_PREFIX, WRAPPERURI);
		messageNamespaces.add(WRAPPER_PREFIX);
		String filename = Paths.get(xmlDir, MESSAGE_WRAPPERS_FILE_NAME + XSD_FILE_TYPE).toString();
		exportXMLSchema(xmlDir, filename, WRAPPERURI, xmlTypes, xmlElements, messageNamespaces);

		UmlCom.trace("Generating WSDLs");
		for (UmlClass port : ports.values()) {
			String portName = port.name();
			Path p1 = Paths.get(wsdlDir, portName + WSDL_FILE_TYPE);
			File file = p1.toFile();
			File parentFile = file.getParentFile();
			if (parentFile != null)
				parentFile.mkdirs();
			FileWriter wsdl = new FileWriter(file);
			trace("WSDL: " + portName + WSDL_FILE_TYPE);
			wsdl.write("<definitions targetNamespace=\"" + WSDLURI + "/" + portName + "\"");
			writeXmlNs(wsdl, WSDL_PREFIX, WSDLURI + "/" + portName);
			writeXmlNs(wsdl, WRAPPER_PREFIX, WRAPPERURI);
			writeXmlNs(wsdl, "xsd", XSD_URI);
			writeXmlNs(wsdl, SOAP_PREFIX, SOAP_URI);
			writeXmlNs(wsdl, WSDL_SCHEMA_PREFIX, WSDL_SCHEMA_URI);
			writeXmlNs(wsdl, "", WSDL_SCHEMA_URI);
			writeXmlNs(wsdl, WSP_PREFIX, WSP_URI);
			writeXmlNs(wsdl, WSRMP_PREFIX, WSRMP_URI);
			writeXmlNs(wsdl, WSU_PREFIX, WSU_URI);
			wsdl.write("><!-- " + port.description() + " -->");
			Path p2 = Paths.get(xmlDir, MESSAGE_WRAPPERS_FILE_NAME + XSD_FILE_TYPE);
			Path p3 = p1.getParent().relativize(p2);
			wsdl.write("<wsp:UsingPolicy wsdl:required=\"true\"/>" + 
					"<wsp:Policy wsu:Id=\"" + WSP_POLICY + "\">" + "<wsrmp:RMAssertion/>" + "</wsp:Policy>" +
					"<wsdl:types>" + 
					"<xsd:schema>" + "<xsd:import namespace=\"" + WRAPPERURI + "\" schemaLocation=\"" + p3.toString() + "\"/>" +
					"</xsd:schema>" + 
					"</wsdl:types>");

			wsdl.write("<!-- messages -->");
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					UmlOperation operation = (UmlOperation) item;
					String operationName = operation.name();
					wsdl.write("<message name=\"" + operationName + REQUEST_MESSAGE_SUFFIX + "\">"
							+ "<part name=\"body\" element=\"" + getPrefixedName(WRAPPER_PREFIX, operationName)
							+ REQUEST_MESSAGE_SUFFIX + "\"/>" + "</message>" + "<message name=\"" + operationName
							+ RESPONSE_MESSAGE_SUFFIX + "\">" + "<part name=\"body\" element=\""
							+ getPrefixedName(WRAPPER_PREFIX, operationName) + RESPONSE_MESSAGE_SUFFIX + "\"/>"
							+ "</message>");
				}
			}

			wsdl.write("<!-- ports -->");
			wsdl.write("<portType name=\"" + portName + "\">");
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					UmlOperation operation = (UmlOperation) item;
					String operationName = operation.name();
					wsdl.write("<operation name=\"" + operationName + "\">" + "<input message=\""
							+ getPrefixedName(WSDL_PREFIX, operationName) + REQUEST_MESSAGE_SUFFIX + "\"/>"
							+ "<output message=\"" + getPrefixedName(WSDL_PREFIX, operationName)
							+ RESPONSE_MESSAGE_SUFFIX + "\"/>" + "</operation>");
				}
			}
			wsdl.write("</portType>");

			wsdl.write("<!-- bindings -->");
			wsdl.write("<binding name=\"" + portName + "Soap\" type=\"" + getPrefixedName(WSDL_PREFIX, portName) + "\">"
					+ "<wsp:PolicyReference URI=\"#" + WSP_POLICY + "\"/>"
					+ "<soap:binding style=\"document\" transport=\"" + SOAP_HTTP_BINDING_URI + "\"/>");
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					UmlOperation oper = (UmlOperation) item;
					String operationName = oper.name();
					wsdl.write("<operation name=\"" + operationName + "\">");
					wsdl.write("<!-- " + item.description() + " -->");
					wsdl.write("<soap:operation soapAction=\"" + WSDLURI
							+ "/" + portName + "/" + operationName + "\"/>" + "<input>"
							+ "	<soap:body use=\"literal\"/>" + "</input>" + "<output>"
							+ "	<soap:body use=\"literal\"/>" + "</output>" + "</operation>");
				}
			}
			wsdl.write("</binding>");
			wsdl.write(
					"<!-- services not defined here...defined in an implementation-specific WSDL that imports this one -->"
							+ "</definitions>");
			wsdl.close();
		}
	}

	/** exports XML catalog file */
	private static void exportXMLCatalog(String xmlDir, Set<String> CodeListNamespaces) throws IOException {
		FileWriter xml;
		UmlCom.trace("Generating XML catalog");
		File file = Paths.get(xmlDir, XML_CATALOG_FILE).toFile();
		File parentFile = file.getParentFile();
		if (parentFile != null)
			parentFile.mkdirs();
		xml = new FileWriter(file);
		xml.write(XML_HEADER + XML_ATTRIBUTION + XML_CATALOG_HEADER + "<catalog prefer=\"public\" "
				+ NAMESPACE_ATTRIBUTE + "=\"" + XML_CATALOG_URI + "\">\n");
		for (Entry<String, String> entry : Prefixes.entrySet()) {
			String prefix = entry.getKey();
			String schemaURI = Prefixes.get(prefix);
			Namespace ns = Namespaces.get(schemaURI);
			if (isExternalPrefix(prefix))
				xml.write("<uri name=\"" + schemaURI + "\" uri=\"" + externalSchemaURL.get(schemaURI) + "\"/>\n");
			else if (ns.referenceClassView == null)
				xml.write("<uri name=\"" + schemaURI + "\" uri=\"" + ns.filepath + "\"/>\n");
		}
		for (String codeList : CodeListNamespaces)
			xml.write("<uri name=\"" + getExtensionSchema(codeList) + "\" uri=\"" + codeList + GC_FILE_TYPE + "\"/>\n");
		xml.write(
				"<nextCatalog  catalog=\"" + Paths.get(NIEM_DIR, XML_CATALOG_FILE).toString() + "\" />\n</catalog>\n");
		xml.close();
	}

	/** return XML schema element in type definition */
	private static String exportXMLElementInTypeSchema(UmlClassInstance element, String multiplicity,
			String mappingNotes) {
		String elementSchema = "<xs:element ref=\"" + getPrefixedName(element) + "\" minOccurs=\""
				+ getMinOccurs(multiplicity) + "\" maxOccurs=\"" + getMaxOccurs(multiplicity) + "\"";
		if (mappingNotes != null && !mappingNotes.equals(""))
			elementSchema += "<!--" + mappingNotes + "-->\n</xs:element>\n";
		else
			elementSchema += "/>\n";
		return elementSchema;
	}

	/** return XML schema element definition */
	private static String exportXmlElementSchema(UmlClassInstance element) {
		String elementName = getName(element);
		String elementSchema = "<xs:element name=\"" + elementName + "\"";
		UmlClass baseType = getBaseType(element);
		if (baseType != null) {
			if (baseType == subsetAbstractType)
				elementSchema += " abstract=\"true\"";
			else
				elementSchema += " type=\"" + getPrefixedName(baseType) + "\"";
		}
		String headElement = element.propertyValue(SUBSTITUTION_PROPERTY);
		if (headElement != null)
			elementSchema += " substitutionGroup=\"" + headElement + "\"";
		String isNillable = element.propertyValue(NILLABLE_PROPERTY);
		if (isNillable == null)
			isNillable = "false";
		if (isNillable.equals("true"))
			elementSchema += " nillable=\"true\"";
		elementSchema += ">\n";
		String mappingNotes = element.propertyValue(NOTES_PROPERTY);
		if (mappingNotes != null && !mappingNotes.equals(""))
			elementSchema += "<!--" + mappingNotes + "-->";
		String description = element.description();
		if (description != null && !description.equals("")) {
			elementSchema += "\n<xs:annotation>\n" + "<xs:documentation>" + description + "</xs:documentation>\n";
			String codeList = element.propertyValue(CODELIST_PROPERTY);
			if (codeList != null)
				elementSchema += "<xs:appinfo>" + "<clsa:SimpleCodeListBinding codeListURI=\""
						+ getExtensionSchema(elementName) + "\"/>" + " </xs:appinfo>";
			elementSchema += "</xs:annotation>\n";
		}
		elementSchema += "</xs:element>\n";
		return elementSchema;
	}

	private static void exportXMLSchema(String dir, String filename, String nsSchemaURI,
			TreeSet<String> xmlTypes, TreeSet<String> xmlElements, Set<String> schemaNamespaces) {
		try {
			trace("exportXMLSchema: exporting " + filename);
			File file = new File(filename);
			File parentFile = file.getParentFile();
			if (parentFile != null)
				parentFile.mkdirs();
			FileWriter xml = new FileWriter(filename);
			xml.write(XML_HEADER + XML_ATTRIBUTION + "<" + "xs:schema targetNamespace=\"" + nsSchemaURI + "\"\n");
			
			// export XML namespace definitions
			writeXmlNs(xml, "", nsSchemaURI);
			writeXmlNs(xml, XSI_PREFIX, XSI_URI);
			if (schemaNamespaces.isEmpty())
				UmlCom.trace("exportXMLSchema: error - no imported namespaces in " + filename);
			for (String nsPrefix : schemaNamespaces)
				if (!nsPrefix.equals(LOCAL_PREFIX))
					writeXmlNs(xml, nsPrefix, Prefixes.get(nsPrefix));
			writeXmlNs(xml, CODELIST_APPINFO_PREFIX, CODELIST_APPINFO_URI);
			writeXmlNs(xml, CT_PREFIX, CT_URI);
			writeXmlNs(xml, TERM_PREFIX, TERM_URI);
			writeXmlAttribute(xml, "ct:conformanceTargets",
					NDR_URI + "#ExtensionSchemaDocument " + CODELIST_URI + "#SchemaDocument");
			writeXmlAttribute(xml, "elementFormDefault", "qualified");
			writeXmlAttribute(xml, "attributeFormDefault", "unqualified");
			writeXmlAttribute(xml, "version", getProperty(IEPD_VERSION_PROPERTY));
			// close top level element
			xml.write(">\n<xs:annotation>\n" + "<xs:documentation> Schema for namespace " + nsSchemaURI
					+ "</xs:documentation>\n" + "</xs:annotation>");
			// add import namespaces
			trace("exportXMLSchema: exporting namespaces");
			Path path1 = Paths.get(file.getParent());
			for (String nsPrefix : schemaNamespaces) {
				if ((nsPrefix.equals(LOCAL_PREFIX)) || (nsPrefix.equals(XSD_PREFIX)))
					continue;
				// trace("exportSchema: exporting prefix " + nsPrefix);
				String nsSchemaURI2 = Prefixes.get(nsPrefix);
				if (nsSchemaURI2 == null) {
					UmlCom.trace("exportXMLSchema: error - prefix " + nsPrefix + " not in model");
					continue;
				}
				if (isExternalPrefix(nsPrefix))
					xml.write("<xs:import namespace=\"" + nsSchemaURI2 + "\" schemaLocation=\""
							+ externalSchemaURL.get(nsSchemaURI2) + "\"/>");
				else {
					Namespace ns2 = Namespaces.get(nsSchemaURI2);
					if (ns2 == null) {
						UmlCom.trace("exportXMLSchema: error - namespace " + nsSchemaURI2 + " not in model");
						continue;
					}
					Path p2 = Paths.get(dir, ns2.filepath);
					Path p3 = path1.relativize(p2);
					if (!nsSchemaURI2.equals(nsSchemaURI) && !nsSchemaURI2.equals(LOCAL_URI) && !nsSchemaURI2.equals(XSD_URI))
						xml.write("<xs:import namespace=\"" + nsSchemaURI2 + "\" schemaLocation=\"" + p3.toString() + "\"/>");
				}
			}
			// export attributes, types and element
			xml.write(String.join("", xmlTypes));
			xml.write(String.join("", xmlElements));

			// close schema
			xml.write("</xs:schema>\n");
			xml.close();
		} catch (Exception e1) {
			UmlCom.trace("exportXMLSchema: error exporting XML schema " + e1.toString());
		}
	}

	/** return XML schema type definition */
	private static String exportXmlTypeSchema(UmlClass type) {
		String typeName = getName(type);
		String typeSchema = null;
		String codeList = type.propertyValue(CODELIST_PROPERTY);
		boolean isComplexType = true;
		boolean isComplexContent = true;
		UmlClass baseType = getBaseType(type);
		if (baseType == null)
			baseType = subsetObjectType;
		String baseTypeCodeList = baseType.propertyValue(CODELIST_PROPERTY);
		String baseTypeName = getPrefixedName(baseType);
		if (codeList != null && !codeList.equals("")) { // code list simple type
			trace("exportXmlTypeSchema: exporting code list simple type " + typeName);
			isComplexType = false;
			isComplexContent = false;
		} else if (baseTypeCodeList != null && !baseTypeCodeList.equals("")) { // code list complex type
			trace("exportXmlTypeSchema: exporting code list complex type " + typeName);
			isComplexContent = false;
		} else
			trace("exportXmlTypeSchema: exporting complex type " + typeName); // complexContent

		TreeSet<String> xmlEnumerations = new TreeSet<String>();
		if (isComplexType == false && baseType != null)
			if (codeList != null && codeList.equals("")) {
				for (String code : codeList.split(CODELIST_DELIMITER)) {
					if (code.equals(""))
						continue;
					String[] codeParams = code.replace("&", "&amp;").split(CODELIST_DEFINITION_DELIMITER);
					String codeValue = codeParams[0].trim();
					if (codeValue.equals(""))
						continue;
					String codeDescription = (codeParams.length > 1 && !codeParams[1].equals("")) ? codeParams[1].trim()
							: "";
					String enumeration = "<xs:enumeration value=\"" + codeValue + "\">\n";
					if (!codeDescription.equals(""))
						enumeration += "<xs:annotation>\n" + "<xs:documentation>" + codeDescription
						+ "</xs:documentation>\n" + "</xs:annotation>\n";
					enumeration += "</xs:enumeration>\n";
					xmlEnumerations.add(enumeration);
				}
			}
		// type.sortChildren();
		// add elements, attributes and attribute groups in types
		TreeSet<String> xmlElementsInType = new TreeSet<String>();
		TreeSet<String> xmlAttributesInType = new TreeSet<String>();
		String anyElement = getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME);
		UmlAttribute augmentationPoint = null;
		String xmlElementInType = null;
		for (UmlItem item : type.children()) {
			if (item.kind() == anItemKind.anAttribute) {
				UmlAttribute attribute = (UmlAttribute) item;
				UmlClassInstance element = getElementByURI(null, getURI(attribute));
				if (element == null)
					continue;
				String elementName = getPrefixedName(element);
				trace("exportXmlTypeSchema: exporting element in type " + elementName);
				String elementMappingNotes = null;
				if (elementName.endsWith(AUGMENTATION_POINT_NAME))
					augmentationPoint = attribute;
				if (isComplexContent)
					elementMappingNotes = attribute.propertyValue(NOTES_PROPERTY);
				if (elementName.equals(anyElement)) {
					xmlElementsInType.add("<xs:any/>");
					continue;
				}
				// if (complexContent)
				String multiplicity = attribute.multiplicity();
				if (isAttribute(element)) {
					String use = multiplicity.equals("1,1") ? "required" : "optional";
					xmlAttributesInType.add("<xs:attribute ref=\"" + elementName + "\" use = \"" + use + "\"/>");
				} else {
					xmlElementInType = exportXMLElementInTypeSchema(element, multiplicity, elementMappingNotes);
					if (xmlElementInType != null)
						xmlElementsInType.add(xmlElementInType);
				}
			}
			if (item.kind() == anItemKind.aRelation) {
				UmlRelation relation = (UmlRelation) item;
				if (relation.relationKind() == aRelationKind.aDirectionalAggregation) { // attributeGroup
					UmlClass sourceBaseType = relation.roleType();
					if (sourceBaseType != null) {
						xmlAttributesInType.add("<xs:attributeGroup ref=\"" + getPrefixedName(sourceBaseType) + "\"/>");
					}
				}
			}
		}
		if (augmentationPoint != null) {
			// if (complexContent) {
			UmlClassInstance element = getElementByURI(null, getURI(augmentationPoint));
			xmlElementsInType.add(exportXMLElementInTypeSchema(element, augmentationPoint.multiplicity(), null));
		}

		// write XML schema definition
		typeSchema = (isComplexType) ? "<xs:complexType" : "<xs:simpleType";
		typeSchema += " name=\"" + typeName + "\">\n";
		String mappingNotes = type.propertyValue(NOTES_PROPERTY);
		if (mappingNotes != null && !mappingNotes.equals(""))
			typeSchema += "<!--" + mappingNotes + "-->";
		String description = type.description();
		if (description != null && !description.equals(""))
			typeSchema += "<xs:annotation>\n" 
					+ "<xs:documentation>" + description + "</xs:documentation>\n"
					+ "</xs:annotation>\n";
		if (isComplexType) {
			if (isComplexContent) {
				typeSchema += "<xs:complexContent>\n" 
						+ "<xs:extension base=\"" + baseTypeName + "\">\n"
						+ "<xs:sequence>\n"
						+ String.join("", xmlElementsInType) + "\n"
						+ "</xs:sequence>\n"
						+ "</xs:extension>\n"
						+ String.join("", xmlAttributesInType) + "\n"
						+ "</xs:complexContent>\n"
						+ "</xs:complexType>\n";
			} else {
				typeSchema += "<xs:simpleContent>\n" 
						+ "<xs:extension base=\"" + baseTypeName + "\"/>\n"
						+ String.join("", xmlAttributesInType) + "\n"
						+ "</xs:simpleContent>\n"
						+ "</xs:complexType>\n";
			}
		} else {
			typeSchema += "<xs:restriction base=\"" + baseTypeName + "\"";
			if (xmlEnumerations.size()>0)
				typeSchema += String.join("", xmlEnumerations) + "\n";
			typeSchema += "</xs:restriction>\n"
					+ "</xs:simpleType>\n";
		}
		return typeSchema;
	}
	
	/** filter non-ASCII characters */
	private static String filterASCII(String string) {
		return string.replaceAll("[^\\p{ASCII}]", "");
	}
	
	/** return attribute name with prefix filtered */
	private static String filterAttributePrefix(String attributeName) {
		return attributeName.replaceAll(ATTRIBUTE_PREFIX, "");
	}

	/** filter illegal characters in enumerations */
	private static String filterEnum(String string) {
		return string.replaceAll(CODELIST_DELIMITER + CODELIST_DEFINITION_DELIMITER, "");
	}

	/** filter illegal characters in XML prefix */
	private static String filterPrefix(String prefix) {
		return prefix.replaceAll("[^-._A-Za-z0-9]", "");
	}

	/** filter illegal characters in XML strings */
	private static String filterQuotes(String string) {
		return string.replaceAll("&", "&amp;").replaceAll("\"", "&quot;").replaceAll("\r|\n", "");
	}

	/** filter illegal characters in UML elements */
	private static String filterUMLElement(String string) {
		return string.replaceAll("[^A-Za-z0-9_@#$-`~,.<?;:'\"\\\\]", "");
	}

	/** filter illegal characters in UML types */
	private static String filterUMLType(String string) {
		return string.replaceAll("[^A-Za-z0-9_@#$`~,.<?;:'\"\\\\]", "");
	}

	/** return attribute group related to a type */
	private static UmlClass getAttributeGroup(UmlClass type) {
		for (UmlItem item : type.children())
			if (item.kind() == anItemKind.aRelation) {
				UmlRelation r = (UmlRelation) item;
				if (r.relationKind() == aRelationKind.aDirectionalAggregation)
					return r.roleType();
			}
		// trace("getAttributeGroup: error - attribute group not found for " +
		// type.name());
		return null;
	}

	/** return base type related to a type or element */
	private static UmlClass getBaseType(UmlItem item) {
		UmlClass baseType = null;
		switch (item.kind().value()) {
		case anItemKind._aClassInstance:
			UmlClassInstance classInstance = (UmlClassInstance) item;
			baseType = classInstance.type();
			break;
		case anItemKind._aClass:
			if (item == subsetAbstractType || item == referenceAbstractType)
				return null;
			UmlClass type = (UmlClass) item;
			for (UmlItem item2 : type.children())
				if (item2.kind() == anItemKind.aRelation) {
					UmlRelation r = (UmlRelation) item2;
					if (r.relationKind() == aRelationKind.aGeneralisation) {
						baseType = r.roleType();
						break;
					}
				}
			if (baseType == null) {
				String prefix = getPrefix(item);
				if (prefix.equals(STRUCTURES_PREFIX) || prefix.equals(XSD_PREFIX))
					return null;
				if (getName(item).endsWith(AUGMENTATION_TYPE_NAME))
					baseType = subsetAugmentationType;
			}
		default:
			break;
		}
		// if (baseType == null)
		// trace("getBaseType: error - no base type for " + item.name());
		// else
		// trace("getBaseType: base type found " + baseType.name());
		return baseType;
	}

	/** returns the html for a column */
	private static String getColumnHtml(String value, String bgcolor, String fgcolor, Boolean wordwrap) {
		String style = wordwrap ? "word-wrap: break-word" : "";
		return "<td  style=\"" + style + "\" bgcolor=\"" + bgcolor + "\"><font color = \"" + fgcolor + "\">" + value
				+ "</font></td>";
	}

	/** return the default schema URI for the current file */
	private static String getDefaultSchemaURI(String filename, Document doc) {
		String defaultSchemaURI = doc.lookupNamespaceURI(null);
		if (defaultSchemaURI == null) {
			// trace("getDefaultSchemaURI: no default namespace found in " + filename);
			defaultSchemaURI = LOCAL_PREFIX;
		}
		return defaultSchemaURI;
	}

	/** filter whitespace */
	// private static String filterToken(String string) {
	// return string.replaceAll("\\s", "");
	// }

	/** return an element in schema schemaURI with name elementName */
	private static UmlClassInstance getElement(UmlPackage modelPackage, String schemaURI, String elementName) {
		return getElementByURI(modelPackage, getURI(schemaURI, elementName));
	}

	/** filter illegal characters in XML names */
	// private static String filterNameToken(String string) {
	// return string.replaceAll("[^-._:A-Za-z0-9]", "");
	// }

	/** return an element in modelPackage with uri elementUri */
	private static UmlClassInstance getElementByURI(UmlPackage modelPackage, String elementUri) {
		UmlClassInstance element = null;
		if (modelPackage == null)
			modelPackage = (SubsetElements.containsKey(elementUri)) ? subsetPackage : extensionPackage;
		if (modelPackage == referencePackage)
			element = NiemElements.get(elementUri);
		else if (modelPackage == subsetPackage)
			element = SubsetElements.get(elementUri);
		else if (modelPackage == extensionPackage)
			element = ExtensionElements.get(elementUri);
		// if (element == null)
		// UmlCom.trace("getElementByURI: error - no element found for uri " +
		// elementUri + " in model " + modelPackage.name());
		return element;
	}

	/** returns an element in type and checks the multiplicity */
	private static UmlAttribute getElementInType(UmlClass type, String elementInTypeName, String multiplicity) {
		for (UmlItem item : type.children())
			if (item.kind() == anItemKind.anAttribute && item.name().equals(elementInTypeName)) {
				String previousMultiplicity = ((UmlAttribute) item).multiplicity();
				if (!previousMultiplicity.equals(multiplicity))
					UmlCom.trace("getElementInType:  error - " + getPrefixedName(type) + "/" + elementInTypeName
							+ " has conflicting multiplicities " + previousMultiplicity + " and " + multiplicity);
				return (UmlAttribute) item;
			}
		return null;
	}

	/** return an element in type in modelPackage with uri typeURI */
	private static List<UmlClassInstance> getElementsInType(UmlPackage modelPackage, String typeURI) {
		List<UmlClassInstance> elementInTypeList = null;
		if (modelPackage == referencePackage) {
			elementInTypeList = NiemElementsInType.get(typeURI);
			if (elementInTypeList == null) {
				elementInTypeList = new ArrayList<UmlClassInstance>();
				NiemElementsInType.put(typeURI, elementInTypeList);
			}
		} else if (modelPackage == subsetPackage) {
			elementInTypeList = SubsetElementsInType.get(typeURI);
			if (elementInTypeList == null) {
				elementInTypeList = new ArrayList<UmlClassInstance>();
				SubsetElementsInType.put(typeURI, elementInTypeList);
			}
		} else if (modelPackage == extensionPackage) {
			elementInTypeList = ExtensionElementsInType.get(typeURI);
			if (elementInTypeList == null) {
				elementInTypeList = new ArrayList<UmlClassInstance>();
				ExtensionElementsInType.put(typeURI, elementInTypeList);
			}
		}
		return elementInTypeList;
	}

	/** returns an extension schema URI */
	private static String getExtensionSchema(String prefix) {
		return getProperty(IEPD_URI_PROPERTY) + prefix;
	}

	/** returns a line of the NIEM mapping spreadsheet in CSV format */
	private static String[] getItemCsv(UmlItem item) {
		String[] nextLine = new String[NIEM_STEREOTYPE_MAP.length];
		try {
			// Export Class and Property
			switch (item.kind().value()) {
			case anItemKind._aClass:
				nextLine[0] = item.name();
				nextLine[1] = "";
				nextLine[2] = "";
				break;
			case anItemKind._anAttribute:
				nextLine[0] = item.parent().name();
				nextLine[1] = item.name();
				UmlAttribute a = (UmlAttribute) item;
				nextLine[2] = a.multiplicity();
				break;
			case anItemKind._aRelation:
				nextLine[0] = item.parent().name();
				UmlRelation r = (UmlRelation) item;
				nextLine[1] = r.name();
				nextLine[2] = r.multiplicity();
				break;
			case anItemKind._aClassInstance:
				nextLine[0] = "";
				nextLine[1] = item.name();
				nextLine[2] = "";
				break;
			default:
				nextLine[0] = item.parent().name();
				nextLine[1] = item.name();
				nextLine[2] = "";
				break;
			}
		} catch (Exception e) {
			UmlCom.trace("itemCsv: error importing class, property multiplicity " + e.toString());
		}

		// Export Description
		nextLine[3] = item.description();

		// Export NIEM Mapping
		if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
			for (int column = 4; column < NIEM_STEREOTYPE_MAP.length; column++)
				nextLine[column] = item.propertyValue(getNiemProperty(column));

		return nextLine;
	}

	/** output a JSON name value pair */
	private static String getJsonPair(String name, String value) {
		return  "\"" + name + "\" : \"" + value + "\"\n";
	}

	/** return XML maxOccurs from multiplicity */
	private static String getMaxOccurs(String multiplicity) {
		String maxOccurs = null;
		if (multiplicity.equals(""))
			maxOccurs = "1";
		else if (multiplicity.contains(","))
			maxOccurs = multiplicity.split(",")[1];
		else
			maxOccurs = multiplicity;
		try {
			if (!maxOccurs.equals("unbounded") && (Integer.parseInt(maxOccurs) < 1))
				throw new NumberFormatException();
		} catch (NumberFormatException e) {
			UmlCom.trace("getMaxOccurs: error - invalid multiplicity " + multiplicity);
		}
		return maxOccurs;
	}

	/** return XML minOccurs from multiplicity */
	private static String getMinOccurs(String multiplicity) {
		String minOccurs = null;
		if (multiplicity.equals(""))
			minOccurs = "1";
		else if (multiplicity.contains(","))
			minOccurs = multiplicity.split(",")[0];
		else
			minOccurs = multiplicity;
		try {
			if (Integer.parseInt(minOccurs) < 0)
				throw new NumberFormatException();
		} catch (NumberFormatException e) {
			UmlCom.trace("getMinOccurs: error - invalid multiplicity " + multiplicity);
		}
		return minOccurs;
	}

	/** return model for Umlitem item */
	private static UmlPackage getModel(UmlItem item) {
		anItemKind kind = item.kind();
		if (kind == anItemKind.aClass || kind == anItemKind.aClassInstance)
			return (UmlPackage) (item.parent().parent());
		if (kind == anItemKind.aClassView)
			return (UmlPackage) (item.parent());
		UmlCom.trace("getPrefix - error - no prefix for " + item.name());
		return null;
	}

	/** return tagname from XML tag */
	private static String getName(String tagName) {
		if (tagName == null)
			return "";
		int i = tagName.indexOf(NAMESPACE_DELIMITER);
		String name = (i >= 0) ? tagName.substring(i + 1) : tagName;
		// return name.replaceAll("[^-._:A-Za-z0-9]", "");
		return name.replaceAll("[^-._:A-Za-z0-9@]", "");
	}

	/** return tagname for UmlItem item */
	private static String getName(UmlItem item) {
		return getName(item.name());
	}

	/**
	 * return namespace for schema schemaURI in model modelPackage; create it with
	 * prefix if doesn't exist
	 */
	private static UmlClassView getNamespace(UmlPackage modelPackage, String prefix, String schemaURI) {
		if (schemaURI == null || prefix == null)
			return null;
		Namespace ns = Namespaces.get(schemaURI);
		if (ns == null) {
			// create namespace
			ns = new Namespace(schemaURI);
			Namespaces.put(schemaURI, ns);
			trace("getNamespace: added namespace " + schemaURI);
		}
		String prefix2 = filterPrefix(prefix);
		if (!Prefixes.containsKey(prefix2)) {
			// create prefix
			Prefixes.put(prefix2, schemaURI);
			trace("getNamespace: added prefix " + prefix2 + " for " + schemaURI);
		}
		// select reference, subset or extension model
		if (modelPackage == null)
			modelPackage = isNiemPrefix(prefix) ? subsetPackage : extensionPackage;

		// return classview if it exists
		if (modelPackage == referencePackage) {
			if (ns.referenceClassView != null)
				return ns.referenceClassView;
		} else if (ns.nsClassView != null)
			return ns.nsClassView;

		// create classview
		String prefix3 = prefix2;
		UmlClassView namespaceClassView = null;
		int conflictCounter = 1;

		while (namespaceClassView == null) {
			try {
				namespaceClassView = UmlClassView.create(modelPackage, prefix3);
			} catch (Exception e) {
				UmlCom.trace("getNamespace: multiple namespace URIs for prefix " + prefix3 + " " + schemaURI + " and "
						+ Prefixes.get(prefix2));
				prefix3 = prefix2 + conflictCounter;
				conflictCounter++;
			}
		}
		setURI(namespaceClassView, schemaURI);
		// trace("getNamespace: added class view " + namespaceClassView.name());

		if (prefix != null)
			setPrefix(namespaceClassView, prefix2);

		if (modelPackage == referencePackage)
			ns.referenceClassView = namespaceClassView;
		else {
			ns.nsClassView = namespaceClassView;
			if (modelPackage == extensionPackage) {
				ns.nsClassView = namespaceClassView;
				ns.filepath = prefix2 + XSD_FILE_TYPE;
				namespaceClassView.set_PropertyValue(FILE_PATH_PROPERTY, ns.filepath);
			}
		}
		return namespaceClassView;
	}

	/**
	 * return the NIEM stereotype associated with a column in the NIEM mapping
	 * spreadsheet
	 */
	private static String getNiemProperty(int p) {
		return NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[p][1];
	}

	/** return NIEM version */
	private static String getNiemVersion() {
		String niemVersion = NIEM_VERSION_DEFAULT;

		String schemaURI = Prefixes.get("nc");
		// UmlCom.trace("NIEM URI: " + schemaURI);
		Matcher mat = Pattern.compile(".*niem-core/(.*)/").matcher(schemaURI);
		if (mat.find())
			niemVersion = mat.group(1);
		UmlCom.trace("NIEM version: " + niemVersion);
		return niemVersion;
	}

	/**
	 * return child package with name packageName in parentPackage; if it doesn't
	 * exist and create is true, create it
	 */
	private static UmlPackage getPackage(UmlPackage parentPackage, String packageName, boolean create) {
		for (UmlItem item : parentPackage.children()) {
			if (item.name().equals(packageName))
				if ((item.kind() == anItemKind.aPackage))
					return (UmlPackage) item;
		}
		if (create) {
			trace("getPackage: Creating " + packageName);
			return UmlPackage.create(parentPackage, packageName);
		}
		return null;
	}

	/** return namespace prefix from XML tag */
	private static String getPrefix(String tagName) {
		if (tagName == null) {
			// trace("getPrefix: error - tagName is null");
			return null;
		}
		int i = tagName.indexOf(NAMESPACE_DELIMITER);
		if (i >= 0) {
			String prefix = tagName.substring(0, i).trim();
			return filterPrefix(prefix);
		} else
			return null;
	}

	/** return namespace prefix for UmlItem item */
	private static String getPrefix(UmlItem item) {
		switch (item.kind().value()) {
		case anItemKind._aClass:
		case anItemKind._aClassInstance:
			return getPrefix(item.parent());
		case anItemKind._aClassView:
			String prefix = item.propertyValue(PREFIX_PROPERTY);
			if (prefix != null)
				return filterPrefix(prefix);
		default:
			break;
		}
		UmlCom.trace("getPrefix - error - no prefix for " + item.name());
		return null;
	}

	/** return name with namespace prefix for an attribute with name tagName */
	private static String getPrefixedAttributeName(String prefix, String tagName) {
		return prefix + NAMESPACE_DELIMITER + ATTRIBUTE_PREFIX + filterAttributePrefix(tagName);
	}

	/** return name with namespace prefix for type or element with name tagName */
	private static String getPrefixedName(String prefix, String tagName) {
		return prefix + NAMESPACE_DELIMITER + tagName;
	}

	/** return name with namespace prefix for UmlItem item */
	private static String getPrefixedName(UmlItem item) {
		return getPrefix(item) + NAMESPACE_DELIMITER + item.name();
	}

	/** return project property with name propertyName */
	public static String getProperty(String propertyName) {
		return UmlBasePackage.getProject().propertyValue(propertyName);
	}

	/** return schemaURI for type or element with name tagname */
	private static String getSchemaURI(String tagName) {
		String prefix = getPrefix(tagName);
		if (prefix == null)
			// prefix = LOCAL_PREFIX;
			return null;
		String schemaURI = Prefixes.get(prefix);
		if (schemaURI == null)
			schemaURI = getExtensionSchema(prefix);
		return schemaURI;
	}

	/** return type in model modelPackage with schema schemaURI and name tagname */
	private static UmlClass getType(UmlPackage modelPackage, String schemaURI, String typeName) {

		// if model package not defined, default to subset or extension based on prefix
		if (modelPackage == null)
			modelPackage = isNiemPrefix(getPrefix(typeName)) ? subsetPackage : extensionPackage;

		// return cached type
		String uri = getURI(schemaURI, typeName);
		if (modelPackage == referencePackage)
			return NiemTypes.get(uri);
		else if (modelPackage == subsetPackage)
			return SubsetTypes.get(uri);
		else if (modelPackage == extensionPackage)
			return ExtensionTypes.get(uri);
		return null;
	}

	/** return URI of a item in schemaURI with name itemName */
	private static String getURI(String schemaURI, String itemName) {
		itemName.replaceAll("[^-._:A-Za-z0-9]", "");
		return schemaURI + HASH_DELIMITER + getName(itemName).replaceAll(HASH_DELIMITER, "");
	}

	/** return URI of an item */
	private static String getURI(UmlItem item) {
		return item.propertyValue(URI_PROPERTY);
	}
	
	/** hide item from documentation */
	private static void hideItem(UmlItem item) {
		item.known = false;
		for (UmlItem child : item.children())
			hideItem(child);
	}

	/** hide reference model from documentation */
	protected static void hideReferenceModel() {
		hideItem(referencePackage);
	}

	/** return code values and descriptions from enumerations in schema */
	private static String importCodeList(NodeList elist) {
		String codeList = "";
		XPathExpression xe = null;
		if (_IMPORT_CODE_DESCRIPTIONS)
			try {
				xe = xPath.compile("xs:annotation[1]/xs:documentation[1]");
			} catch (XPathExpressionException e) {
				UmlCom.trace("getCodeList: exception " + e.toString());
			}

		for (int j = 0; j < elist.getLength(); j++) {
			Element enumElement = (Element) elist.item(j);
			String value = filterEnum(filterASCII(enumElement.getAttribute("value")));
			String codeDescription = null;
			if (_IMPORT_CODE_DESCRIPTIONS)
				try {
					codeDescription = filterEnum(filterASCII(xe.evaluate(enumElement)));
				} catch (Exception e) {
					UmlCom.trace("getCodeList: error - cannot import code descriptions " + e.toString());
				}
			if (codeDescription != null && !codeDescription.equals("")) {
				codeList += value + CODELIST_DEFINITION_DELIMITER + codeDescription + CODELIST_DELIMITER + " ";
			} else
				codeList += value + CODELIST_DELIMITER + " ";
		}
		return codeList;
	}

	/** import NIEM reference model elements into HashMaps and return namespace */
	private static Namespace importElements(DocumentBuilder db, String filename) {
		// trace("importElements: importing elements from schema " + filename);
		String filename2 = "\n" + filename + "\n";
		Document doc = null;
		Namespace ns = null;
		XPathExpression xe = null;
		try {
			// parse the schema
			doc = db.parse(new File(filename));
			xPath.setNamespaceContext(new NamespaceResolver(doc, true));
			ns = importNamespaces(doc);

			// compile XPath queries
			xe = xPath.compile("xs:annotation[1]/xs:documentation[1]");
		} catch (Exception e) {
			UmlCom.trace(filename2 + "importElements: error " + e.toString());
			filename2 = "";
		}
		// get target and default prefixes
		String targetPrefix = getPrefix(ns.referenceClassView);
		String defaultSchemaURI = getDefaultSchemaURI(filename, doc);
		String defaultPrefix = getPrefix(Namespaces.get(defaultSchemaURI).referenceClassView);

		// import elements
		// trace("importElement: importing elements");
		NodeList elementList = null;
		try {
			elementList = (NodeList) xPath.evaluate("xs:element[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace("importElements: error - cannot import element " + e.toString());
		}

		for (int elementIndex = 0; elementIndex < elementList.getLength(); elementIndex++) {
			Element elementElement = (Element) elementList.item(elementIndex);
			String elementName = elementElement.getAttribute("name");
			if (getPrefix(elementName) == null)
				elementName = getPrefixedName(targetPrefix, elementName);
			String abstractAttribute = elementElement.getAttribute("abstract");
			String baseTypeSchemaURI = null;
			String baseTypeName = null;
			if (!abstractAttribute.equals("true")) {
				baseTypeName = elementElement.getAttribute("type");
				if (baseTypeName.equals(""))
					baseTypeName = null;
				else if (getPrefix(baseTypeName) == null)
					baseTypeName = getPrefixedName(defaultPrefix, baseTypeName);
				baseTypeSchemaURI = doc.lookupNamespaceURI(getPrefix(baseTypeName));
				if (baseTypeSchemaURI == null)
					baseTypeSchemaURI = getSchemaURI(baseTypeName);
				if (baseTypeName != null && baseTypeSchemaURI == null && getPrefix(baseTypeName) == null) {
					baseTypeSchemaURI = XSD_URI;
					baseTypeName = getPrefixedName(XSD_PREFIX, baseTypeName);
				}
			}
			try {
				addElement(referencePackage, ns.schemaURI, elementName, baseTypeSchemaURI, baseTypeName,
						xe.evaluate(elementElement), null);
			} catch (Exception e) {
				UmlCom.trace("importElements: error - cannot import element " + e.toString());
			}
		}

		// import attributes
		// trace("importElement: importing attributes");
		NodeList attributeList = null;
		try {
			attributeList = (NodeList) xPath.evaluate("xs:attribute[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace("importElements: error - cannot import attributes " + e.toString());
		}
		for (int attributeIndex = 0; attributeIndex < attributeList.getLength(); attributeIndex++) {
			Element attribute = (Element) attributeList.item(attributeIndex);
			String attributeName = attribute.getAttribute("name");
			String attributePrefix = getPrefix(attributeName);
			if (attributePrefix == null)
				attributePrefix = targetPrefix;
			attributeName = getPrefixedAttributeName(attributePrefix, getName(attributeName));
			// trace("importElements: adding attribute " + elementName);
			String codeList = "";
			String baseTypeSchemaURI = null;
			String baseTypeName = attribute.getAttribute("type");
			if (baseTypeName.equals(""))
				try {
					Element restriction = (Element) xPath.evaluate(".//xs:simpleType/xs:restriction[1][@base]",
							attribute, XPathConstants.NODE);
					if (restriction != null) {
						baseTypeName = restriction.getAttribute("base");
						NodeList eList = (NodeList) xPath.evaluate("xs:enumeration[@value]", restriction,
								XPathConstants.NODESET);
						codeList = importCodeList(eList);
					}
				} catch (Exception e) {
					UmlCom.trace(filename + "\nimportElements: error importing base types for attribute "
							+ attributeName + " " + e.toString());
				}
			if (baseTypeName == null || baseTypeName.equals(""))
				baseTypeName = null;
			else {
				if (getPrefix(baseTypeName) == null)
					baseTypeName = getPrefixedName(defaultPrefix, baseTypeName);
				baseTypeSchemaURI = doc.lookupNamespaceURI(getPrefix(baseTypeName));
				if (baseTypeSchemaURI == null)
					baseTypeSchemaURI = getSchemaURI(baseTypeName);
				if (baseTypeName != null && baseTypeSchemaURI == null && getPrefix(baseTypeName) == null) {
					baseTypeSchemaURI = XSD_URI;
					baseTypeName = getPrefixedName(XSD_PREFIX, baseTypeName);
				}
			}
			UmlClassInstance element = null;
			try {

				element = addElement(referencePackage, ns.schemaURI, attributeName, baseTypeSchemaURI, baseTypeName,
						xe.evaluate(attribute), null);
			} catch (Exception e) {
				UmlCom.trace(filename2 + "importElements: error - cannot add attribute " + attributeName + " of type "
						+ baseTypeName + " " + e.toString());
				filename2 = "";
			}
			if (element != null)
				if (!codeList.equals(""))
					element.set_PropertyValue(CODELIST_PROPERTY, codeList);
		}
		return ns;
	}

	/**
	 * import NIEM reference model elements in Types into HashMaps and return
	 * namespace
	 */
	private static Namespace importElementsInTypes(DocumentBuilder db, String filename) {
		// trace("importElementsInTypes: importing elements in types from schema " +
		// filename);
		// String filename2 = "\n" + filename + "\n";
		Document doc = null;
		Namespace ns = null;
		try {
			// parse the schema
			doc = db.parse(new File(filename));
			xPath.setNamespaceContext(new NamespaceResolver(doc, true));
			ns = importNamespaces(doc);
		} catch (Exception e) {
			UmlCom.trace(filename + "\nimportElementsInTypes: error parsing the schema " + e.toString());
		}

		// get target and default prefixes
		String targetPrefix = getPrefix(ns.referenceClassView);
		String defaultSchemaURI = getDefaultSchemaURI(filename, doc);
		String defaultPrefix = getPrefix(Namespaces.get(defaultSchemaURI).referenceClassView);

		// import attributes in attribute groups
		// trace("importElementsInTypes: import attributes in attribute groups");
		Node root = null;
		NodeList attributeGroupList = null;
		try {
			root = doc.getDocumentElement();
			attributeGroupList = (NodeList) xPath.evaluate("xs:attributeGroup[@name]", root, XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace(filename + "\nimportElementsInTypes: error parsing the schema " + e.toString());
		}

		for (int attributeGroupIndex = 0; attributeGroupIndex < attributeGroupList.getLength(); attributeGroupIndex++) {
			Element attributeGroupElement = (Element) attributeGroupList.item(attributeGroupIndex);
			String attributeGroupName = attributeGroupElement.getAttribute("name");
			if (getPrefix(attributeGroupName) == null)
				attributeGroupName = getPrefixedAttributeName(targetPrefix, attributeGroupName);
			UmlClass attributeGroup = getType(referencePackage, ns.schemaURI, attributeGroupName);
			if (attributeGroup == null) {
				UmlCom.trace("importElementsInType: error - attribute group " + attributeGroupName
						+ " not in reference model");
				continue;
			}
			NodeList attributeList = null;
			try {
				attributeList = (NodeList) xPath.evaluate(".//xs:attribute[@ref]", attributeGroupElement,
						XPathConstants.NODESET);
			} catch (Exception e) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error parsing the schema " + e.toString());
			}
			for (int attributeIndex = 0; attributeIndex < attributeList.getLength(); attributeIndex++) {
				Element attributeElement = (Element) attributeList.item(attributeIndex);
				String attributeName = attributeElement.getAttribute("ref");
				String attributePrefix = getPrefix(attributeName);
				if (attributePrefix == null)
					attributePrefix = defaultPrefix;
				attributeName = getPrefixedAttributeName(attributePrefix, getName(attributeName));
				String multiplicity = (attributeElement.getAttribute("use")).equals("required") ? "1,1" : "0,1";
				String attributeSchemaURI = doc.lookupNamespaceURI(getPrefix(attributeName));
				if (attributeSchemaURI == null)
					attributeSchemaURI = getSchemaURI(attributeName);
				if (attributeSchemaURI == null) {
					UmlCom.trace("addElementInType: error - prefix for attribute " + attributeName + " not in model");
					continue;
				}
				UmlClassInstance element = getElement(referencePackage, attributeSchemaURI, getName(attributeName));
				if (element == null) {
					UmlCom.trace("importElementsInType: error - attribute " + attributeName + " not in model");
					continue;
				}
				addElementInType(attributeGroup, element, multiplicity);
			}
		}

		// import base types for simple types (codes)
		// trace("importElementsInTypes: import base types for simple types (codes)");
		NodeList simpleTypeNodeList = null;
		try {
			simpleTypeNodeList = (NodeList) xPath.evaluate("xs:simpleType[@name]/xs:restriction[1][@base]", root,
					XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace(
					filename + "\nimportElementsInTypes: error importing base types for simple types " + e.toString());
		}
		for (int elementIndex = 0; elementIndex < simpleTypeNodeList.getLength(); elementIndex++) {
			Element restrictionElement = (Element) simpleTypeNodeList.item(elementIndex);
			Element typeElement = (Element) restrictionElement.getParentNode();
			String typeName = typeElement.getAttribute("name");
			if (getPrefix(typeName) == null)
				typeName = getPrefixedName(targetPrefix, typeName);
			String baseTypeName = restrictionElement.getAttribute("base");
			if (getPrefix(baseTypeName) == null)
				baseTypeName = getPrefixedName(defaultPrefix, baseTypeName);
			UmlClass type = getType((UmlPackage) (ns.referenceClassView.parent()), ns.schemaURI, typeName);
			if (type == null)
				continue;
			UmlClass baseType = getType(referencePackage, doc.lookupNamespaceURI(getPrefix(baseTypeName)),
					baseTypeName);
			if (baseType == null)
				continue;
			relateBaseType(type, baseType);
		}

		// import base types and elements for complex types
		// trace("importElementsInTypes: import base types and elements for complex
		// types");
		NodeList complexTypeNodeList = null;
		try {
			complexTypeNodeList = (NodeList) xPath.evaluate("xs:complexType[@name]", root, XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace(filename + "\nimportElementsInTypes: error parsing types" + e.toString());
		}
		for (int elementIndex = 0; elementIndex < complexTypeNodeList.getLength(); elementIndex++) {
			Element typeElement = (Element) complexTypeNodeList.item(elementIndex);
			if (typeElement == null)
				continue;
			String typeName = typeElement.getAttribute("name");
			if (getPrefix(typeName) == null)
				typeName = getPrefixedName(targetPrefix, typeName);
			UmlClass type = getType((UmlPackage) (ns.referenceClassView.parent()), ns.schemaURI, typeName);
			if (type == null)
				continue;

			// import base types for complex types
			// trace("importElementsInTypes: import base types for complex types");
			NodeList baseTypeList = null;
			try {
				baseTypeList = (NodeList) xPath.evaluate(
						"xs:simpleContent[1]/xs:extension[1][@base] | xs:complexContent[1]/xs:extension[1][@base]",
						typeElement, XPathConstants.NODESET);
			} catch (Exception e) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error importing base types for complex types"
						+ e.toString());
			}
			for (int baseTypeIndex = 0; baseTypeIndex < baseTypeList.getLength(); baseTypeIndex++) {
				Element baseTypeElement = (Element) baseTypeList.item(baseTypeIndex);
				String baseTypeName = baseTypeElement.getAttribute("base");
				if (getPrefix(baseTypeName) == null)
					baseTypeName = getPrefixedName(defaultPrefix, baseTypeName);
				UmlClass baseType = getType(referencePackage, doc.lookupNamespaceURI(getPrefix(baseTypeName)),
						baseTypeName);
				if (baseType == null)
					continue;
				relateBaseType(type, baseType);
			}

			// import attribute groups in type
			// trace("importElementsInTypes: import attributes groups in types");
			NodeList attributeGroupInTypeNodeList = null;
			try {
				attributeGroupInTypeNodeList = (NodeList) xPath.evaluate(".//xs:attributeGroup[@ref]", typeElement,
						XPathConstants.NODESET);
			} catch (Exception e) {
				UmlCom.trace(filename + "\nimportElementsInTypes:error importing attributeGroup in complex types"
						+ e.toString());
			}
			for (int attributeGroupIndex = 0; attributeGroupIndex < attributeGroupInTypeNodeList
					.getLength(); attributeGroupIndex++) {
				Element attributeGroupElement = (Element) attributeGroupInTypeNodeList.item(attributeGroupIndex);
				String attributeGroupName = attributeGroupElement.getAttribute("ref");
				if (getPrefix(attributeGroupName) == null)
					attributeGroupName = getPrefixedName(defaultPrefix, attributeGroupName);
				String prefix = getPrefix(attributeGroupName);
				String schemaURI = (prefix == null) ? ns.schemaURI : doc.lookupNamespaceURI(prefix);
				UmlClass attributeGroupType = getType(referencePackage, schemaURI,
						getPrefixedAttributeName(getPrefix(attributeGroupName), getName(attributeGroupName)));
				if (attributeGroupType == null)
					continue;
				relateAttributeGroup(type, attributeGroupType);
			}

			// import attributes in type
			// trace("importElementsInTypes: import attributes in types");
			NodeList attributeInTypeNodeList = null;
			try {
				attributeInTypeNodeList = (NodeList) xPath.evaluate(".//xs:attribute[@ref]", typeElement,
						XPathConstants.NODESET);
			} catch (Exception re) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error importing attributes in type " + re.toString());
			}
			for (int attributeIndex = 0; attributeIndex < attributeInTypeNodeList.getLength(); attributeIndex++) {
				Element attributeElement = (Element) attributeInTypeNodeList.item(attributeIndex);
				String attributeName = attributeElement.getAttribute("ref");
				if (getPrefix(attributeName) == null)
					attributeName = getPrefixedName(defaultPrefix, attributeName);
				String multiplicity = (attributeElement.getAttribute("use").equals("required")) ? "1,1" : "0,1";
				UmlClassInstance element = getElement(referencePackage,
						doc.lookupNamespaceURI(getPrefix(attributeName)),
						getPrefixedAttributeName(getPrefix(attributeName), attributeName));
				addElementInType(type, element, multiplicity);
				// trace("importElementsInTypes: imported attribute :" + attributeName + " in
				// group " + typeName);
			}

			// import elements in type
			// trace("importElementsInTypes: import elements in types");
			NodeList elementInTypeNodeList = null;
			try {
				elementInTypeNodeList = (NodeList) xPath.evaluate(".//xs:sequence[1]/xs:element[@ref]", typeElement,
						XPathConstants.NODESET);
			} catch (Exception e) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error importing elements in type " + e.toString());
			}
			String elementName = null;
			try {
				for (int elementInTypeIndex = 0; elementInTypeIndex < elementInTypeNodeList
						.getLength(); elementInTypeIndex++) {
					Element elementElement = (Element) elementInTypeNodeList.item(elementInTypeIndex);
					elementName = elementElement.getAttribute("ref");
					// trace("importElementsInTypes: adding element " + elementName + " to type " +
					// typeName);
					if (getPrefix(elementName) == null)
						elementName = getPrefixedName(defaultPrefix, elementName);
					String minOccurs = elementElement.getAttribute("minOccurs");
					if (minOccurs.equals(""))
						minOccurs = "1";
					String maxOccurs = elementElement.getAttribute("maxOccurs");
					if (maxOccurs.equals(""))
						maxOccurs = "1";
					String multiplicity = minOccurs + "," + maxOccurs;
					String elementSchemaURI = doc.lookupNamespaceURI(getPrefix(elementName));
					if (elementSchemaURI == null)
						elementSchemaURI = getSchemaURI(elementName);
					if (elementSchemaURI == null) {
						UmlCom.trace(
								"importElementsInType: error - prefix for element " + elementName + " not in model");
						continue;
					}
					UmlClassInstance element = getElement(referencePackage, elementSchemaURI, elementName);
					if (element == null) {
						UmlCom.trace("importElementsInType: error - element " + getURI(elementSchemaURI, elementName)
						+ " not in reference model");
						continue;
					}
					addElementInType(type, element, multiplicity);
					// trace("importElementsInTypes: added element " + elementName + " in type " +
					// typeName);

				}
			} catch (Exception re) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error importing element " + elementName + " in type "
						+ typeName + " " + re.toString());
			}
		}
		return ns;
	}

	/** import namespaces and return target namespace */
	private static Namespace importNamespaces(Document doc) {
		NamedNodeMap nslist = doc.getDocumentElement().getAttributes();
		for (int nsIndex = 0; nsIndex < nslist.getLength(); nsIndex++) {
			Node attributeNode = nslist.item(nsIndex);
			String attributeNodeName = attributeNode.getNodeName();
			if (attributeNodeName.startsWith(NAMESPACE_ATTRIBUTE)) {
				String prefix = (attributeNodeName.equals(NAMESPACE_ATTRIBUTE)) ? attributeNode.getNodeValue()
						: attributeNodeName.substring(6);
				getNamespace(referencePackage, prefix, attributeNode.getNodeValue());
			}
		}

		String schemaURI = null;
		Namespace ns = null;
		try {
			// get target namespace
			schemaURI = xPath.evaluate("xs:schema/@targetNamespace", doc);
			// schemaURI = doc.lookupNamespaceURI(null);
			ns = Namespaces.get(schemaURI);
			if (ns == null)
				return Namespaces.get(LOCAL_PREFIX);
			// set namespace description
			ns.referenceClassView
			.set_Description(xPath.evaluate("xs:schema/xs:annotation[1]/xs:documentation[1]", doc));
		} catch (Exception e) {
			UmlCom.trace("importNamespaces: error " + e.toString());
		}
		return ns;
	}

	/** import NIEM reference model types into HashMaps and return namespace */
	private static Namespace importTypes(DocumentBuilder db, String filename) {
		// trace("importTypes: importing types from schema " + filename);
		String filename2 = "\n" + filename + "\n";
		Namespace ns = null;
		Document doc = null;
		XPathExpression xe = null;
		XPathExpression xe1 = null;
		try {
			// parse the schema
			doc = db.parse(new File(filename));
			xPath.setNamespaceContext(new NamespaceResolver(doc, true));
			ns = importNamespaces(doc);

			// compile XPath queries
			xe = xPath.compile("xs:annotation[1]/xs:documentation[1]");
			xe1 = xPath.compile("xs:restriction[1]/xs:enumeration");
		} catch (Exception re) {
			UmlCom.trace(filename2 + "importTypes: error " + re.toString());
			filename2 = "";
		}
		// get target and default prefixes
		String targetPrefix = getPrefix(ns.referenceClassView);

		// import types
		NodeList typeList = null;
		try {
			typeList = (NodeList) xPath.evaluate("xs:complexType|xs:simpleType[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace(filename2 + "importTypes: error - cannot parse types " + e.toString());
		}

		for (int typeIndex = 0; typeIndex < typeList.getLength(); typeIndex++) {
			Element typeElement = (Element) typeList.item(typeIndex);
			String nodeType = typeElement.getNodeName();
			String typeName = typeElement.getAttribute("name");
			if (getPrefix(typeName) == null)
				typeName = getPrefixedName(targetPrefix, typeName);
			UmlClass type = null;
			try {
				type = addType(referencePackage, ns.schemaURI, typeName, xe.evaluate(typeElement), null);
			} catch (Exception e) {
				UmlCom.trace(filename2 + "importTypes: cannot add type " + typeName + " to schema " + ns.schemaURI + " "
						+ e.toString());
			}
			if (type == null)
				continue;
			if (nodeType == "xs:simpleType") {
				type.set_Stereotype("enum_pattern");
				// import enumerated values for simple types (codes)
				NodeList elist = null;
				try {
					elist = (NodeList) xe1.evaluate(typeElement, XPathConstants.NODESET);
				} catch (Exception e) {
					UmlCom.trace(filename2 + "importTypes: error - cannot import enumerations " + e.toString());
				}
				String codeList = importCodeList(elist);
				if (!codeList.equals(""))
					type.set_PropertyValue(CODELIST_PROPERTY, codeList);
			}
		}

		// import attribute groups
		NodeList attributeGroupList = null;
		try {
			attributeGroupList = (NodeList) xPath.evaluate("xs:attributeGroup[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
		} catch (XPathExpressionException e) {
			UmlCom.trace(filename2 + "importTypes: error - cannot parse attribute groups " + e.toString());
		}
		for (int attributeGroupIndex = 0; attributeGroupIndex < attributeGroupList.getLength(); attributeGroupIndex++) {
			Element attributeGroupElement = (Element) attributeGroupList.item(attributeGroupIndex);
			String attributeGroupName = attributeGroupElement.getAttribute("name");
			String attributeGroupPrefix = getPrefix(attributeGroupName);
			if (attributeGroupPrefix == null)
				attributeGroupPrefix = targetPrefix;
			attributeGroupName = getPrefixedAttributeName(attributeGroupPrefix, getName(attributeGroupName));
			try {
				addType(referencePackage, ns.schemaURI, attributeGroupName, xe.evaluate(attributeGroupElement), null);
			} catch (Exception e) {
				UmlCom.trace(filename2 + "importTypes: error - cannot add attribute group " + attributeGroupName + " "
						+ e.toString());
				filename2 = "";
			}
		}
		return ns;
	}

	/** returns true if the UML item is an attribute or attribute group */
	private static boolean isAttribute(UmlItem item) {
		return getName(item).startsWith(ATTRIBUTE_PREFIX);
	}

	/** return true if type or element has a prefix in an external schema */
	private static Boolean isExternalPrefix(String prefix) {
		if (prefix == null)
			return false;
		return externalPrefixes.contains(prefix);
	}

	/** return true if an element exists in reference model */
	private static Boolean isNiemElement(String elementName) {
		if ((elementName == null) || elementName.equals("") || elementName.equals("??")
				|| isExternalPrefix(getPrefix(elementName)))
			return false;
		String schemaURI = Prefixes.get(getPrefix(elementName));
		if (schemaURI == null)
			return false;
		return NiemElements.containsKey(getURI(schemaURI, elementName));
	}

	/** return true if an element in type exists in reference model */
	private static Boolean isNiemElementInType(String typeName, String elementName) {
		if (!isNiemType(typeName) || !isNiemElement(elementName))
			return false;
		UmlClassInstance element = getElement(referencePackage, getSchemaURI(elementName), elementName);
		List<UmlClassInstance> elementList = getElementsInType(referencePackage,
				getURI(getSchemaURI(typeName), typeName));
		for (UmlClassInstance element2 : elementList)
			if (element.equals(element2))
				return true;
		UmlCom.trace("isNiemElementInType: error - element " + elementName + " not in type " + typeName);
		return false;
	}

	/** return true if a prefix exists in reference model */
	private static Boolean isNiemPrefix(String prefix) {
		if (prefix == null)
			return false;
		if (isExternalPrefix(prefix))
			return false;
		String schemaURI = Prefixes.get(prefix);
		Namespace ns = Namespaces.get(schemaURI);
		if (ns == null)
			return false;
		return ns.referenceClassView != null;
	}

	/** returns true if type exists in reference model */
	private static Boolean isNiemType(String typeName) {
		if ((typeName == null) || typeName.equals("") || typeName.equals("??") || isExternalPrefix(getPrefix(typeName)))
			return false;
		String schemaURI = Prefixes.get(getPrefix(typeName));
		if (schemaURI == null)
			return false;
		return NiemTypes.containsKey(getURI(schemaURI, typeName));
	}

	/** create a relationship between a type and an attribute group */
	private static void relateAttributeGroup(UmlClass type, UmlClass attributeGroupType) {
		if (type != null && attributeGroupType != null)
			try {
				UmlBaseRelation.create(aRelationKind.aDirectionalAggregation, type, attributeGroupType);
			} catch (Exception re) {
				// trace("createSubsetAndExtension: " + typeName + " already related to
				// attribute group " + baseTypeName);
			}
	}

	/** create a relationship between a type and a base type */
	private static void relateBaseType(UmlClass type, UmlClass baseType) {
		if (type != null && baseType != null)
			try {
				UmlBaseRelation.create(aRelationKind.aGeneralisation, type, baseType);
			} catch (Exception re) {
				// trace("copyType: error - type " + type.name() + " already related to base
				// type " + sourceBaseTypeName);
			}
	}

	/** relate element in type to element */
	private static void relateElementInType(UmlAttribute elementInType, UmlClassInstance element) {
		UmlTypeSpec elementType = new UmlTypeSpec();
		elementType.type = getBaseType(element);
		if (elementType.type != null)
			try {
				elementInType.set_Type(elementType);
			} catch (Exception re) {
				UmlCom.trace("relateElementInType: error relating element in type to " + getPrefixedName(element) + " "
						+ re.toString());
			}
	}

	/** add a description to type or element */
	private static void setDescription(UmlItem item, String description) {
		String currentDescription = item.description();
		if ((currentDescription.equals("")) && (description != null) && (!description.equals("")))
			item.set_Description(description);
	}

	/** add NIEM mapping notes to a type or element */
	private static void setNotes(UmlItem item, String notes) {
		if ((item != null) && (notes != null) && (!notes.equals(""))) {
			String currentNotes = item.propertyValue(NOTES_PROPERTY);
			if (currentNotes == null)
				currentNotes = notes;
			else if (!currentNotes.contains(notes))
				currentNotes = currentNotes + "; " + notes;
			if (!currentNotes.equals(""))
				item.set_PropertyValue(NOTES_PROPERTY, currentNotes);
		}
	}

	/** sets the prefix of an UmlItem */
	private static void setPrefix(UmlItem item, String prefix) {
		item.set_PropertyValue(PREFIX_PROPERTY, prefix);
	}

	/** sets a project property */
	private static void setPropertyDefault(String propertyName, String propertyValue) {
		UmlPackage root = UmlBasePackage.getProject();
		if (root.propertyValue(propertyName) == null)
			root.set_PropertyValue(propertyName, propertyValue);
	}

	/** sets the URI of an UmlItem */
	private static void setURI(UmlItem item, String uri) {
		item.set_PropertyValue(URI_PROPERTY, uri);
	}

	/** outputs debugging information */
	private static void trace(String output) {
		if (_TRACE)
			UmlCom.trace(output);
	}

	/** writes a column of the NIEM mapping spreadsheet in HTML format to a file */
	private static void writeItemHtml(FileWriter fw, UmlItem item) throws IOException {
		if (item.known) {
			fw.write("<a href=\"");
			if (!UmlItem.flat && (item.parent() != null) && (item.parent().kind() == anItemKind.aClass)) {
				fw.write("class");
				fw.write(String.valueOf(item.parent().getIdentifier()));
			} else
				fw.write("index");
			fw.write(HTML_FILE_TYPE + "#ref");
			fw.write(String.valueOf(item.kind().value()));
			fw.write('_');
			fw.write(String.valueOf(item.getIdentifier()));
			fw.write("\"><b>");
			fw.write(item.name());
			fw.write("</b></a>");
		} else
			fw.write(item.name());
	}

	/** writes a line of the NIEM mapping spreadsheet in HTML format to a file */
	private static void writeLineHtml(FileWriter fw, UmlItem item) {
		try {
			// Export Class, Property and Multiplicity
			// trace("writeLineHtml: " + item.name());
			switch (item.kind().value()) {
			case anItemKind._aClass: {
				fw.write("<tr bgcolor=\"#f0f0f0\"><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item);
				fw.write("</td><td>");
				fw.write("</td><td>");
			}
			break;
			case anItemKind._anAttribute: {
				fw.write("<tr><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item.parent());
				fw.write("</td><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item);
				fw.write("</td><td>");
				UmlAttribute a = (UmlAttribute) item;
				fw.write(a.multiplicity());
			}
			break;
			case anItemKind._aRelation: {
				UmlRelation rel = (UmlRelation) item;
				if ((rel.relationKind() == aRelationKind.aGeneralisation)
						|| (rel.relationKind() == aRelationKind.aRealization))
					return;
				else {
					fw.write("<tr><td style=\"word-wrap: break-word\">");
					writeItemHtml(fw, item.parent());
					fw.write("</td><td style=\"word-wrap: break-word\">");
					writeItemHtml(fw, item);
					fw.write("</td><td>");
					fw.write(rel.multiplicity());
				}
			}
			break;
			default:
				return;
			}
			fw.write("</td><td>");

			// Export Description
			if (item.description() != null)
				fw.write(item.description());
			fw.write("</td>");

			// Export NIEM Mapping
			int columnIndex;
			// String oldValue, container;
			String[] column = new String[NIEM_STEREOTYPE_MAP.length];
			String extensionBGColor = "#ffd700";
			String defaultBGColor = "#ffffff";
			String invalidFGColor = "#ff0000"; // invalid NIEM mappings are red
			String changedFGColor = "#0000ff"; // changes from the previous
			// version are blue
			String defaultFGColor = "#000000";
			String fgcolor, bgcolor;

			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
				for (columnIndex = 4; columnIndex < NIEM_STEREOTYPE_MAP.length; columnIndex++) {
					column[columnIndex] = (String) (item.propertyValue(getNiemProperty(columnIndex)));
					column[columnIndex] = (column[columnIndex] != null) ? column[columnIndex].trim() : "";
				}

				// determine if this is an extension
				/*
				 * Boolean extension = false; String[] xPathElements = column[4].split("/"); for
				 * (String element : xPathElements) { String prefix = getPrefix(element); if
				 * (!prefix.equals("") && !isNiemSchema(prefix) &&
				 * !isExternalPrefix(getPrefix(element.trim()))) { extension = true; continue; }
				 * }
				 */

				// export XPath
				String XPath = column[4].trim();
				String oldXPath = column[9].trim();
				// bgcolor = (extension) ? extensionBGColor : defaultBGColor;
				bgcolor = defaultBGColor;
				fgcolor = (XPath.equals(oldXPath)) ? defaultFGColor : changedFGColor;
				fw.write(getColumnHtml(XPath, bgcolor, fgcolor, true));

				// export Type
				String typeName = column[5].trim();
				String typePrefix = getPrefix(typeName);
				bgcolor = defaultBGColor;
				fgcolor = defaultFGColor;
				if (!typeName.equals("")) {
					if (isNiemPrefix(getPrefix(typeName)) && !isNiemType(typeName))
						fgcolor = invalidFGColor;
					if (!isNiemPrefix(typePrefix) && !isExternalPrefix(typePrefix))
						bgcolor = extensionBGColor;
				}
				fw.write(getColumnHtml(typeName, bgcolor, fgcolor, true));

				// export Property
				String elementLine = column[6];
				fgcolor = defaultFGColor;
				bgcolor = defaultBGColor;
				if (!elementLine.equals("")) {
					String[] elementNames = elementLine.split(",");
					for (String elementName : elementNames) {
						elementName = elementName.trim();
						Matcher mat = Pattern.compile("\\((.*?)\\)").matcher(elementName);
						if (!mat.find()) {
							String prefix = getPrefix(elementName);
							if (isNiemPrefix(typePrefix) && isNiemPrefix(prefix)
									&& !isNiemElementInType(typeName, elementName))
								fgcolor = invalidFGColor;
							prefix = getPrefix(elementLine);
							if (!isNiemPrefix(prefix) && !isExternalPrefix(prefix))
								bgcolor = extensionBGColor;
						}
					}
				}
				fw.write(getColumnHtml(elementLine, bgcolor, fgcolor, true));

				// export BaseType
				String baseType = column[7].trim();
				String basePrefix = getPrefix(baseType);
				bgcolor = defaultBGColor;
				fgcolor = defaultFGColor;
				if (!baseType.equals("") && !baseType.equals(ABSTRACT_TYPE_NAME)) {
					if (!isNiemPrefix(basePrefix) && !isExternalPrefix(basePrefix))
						bgcolor = extensionBGColor;
					if (isNiemPrefix(basePrefix) && !isNiemType(baseType))
						fgcolor = invalidFGColor;
				}
				fw.write(getColumnHtml(baseType, bgcolor, fgcolor, true));

				// export Multiplicity
				bgcolor = defaultBGColor;
				String multiplicity = column[8];
				fgcolor = (multiplicity.equals(column[10])) ? defaultFGColor : changedFGColor;
				String minOccurs = getMinOccurs(multiplicity);
				String maxOccurs = getMaxOccurs(multiplicity);
				try {
					if (Integer.parseInt(minOccurs) < 0)
						throw new NumberFormatException();
					if (!maxOccurs.equals("unbounded") && (Integer.parseInt(maxOccurs) < 1))
						throw new NumberFormatException();
				} catch (NumberFormatException e) {
					fgcolor = invalidFGColor;
				}
				fw.write(getColumnHtml(column[8], bgcolor, fgcolor, false));

				// export Old XPath, Multiplicity, Mapping Notes, code list
				fgcolor = defaultFGColor;
				fw.write(getColumnHtml(column[9], bgcolor, fgcolor, true));
				fw.write(getColumnHtml(column[10], bgcolor, fgcolor, false));
				fw.write(getColumnHtml(column[11], bgcolor, fgcolor, true));
				fw.write(getColumnHtml(column[12], bgcolor, fgcolor, true));
			}
			fw.write("</tr>");
		} catch (Exception e) {
			UmlCom.trace("writeLineHtml: error " + e.toString());
		}
	}

	/** writes an XML name value pair to a file */
	private static void writeXmlAttribute(FileWriter fw, String name, String value) {
		try {
			fw.write(" " + name + "=\"" + value + "\"");
		} catch (Exception e) {
			UmlCom.trace("xmlAttribute: error " + e.toString());
		}
	}

	/** writes an XML namespace attribute to a file */
	private static void writeXmlNs(FileWriter fw, String prefix, String value) {
		try {
			if (prefix.equals(""))
				fw.write(" " + NAMESPACE_ATTRIBUTE + "=\"" + value + "\"");
			else
				fw.write(" " + NAMESPACE_ATTRIBUTE + ":" + prefix + "=\"" + value + "\"");
		} catch (Exception e) {
			UmlCom.trace("xmlNS: error " + e.toString());
		}
	}

	/** initialize NiemTools project */
	public NiemTools() {
		super();

		// set IEPD configuration defaults
		setPropertyDefault(IEPD_URI_PROPERTY, IEPD_URI_DEFAULT);
		setPropertyDefault(IEPD_NAME_PROPERTY, IEPD_NAME_DEFAULT);
		setPropertyDefault(IEPD_VERSION_PROPERTY, IEPD_VERSION_DEFAULT);
		setPropertyDefault(IEPD_STATUS_PROPERTY, IEPD_STATUS_DEFAULT);
		setPropertyDefault(IEPD_ORGANIZATION_PROPERTY, IEPD_ORGANIZATION_DEFAULT);
		setPropertyDefault(IEPD_CONTACT_PROPERTY, IEPD_CONTACT_DEFAULT);
		setPropertyDefault(IEPD_EMAIL_PROPERTY, IEPD_EMAIL_DEFAULT);
		setPropertyDefault(IEPD_LICENSE_URL_PROPERTY, IEPD_LICENSE_URL_DEFAULT);
		setPropertyDefault(IEPD_TERMS_URL_PROPERTY, IEPD_TERMS_URL_DEFAULT);
		setPropertyDefault(IEPD_READ_ME_FILE_PROPERTY, IEPD_READ_ME_FILE_DEFAULT);
		setPropertyDefault(IEPD_CHANGE_LOG_FILE_PROPERTY, IEPD_CHANGE_LOG_FILE_DEFAULT);
		setPropertyDefault(IEPD_EXTERNAL_SCHEMAS_PROPERTY, IEPD_EXTERNAL_SCHEMAS_DEFAULT);
	}

	/** caches namespaces and prefixes for external schemas */
	public void cacheModels() {
		trace("cacheModels: caching reference, subset and extension models");
		cacheExternalSchemas();
		cacheModel(referencePackage);
		cacheModel(subsetPackage);
		cacheModel(extensionPackage);
	}

	/** creates Platform Independent Model (NIEM) */
	public void createNIEM() {
		UmlPackage pimPackage = null;
		trace("createNIEM: Creating NIEM folders");
		// Find or create NIEM packages
		pimPackage = getPackage(UmlBasePackage.getProject(), NIEM_PACKAGE, true);
		subsetPackage = getPackage(pimPackage, NIEM_SUBSET_PACKAGE, true);
		extensionPackage = getPackage(pimPackage, NIEM_EXTENSION_PACKAGE, true);
		referencePackage = getPackage(pimPackage, NIEM_REFERENCE_PACKAGE, true);
		referencePackage.set_Stereotype("framework");
	}

	/** creates NIEM subset and extension models */
	@SuppressWarnings("unchecked")
	public void createSubsetAndExtension() {

		// cache NIEM namespaces, elements and types
		trace("createSubsetAndExtension: cache models");
		// cacheModel(referencePackage);
		// cacheModel(subsetPackage);
		// cacheModel(extensionPackage);

		Iterator<UmlItem> it = (UmlItem.all.iterator());
		// add types to subset and extension
		trace("createSubsetAndExtension: copy subset types and create extension types");
		it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				continue;
			String typeName = item.propertyValue(NIEM_STEREOTYPE_TYPENAME).trim();
			String elementName = item.propertyValue(NIEM_STEREOTYPE_PROPERTY).trim();
			String notes = item.propertyValue(NIEM_STEREOTYPE_NOTES).trim();
			String baseTypeName = item.propertyValue(NIEM_STEREOTYPE_BASE_TYPE).trim();
			if (baseTypeName.equals(ABSTRACT_TYPE_NAME))
				continue;
			// trace("createSubsetAndExtension: adding type " + typeName + " and base type "
			// + baseTypeName);
			String description = null;
			if (elementName.equals(""))
				if (typeName.endsWith(AUGMENTATION_TYPE_NAME))
					description = "An augmentation type";
				else
					description = item.description().trim();

			// add base type
			if (!baseTypeName.equals(""))
				if (isNiemType(baseTypeName))
					copyType(baseTypeName);
				else
					addType(extensionPackage, getSchemaURI(baseTypeName), baseTypeName, null, null);

			// add type
			if (!typeName.equals(""))
				if (isNiemType(typeName))
					copyType(typeName);
				else
					addType(extensionPackage, getSchemaURI(typeName), typeName, description, notes);
		}

		// relate extension types to base types and attribute groups
		trace("createSubsetAndExtension: copy subset base types and create extension base types");
		it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				continue;
			String typeName = item.propertyValue(NIEM_STEREOTYPE_TYPENAME).trim();
			String elementName = item.propertyValue(NIEM_STEREOTYPE_PROPERTY).trim();
			String baseTypeName = item.propertyValue(NIEM_STEREOTYPE_BASE_TYPE).trim();
			if (typeName.equals("") || isNiemType(typeName))
				continue;
			UmlClass type = getType(null, getSchemaURI(typeName), typeName);
			if (type == null)
				continue;
			UmlClass baseType = null;
			if (baseTypeName.equals("") || typeName.endsWith(AUGMENTATION_TYPE_NAME))
				baseType = subsetAugmentationType;
			else {
				if (!elementName.equals(""))
					continue;
				if (baseTypeName.equals("")) {
					UmlCom.trace("createSubsetAndExtension: base type not defined for type " + typeName
							+ "; using default base type.");
					baseType = subsetObjectType;
				} else
					baseType = getType(null, getSchemaURI(baseTypeName), baseTypeName);
				if (baseType == null) {
					UmlCom.trace("createSubsetAndExtension: base type " + baseTypeName + " not found.");
					continue;
				}
			}

			// relate type to base type
			relateBaseType(type, baseType);

			// If type is based on simple type, add attribute group
			String baseTypePrefix = getPrefix(baseType);
			if (baseTypePrefix != null && baseTypePrefix.equals(XSD_PREFIX))
				relateAttributeGroup(type, subsetSimpleObjectAttributeGroup);
		}

		// Copy subset elements and create extension elements
		trace("createSubsetAndExtension: copy subset elements and create extension elements");
		it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				continue;
			String typeName = item.propertyValue(NIEM_STEREOTYPE_TYPENAME).trim();
			String elementList = item.propertyValue(NIEM_STEREOTYPE_PROPERTY).trim();
			String baseTypeName = item.propertyValue(NIEM_STEREOTYPE_BASE_TYPE).trim();
			String multiplicity = item.propertyValue(NIEM_STEREOTYPE_MULTIPLICITY).trim();
			String description = item.description().trim();
			String mappingNotes = item.propertyValue(NIEM_STEREOTYPE_NOTES).trim();
			String codeList = item.propertyValue(NIEM_STEREOTYPE_CODE_LIST).trim();

			boolean substitution = elementList.contains("(");
			String headElement = null;
			String[] elementNames = elementList.split(",");
			for (String elementName : elementNames) {
				boolean representation = false;
				if (elementName.contains("(")) {
					elementName = elementName.replaceAll("\\(|\\)", "");
					representation = true;
				}
				elementName = elementName.trim();
				if (elementName.equals(""))
					continue;
				if (elementName.contains("Augmentation") && description.equals(""))
					description = "An augmentation";
				Boolean isNillable = elementName.startsWith(REFERENCE_PREFIX);
				if (isNillable)
					elementName = elementName.substring(1);
				// trace("createSubsetAndExtension: adding element " + elementName + " in type "
				// + typeName);
				if (substitution && !representation && headElement == null)
					headElement = elementName;
				String baseTypeName2 = baseTypeName;
				if (baseTypeName.equals(ABSTRACT_TYPE_NAME) || (substitution && !representation))
					baseTypeName2 = getPrefixedName(LOCAL_PREFIX, ABSTRACT_TYPE_NAME);

				// copy NIEM element or add extension element
				UmlClassInstance element = (isNiemElement(elementName)) ? copyElement(elementName)
						: addElement(extensionPackage, getSchemaURI(elementName), elementName,
								getSchemaURI(baseTypeName2), baseTypeName2, description, mappingNotes);
				if (element == null)
					continue;

				// copy element in type
				if ((!substitution || !representation) && !typeName.equals("")) {
					UmlClass type = getType(null, getSchemaURI(typeName), typeName);
					if (type != null)
						if (isNiemType(typeName))
							copyElementInType(type, element, multiplicity);
						else
							addElementInType(type, element, multiplicity);
				}

				if (isNillable)
					element.set_PropertyValue(NILLABLE_PROPERTY, "true");
				if (headElement != null && substitution && representation)
					element.set_PropertyValue(SUBSTITUTION_PROPERTY, headElement);
				if (codeList != null && !codeList.equals("") && (!substitution || !representation))
					element.set_PropertyValue(CODELIST_PROPERTY, codeList);
			}
		}

		// Sorting
		trace("createSubsetAndExtension: sorting namespaces");
		subsetPackage.sort();
		extensionPackage.sort();
	}

	/** deletes NIEM mappings */
	public void deleteMapping() {
		@SuppressWarnings("unchecked")
		Iterator<UmlItem> it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE) && item.kind() != anItemKind.aClassInstance)
				for (int property = 4; property < NIEM_STEREOTYPE_MAP.length; property++)
					item.set_PropertyValue(getNiemProperty(property), "");
		}
	}

	/** deletes NIEM models */
	public void deleteNIEM(boolean deleteReferenceModel) {

		// Find NIEM package
		UmlPackage pimPackage = getPackage(UmlBasePackage.getProject(), NIEM_PACKAGE, true);

		// delete reference model
		if (deleteReferenceModel) {
			trace("deleteSubset: deleting reference model");
			referencePackage = getPackage(pimPackage, NIEM_REFERENCE_PACKAGE, false);
			if (referencePackage != null) {
				referencePackage.deleteIt();
				referencePackage.unload(true, true);
			}
		}

		// delete subset and extension models
		trace("deleteSubset: deleting subset and extension model");
		subsetPackage = getPackage(pimPackage, NIEM_SUBSET_PACKAGE, false);
		if (subsetPackage != null) {
			subsetPackage.deleteIt();
			subsetPackage.unload(true, true);
		}
		extensionPackage = getPackage(pimPackage, NIEM_EXTENSION_PACKAGE, false);
		if (extensionPackage != null) {
			extensionPackage.deleteIt();
			subsetPackage.unload(true, true);
		}
	}

	/**
	 * exports a NIEM mapping spreadsheet in CSV format
	 * 
	 * roundtripping is supported with importCsv()
	 */
	@SuppressWarnings("unchecked")
	public void exportCsv(String dir, String filename) {

		cacheExternalSchemas();
		
		UmlItem.directory = dir;
		File file = Paths.get(dir, filename).toFile();

		try {
			File parentFile = file.getParentFile();
			if (parentFile != null)
				parentFile.mkdirs();
			FileWriter fw = new FileWriter(file);
			trace("exportCsv: open CSV " + file.toString());
			CSVWriter writer = new CSVWriter(fw);
			
			// Write header
			String[] nextLine = new String[NIEM_STEREOTYPE_MAP.length];
			for (int column = 0; column < NIEM_STEREOTYPE_MAP.length; column++)
				nextLine[column] = NIEM_STEREOTYPE_MAP[column][0];
			writer.writeNext(nextLine);

			// Export NIEM Mappings for Classes
			Iterator<UmlItem> it = (UmlClass.classes.iterator());
			while (it.hasNext()) {
				UmlItem thisClass = (UmlItem) it.next();
				trace("exportCsv: " + thisClass.name());
				if (!thisClass.stereotype().equals(NIEM_STEREOTYPE_TYPE))
					continue;
				nextLine = getItemCsv(thisClass);
				writer.writeNext(nextLine);

				// Export NIEM Mapping for Attributes and Relations
				for (UmlItem item : thisClass.children()) {
					if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
						continue;
					nextLine = getItemCsv(item);
					if (nextLine != null)
						writer.writeNext(nextLine);
				}
			}
			writer.close();
			trace("exportCsv: CSV file created " + file.toString());

		} catch (Exception e) {
			UmlCom.trace("exportCsv: error " + e.toString());
		}
	}

	/** exports a NIEM mapping spreadsheet in HTML format */
	@SuppressWarnings("unchecked")
	public void exportHtml(String dir, String filename) {

		cacheExternalSchemas();
		// cache NIEM namespaces, elements and types
		// cacheModel(referencePackage);
		try {
			// Write rest of header
			File file = Paths.get(dir, filename + HTML_FILE_TYPE).toFile();
			File parentFile = file.getParentFile();
			if (parentFile != null)
				parentFile.mkdirs();
			FileWriter fw = new FileWriter(file);
			fw.write("<html>");
			fw.write("<head><title>" + MAPPING_SPREADSHEET_TITLE
					+ "</title><link rel=\"stylesheet\" href=\"style.css\" type=\"text/css\" /></head>"
					+ "<body><div class = \"title\">" + MAPPING_SPREADSHEET_TITLE + "</div>"
					+ "<table style=\"table-layout: fixed; width: 100%\"><tr bgcolor=\"#f0f0f0\">");
			for (int column = 0; column < NIEM_STEREOTYPE_MAP.length; column++)
				fw.write("<td style=\"word-wrap: break-word\">" + NIEM_STEREOTYPE_MAP[column][0] + "</td>");
			fw.write("</tr>\n");

			// Show NIEM Mappings for Classes
			Iterator<UmlItem> it = (UmlClass.classes.iterator());
			while (it.hasNext()) {
				UmlItem thisClass = (UmlItem) it.next();
				if (thisClass.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
					writeLineHtml(fw, thisClass);

					// Show NIEM Mapping for Attributes and Relations
					for (UmlItem item : thisClass.children())
						if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
							writeLineHtml(fw, item);
				}
			}
			fw.write("</table>\n");
			fw.write("</body></html>");
			fw.close();
		} catch (Exception e) {
			UmlCom.trace("exportHtml: error " + e.toString());
		}
	}

	/** exports a NIEM IEPD including extension and exchange schema */
	@SuppressWarnings("unchecked")
	public void exportIEPD(String xmlDir, String wsdlDir, String jsonDir, String openapiDir) {

		/*
		 * cacheExternalSchemas(); cacheModel(referencePackage);
		 * cacheModel(subsetPackage); cacheModel(extensionPackage);
		 */

		Boolean exportXML = (xmlDir != null);
		Boolean exportJSON = (jsonDir != null);

		// export code lists for extension elements
		CodeListNamespaces = new HashSet<String>();
		exportCodeLists(extensionPackage, xmlDir);
		exportCodeLists(subsetPackage, xmlDir);

		try {
			if (exportXML) {
				// export catalog file
				exportXMLCatalog(xmlDir, CodeListNamespaces);
			}
		} catch (Exception e) {
			UmlCom.trace("exportIEPD: error creating XML catalog file " + e.toString());
		}

		// cache list of ports and message elements
		trace("exportIEPD: cache ports and message elements");
		Map<String, UmlClass> ports = new TreeMap<String, UmlClass>();
//		Map<String, UmlOperation> operations = new TreeMap<String, UmlOperation>();
		Set<String> messages = new TreeSet<String>();
//		Map<String, String> outputMessages = new TreeMap<String, String>();
//		Map<String, ArrayList<String>> inputMessages = new TreeMap<String, ArrayList<String>>();
		Set<String> messageNamespaces = new TreeSet<String>();
		messageNamespaces.add(XSD_PREFIX);
		Iterator<UmlItem> it = (UmlClass.classes.iterator());
		while (it.hasNext()) {
			UmlItem item = (UmlItem) it.next();
			if (!item.stereotype().equals("interface"))
				continue;
			UmlClass port = (UmlClass) item;
			String portName = port.name();
			ports.put(portName, port);
			trace("exportIEPD: port: " + port.name());
			for (UmlItem item2 : port.children()) {
				if (item2.kind() != anItemKind.anOperation)
					continue;
				UmlOperation operation = (UmlOperation) item2;
				String operationName = operation.name();
				trace("exportIEPD: operation: " + operationName);
//				operations.put(operationName, operation);
				UmlClass outputType = null, inputType = null;
				UmlParameter[] params = operation.params();
				if (params != null)
					for (UmlParameter param : params) {
						// ignore RESTful parameters
						if (!param.name.equals("") && !param.name.equals("body"))
							continue;
						trace("exportIEPD: param " + param.name);
						try {
							inputType = param.type.type;
							// String mult = param.multiplicity;
						} catch (Exception e) {
							UmlCom.trace("exportIEPD: error - no input message for " + operationName);
						}
						if (inputType == null || !inputType.stereotype().equals(NIEM_STEREOTYPE_TYPE))
							continue;
						String inputMessage = inputType.propertyValue(NIEM_STEREOTYPE_XPATH);
						if (inputMessage == null || inputMessage.equals(""))
							continue;
						trace("exportIEPD: input Message: " + inputMessage + " from operation " + operationName);
						messageNamespaces.add(getPrefix(inputMessage));
						UmlClassInstance element = getElement(null, getSchemaURI(inputMessage), inputMessage);
						if (element != null)
							element.set_PropertyValue(MESSAGE_ELEMENT_PROPERTY, operationName);
					}
				try {
					outputType = operation.returnType().type;
				} catch (Exception e) {
					UmlCom.trace("exportIEPD: error - no output message for " + operationName + " " + e.toString());
				}
				if (outputType == null || !outputType.stereotype().equals(NIEM_STEREOTYPE_TYPE))
					continue;
				String outputMessage = outputType.propertyValue(NIEM_STEREOTYPE_XPATH);
				if (outputMessage == null || outputMessage.equals(""))
					continue;
				trace("exportIEPD: output Message: " + outputMessage + " from operation " + operationName);
				messageNamespaces.add(getPrefix(outputMessage));
				UmlClassInstance element = getElement(null, getSchemaURI(outputMessage), outputMessage);
				if (element != null)
					element.set_PropertyValue(MESSAGE_ELEMENT_PROPERTY, operationName);
			}
		}

		exportSchemas(subsetPackage, null, Paths.get(jsonDir, NIEM_DIR).toString());
		exportSchemas(extensionPackage, xmlDir, jsonDir);

		if (exportXML) try {
			exportMPDCatalog(xmlDir, CodeListNamespaces, messages);
			exportWSDL(xmlDir, wsdlDir, ports, messageNamespaces);
		} catch (Exception e) {
			UmlCom.trace("exportIEPD: error exporting MPD catalog or WSDL " + e.toString());
		}

		if (exportJSON) try {
				exportOpenAPI(jsonDir, openapiDir, ports, messageNamespaces);
		} catch (Exception e) {
			UmlCom.trace("exportIEPD: error exporting OpenAPI files " + e.toString());
		}
	}

	/**
	 * exports a NIEM wantlist for import into Subset Schema Generator Tool (SSGT)
	 */
	public void exportWantlist(String dir, String filename) {

		// createSubset();
		cacheExternalSchemas();

		UmlItem.directory = dir;
		try {
			// Export schema
			trace("exportWantlist: create header");
			File file = Paths.get(dir, filename).toFile();
			File parentFile = file.getParentFile();
			if (parentFile != null)
				parentFile.mkdirs();
			FileWriter fw = new FileWriter(file);
			fw.write(XML_HEADER);
			fw.write(XML_ATTRIBUTION);
			fw.write("<w:WantList w:release=\"" + getNiemVersion()
			+ "\" w:product=\"NIEM\" w:nillableDefault=\"true\" ");
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					String prefix = item.propertyValue(PREFIX_PROPERTY);
					String schemaURI = Prefixes.get(prefix);
					if (!prefix.equals(LOCAL_PREFIX) && (!prefix.equals(XSD_PREFIX)))
						writeXmlNs(fw, prefix, schemaURI);
				}
			writeXmlNs(fw, "w", WANTLIST_URI);
			fw.write(">");

			// export elements
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					String prefix = classView.propertyValue(PREFIX_PROPERTY);
					String anyElement = getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME);
					if (prefix.equals(LOCAL_PREFIX) || prefix.equals(XSD_PREFIX) || prefix.equals(STRUCTURES_PREFIX))
						continue;
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClassInstance) {
							UmlClassInstance element = (UmlClassInstance) item2;
							String elementName = getPrefixedName(element);
							if (elementName.equals(anyElement))
								continue;
							if (isAttribute(element)) {
								elementName = getPrefixedAttributeName(getPrefix(elementName), elementName);
								trace("exportWantlist: export attribute " + elementName);
								//fw.write("<w:Attribute w:name=\"" + elementName + "\"/>\n");
								continue;
							}
							trace("exportWantlist: export element " + elementName);
							String isNillable = element.propertyValue(NILLABLE_PROPERTY);
							if (isNillable == null)
								isNillable = "false";
							fw.write("<w:Element w:name=\"" + elementName + "\" w:isReference=\"false\" w:nillable=\""
									+ isNillable + "\"/>\n");
						}
				}

			// export types
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					String prefix = classView.propertyValue(PREFIX_PROPERTY);
					if (prefix.equals(LOCAL_PREFIX) || prefix.equals(XSD_PREFIX) || prefix.equals(STRUCTURES_PREFIX))
						continue;
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClass) {
							UmlClass type = (UmlClass) item2;
							String typeName = getPrefixedName(type);
							trace("exportWantlist: export type " + typeName);

							// do not export structures:AugmentationType
							// if (type == subsetAugmentationType)
							// continue;

							// attribute groups are not supported in wantlists
							if (isAttribute(type))
								continue;

							fw.write("<w:Type w:name=\"" + typeName + "\" w:isRequested=\"true\">\n");

							for (UmlItem item3 : type.children())
								if (item3.kind() == anItemKind.anAttribute) {
									UmlAttribute attribute = (UmlAttribute) item3;
									String elementName = attribute.name();
									// trace("exportWantlist: adding element " + elementName);
									String multiplicity = attribute.multiplicity();
									String minOccurs = getMinOccurs(multiplicity);
									String maxOccurs = getMaxOccurs(multiplicity);
									try {
										if (Integer.parseInt(minOccurs) < 0)
											throw new NumberFormatException();
										if (!maxOccurs.equals("unbounded") && (Integer.parseInt(maxOccurs) < 1))
											throw new NumberFormatException();
									} catch (NumberFormatException e) {
										UmlCom.trace("exportWantlist: error - invalid multiplicity " + multiplicity
												+ " for " + typeName + "/" + elementName);
									}

									if (isAttribute(attribute)) {
										elementName = getPrefixedName(getPrefix(elementName),
												filterAttributePrefix(getName(elementName)));
										trace("exportWantlist: export attribute " + elementName);
										//fw.write("<w:AttributeInType w:name=\"" + elementName + "\" w:minOccurs=\""
										//		+ minOccurs + "\" w:maxOccurs=\"" + maxOccurs + "\"/>\n");
										continue;
									}
									// trace("exportWantlist: export element " + elementName + " in type " +
									// typeName);
									fw.write("\t<w:ElementInType w:name=\"" + elementName
											+ "\" w:isReference=\"false\" w:minOccurs=\"" + minOccurs
											+ "\" w:maxOccurs=\"" + maxOccurs + "\"/>\n");
								}

							// export enumerations
/*							String codeList = type.propertyValue(CODELIST_PROPERTY);
							if (codeList != null) {
								// trace("exportWantlist: exporting enumerations for " + getPrefixedName(type));
								if (codeList.trim().contains(CODELIST_DELIMITER)) {
									String[] codes = codeList.split(CODELIST_DELIMITER);
									for (String code : codes) {
										String[] pairs = code.split(CODELIST_DEFINITION_DELIMITER);
										String value = pairs[0].trim();
										if (!value.equals(""))
											fw.write("<w:Facet w:facet=\"enumeration\" w:value=\"" + filterQuotes(value)
											+ "\"/>");
									}
								}
							}*/
							fw.write("</w:Type>");
						}
				}

			fw.write("</w:WantList>");
			fw.close();

		} catch (IOException e) {
			UmlCom.trace("exportWantlist: IO exception: " + e.toString());
		}
	}

	/** import NIEM mapping spreadsheet in CSV format */
	@SuppressWarnings("unchecked")
	public void importCsv(String filename) {

		cacheExternalSchemas();
		// cache UML classes
		Map<String, UmlClass> UMLClasses = new HashMap<String, UmlClass>();
		Map<String, UmlClassInstance> UMLInstances = new HashMap<String, UmlClassInstance>();
		Iterator<UmlItem> it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				if (item.kind() == anItemKind.aClass) {
					UmlClass c = (UmlClass) item;
					if (!UMLClasses.containsKey(c.name()))
						UMLClasses.put(c.name(), c);
				} else if (item.kind() == anItemKind.aClassInstance) {
					UmlClassInstance ci = (UmlClassInstance) item;
					if (!UMLInstances.containsKey(ci.name()))
						UMLInstances.put(ci.name(), ci);
				}
		}
		try {

			CSVReader reader = new CSVReader(new FileReader(filename));
			String[] nextLine;

			// read header
			reader.readNext();

			// read mappings
			while ((nextLine = reader.readNext()) != null) {
				String className = nextLine[0].trim();
				String attributeName = nextLine[1].trim();

				if (!className.equals("")) {
					UmlClass type = UMLClasses.get(className);
					if (type != null) {
						if (attributeName.equals("")) {
							// import NIEM mapping to class
							trace("importCsv: importing NIEM mapping for " + className);
							for (int column = 4; column < NIEM_STEREOTYPE_MAP.length
									&& column < nextLine.length; column++)
								type.set_PropertyValue(getNiemProperty(column), nextLine[column]);
						} else {
							// import NIEM Mapping to attribute
							for (UmlItem item : type.children())
								if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)
										&& (item.name().equals(attributeName)))
									for (int column = 4; column < NIEM_STEREOTYPE_MAP.length
											&& column < nextLine.length; column++)
										item.set_PropertyValue(getNiemProperty(column), nextLine[column]);
						}
					}
				} else if (!attributeName.equals("")) {
					UmlClassInstance element = UMLInstances.get(attributeName);
					if (element != null) {
						// import NIEM mapping to class
						trace("importCsv: importing NIEM mapping for " + attributeName);
						for (int column = 4; column < NIEM_STEREOTYPE_MAP.length && column < nextLine.length; column++)
							element.set_PropertyValue(getNiemProperty(column), nextLine[column]);
					}
				}
			}
			reader.close();
		} catch (FileNotFoundException e) {
			UmlCom.trace("importCsv: error - file not found" + e.toString());
		} catch (IOException e) {
			UmlCom.trace("importCsv: error - IO exception" + e.toString());
		}
	}

	/**
	 * import NIEM reference model into HashMaps to support validation of NIEM
	 * elements and types
	 */
	public void importSchemaDir(String dir, Boolean includeEnums) throws IOException {

		/*
		 * // cache reference model cacheModel(referencePackage);
		 * cacheExternalSchemas();
		 */

		// Configure DOM
		Path path = FileSystems.getDefault().getPath(dir);
		String importPath = path.toString();

		int passes = (includeEnums) ? 4 : 3;

		// Walk directory to import in passes (0: types, 1: elements, 2:
		// elements in types, 3: enumerations
		for (importPass = 0; importPass < passes; importPass++) {
			switch (NiemTools.importPass) {
			case 0:
				UmlCom.trace("\nImporting types");
				break;
			case 1:
				UmlCom.trace("\nImporting elements");
				break;
			case 2:
				UmlCom.trace("\nImporting elements and attributes in types");
				break;
			}
			Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
				@Override
				public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
					// Configure DOM
					DocumentBuilder db = null;
					DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
					docBuilderFactory.setNamespaceAware(true);
					try {
						db = docBuilderFactory.newDocumentBuilder();
					} catch (ParserConfigurationException e) {
						UmlCom.trace("importSchemaDir: error configuring parser " + e.toString());
					}

					String filename = file.toString();
					String filepath1 = filename.replaceFirst(java.util.regex.Matcher.quoteReplacement(importPath), "");
					String filepath = filepath1.replaceAll(java.util.regex.Matcher.quoteReplacement("\\"), "/");
					if (filename.endsWith(XSD_FILE_TYPE)) {
						UmlCom.trace("Importing " + filepath);
						switch (NiemTools.importPass) {
						case 0:
							Namespace ns = importTypes(db, filename);
							ns.referenceClassView.set_PropertyValue(FILE_PATH_PROPERTY, NIEM_DIR + filepath);
							break;
						case 1:
							importElements(db, filename);
							break;
						case 2:
							importElementsInTypes(db, filename);
							break;
						}
					}
					return FileVisitResult.CONTINUE;
				}
			});
		}

		// Sorting
		UmlCom.trace("Sorting namespaces");
		referencePackage.sort();

		UmlCom.trace("Namespaces: " + Namespaces.size());
		UmlCom.trace("Types: " + NiemTypes.size());
		UmlCom.trace("Elements: " + NiemElements.size());
	}

	/** verifies NIEM reference model exists */
	public boolean verifyNIEM() {
		trace("verifyNIEM: verifying NIEM folders");
		UmlPackage pimPackage = getPackage(UmlBasePackage.getProject(), NIEM_PACKAGE, false);
		if (pimPackage != null) {
			referencePackage = getPackage(pimPackage, NIEM_REFERENCE_PACKAGE, false);
			if (referencePackage != null)
				return true;
		}

		UmlCom.trace("NIEM reference model does not exist.  Import NIEM reference schemas first.");
		return false;
	}
}
