
/*
 *   NIEMtools - This is a plug_out that extends the BOUML UML tool with support for the National Information Exchange Model (NIEM) defined at http://niem.gov.
 *   Specifically, it enables a UML Common Information Model (CIM), an abstract class mode, to be mapped into a
 *   UML Platform Specific Model (PSM), the NIEM reference/subset/extension model, and a UML Platform Specific Model (NIEM), NIEM XML Schema.
 *
 *   NOTE: This plug_out requires that the BOUML project include a simple NIEM profile that provides the stereotypes required for mapping.
 *   
 *   Copyright (C) 2017 James E. Cabral Jr., MTG Management Consultants LLC, jcabral@mtgmc.com, http://github.com/cabralje
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
//import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.XMLConstants;
// DOM
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathExpressionException;
import javax.xml.xpath.XPathFactory;

// DOM
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

// OpenCSV library
import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

class NiemTools {

	// Debugging options
	//private static Boolean _TRACE = true;
	private static final Boolean _TRACE = false;
	// private static Boolean _IMPORT_CODE_DESCRIPTIONS = true;
	private static final Boolean _IMPORT_CODE_DESCRIPTIONS = false;

	// JSON
	private static final String JSON_SCHEMA_URI = "http://json-schema.org/draft-04/schema#";
	private static final String JSON_SCHEMA_FILE_TYPE = ".schema.json";
	// XML
	private static final String XML_URI = XMLConstants.XML_NS_URI;
	private static final String XML_PREFIX = XMLConstants.XML_NS_PREFIX;
	private static final String XSD_PREFIX = "xs";
	private static final String XSD_URI = XMLConstants.W3C_XML_SCHEMA_NS_URI;
	private static final String XSD_FILE_TYPE = ".xsd";
	private static final String XML_FILE_TYPE = ".xml";
	private static final String HTML_FILE_TYPE = ".html";
	private static final String XSI_PREFIX = "xsi";
	private static final String XSI_URI = XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;
	private static final String NAMESPACE_DELIMITER = ":";
	private static final String NAMESPACE_ATTRIBUTE = XMLConstants.XMLNS_ATTRIBUTE;
	private static final String XML_HEADER = "<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n";
	private static final String[] XML_TYPE_NAMES = { "anyURI", "base64Binary", "blockSet", "boolean", "byte", "date",
			"dateTime", "DateTimeStamp", "dayTimeDuration", "decimal", "derivationControl", "derivationSet", "double",
			"duration", "ENTITIES", "ENTITY", "float", "formChoice", "fullDerivationSet", "gDay", "gMonth", "gMonthDay",
			"gYear", "gYearMonth", "hexBinary", "ID", "IDREF", "IDREFS", "int", "integer", "language", "long", "Name",
			"namespaceList", "NCName", "negativeInteger", "NMTOKEN", "NMTOKENS", "nonNegativeInteger",
			"nonPositiveInteger", "normalizedString", "NOTATION", "positiveInteger", "public", "QName", "short",
			"simpleDerivationSet", "string", "time", "token", "unsignedByte", "unsignedInt", "unsignedLong",
			"unsignedShort", "yearMonthDuration" };
	private static final String XML_ATTRIBUTION = "<!-- Generated by BOUML niemtools plug_out (https://github.com/cabralje/niem-tools) -->\n";
	// XML Catalog
	private static final String XML_CATALOG_URI = "urn:oasis:names:tc:entity:xmlns:xml:catalog";
	private static final String XML_CATALOG_HEADER = "<!DOCTYPE catalog PUBLIC \"-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN\" \"http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd\">\n";
	// Web services
	private static final String SOAP_PREFIX = "soap";
	private static final String SOAP_URI = "http://schemas.xmlsoap.org/wsdl/soap/";
	private static final String SOAP_HTTP_BINDING_URI = "http://schemas.xmlsoap.org/soap/http";
	private static final String WSDL_SCHEMA_PREFIX = "wsdl";
	private static final String WSDL_SCHEMA_URI = "http://schemas.xmlsoap.org/wsdl/";
	private static final String WSDL_FILE_TYPE = ".wsdl";
	private static final String WSP_PREFIX = "wsp";
	private static final String WSP_URI = "http://schemas.xmlsoap.org/ws/2004/09/policy";
	private static final String WSP_POLICY = "MyPolicy";
	private static final String WSU_PREFIX = "wsu";
	private static final String WSU_URI = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd";
	private static final String WSRMP_PREFIX = "wsrmp";
	private static final String WSRMP_URI = "http://docs.oasis-open.org/ws-rx/wsrmp/200702";
	// Genericode
	private static final String GC_PREFIX = "gc";
	private static final String GC_URI = "http://docs.oasis-open.org/codelist/ns/genericode/1.0/";
	private static final String GC_LOCATION = "https://docs.oasis-open.org/codelist/cs-genericode-1.0/xsd/genericode.xsd";
	private static final String GC_FILE_TYPE = ".gc";
	private static final String GC_APPINFO_PREFIX = "gca";
	private static final String GC_APPINFO_URI = "http://example.org/namespace/genericode-appinfo";
	// NIEM code lists
	private static final String CODELIST_URI = "http://reference.niem.gov/niem/specification/code-lists/1.0/";
	private static final String CODELIST_APPINFO_PREFIX = "clsa";
	private static final String CODELIST_APPINFO_URI = "http://reference.niem.gov/niem/specification/code-lists/1.0/code-lists-schema-appinfo/";
	private static final String CODELIST_CODE = "code";
	private static final String CODELIST_DEFINITION = "definition";
	// NIEM naming and design rules
	private static final String NC_PREFIX = "nc";
	private static final String NDR_URI = "http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/";
	private static final String AUGMENTATION_TYPE_NAME = "AugmentationType";
	private static final String AUGMENTATION_POINT_NAME = "AugmentationPoint";
	private static final String SIMPLE_OBJECT_ATTRIBUTE_GROUP = "@SimpleObjectAttributeGroup";
	private static final String OBJECT_TYPE_NAME = "ObjectType";
	private static final String STRUCTURES_PREFIX = "structures";
	private static final String NIEM_VERSION_DEFAULT = "4.0";
	// NIEM conformance targets
	private static final String CT_PREFIX = "ct";
	private static final String CT_URI = "http://release.niem.gov/niem/conformanceTargets/3.0/";
	// NIEM terms
	private static final String TERM_PREFIX = "term";
	private static final String TERM_URI = "http://release.niem.gov/niem/localTerminology/3.0/";
	// NIEM model package descriptions
	private static final String MPD_URI = "http://reference.niem.gov/niem/specification/model-package-description/3.0/";
	private static final String MPD_CATALOG_URI = "http://reference.niem.gov/niem/resource/mpd/catalog/3.0/";
	private static final String MPD_CATALOG_LOCATION = "https://tools.niem.gov/IEPD/mpd-catalog-3.0.xsd";
	// private static final String MPD_CATALOG_LOCATION =
	// "../../mpd-toolkit-3.0/mpd-catalog-3.0.xsd";
	private static final String MPD_NC_URI = "http://release.niem.gov/niem/niem-core/3.0/";
	private static final String MPD_STRUCTURES_URI = "http://release.niem.gov/niem/structures/3.0/";
	// NIEM subset schema generation tool (SSGT)
	private static final String WANTLIST_URI = "http://niem.gov/niem/wantlist/2.2";
	// Niem-tools UML modeling
	private static final String NIEM_PACKAGE = "NIEM";
	private static final String NIEM_REFERENCE_PACKAGE = "NIEMReference";
	private static final String NIEM_SUBSET_PACKAGE = "NIEMSubset";
	private static final String NIEM_EXTENSION_PACKAGE = "NIEMExtension";
	private static final String MAPPING_SPREADSHEET_TITLE = "NIEM Mapping";
	private static final String ATTRIBUTE_PREFIX = "@";
	private static final String REFERENCE_PREFIX = "^";
	private static final String HASH_DELIMITER = ",";
	private static final String CODELIST_DELIMITER = ";";
	private static final String CODELIST_DEFINITION_DELIMITER = "=";
	private static final String NOTES_PROPERTY = "Notes";
	private static final String NILLABLE_PROPERTY = "isNillable";
	private static final String URI_PROPERTY = "URI";
	private static final String PREFIX_PROPERTY = "prefix";
	private static final String SUBSTITUTION_PROPERTY = "substitutesFor";
	private static final String CODELIST_PROPERTY = "codeList";
	private static final String FILE_PATH_PROPERTY = "path";
	private static final String WSDL_SUFFIX = "WSDL";
	private static final String WSDL_XSD_SUFFIX = "MessageWrappers";
	private static final String LOCAL_PREFIX = "local";
	private static final String LOCAL_URI = "local";
	private static final String ABSTRACT_TYPE_NAME = "abstract";
	private static final String ANY_ELEMENT_NAME = "any";
	// Niem-tools web services
	private static final String WSDL_PREFIX = "tns";
	private static final String WSDL_XSD_PREFIX = "wrapper";
	private static final String RESPONSE_MESSAGE_SUFFIX = "Response";
	private static final String REQUEST_MESSAGE_SUFFIX = "Request";
	// IEPD Properties
	private static final String IEPD_EXTERNAL_SCHEMAS_PROPERTY = "externalSchemas";
	private static final String IEPD_CHANGE_LOG_FILE_PROPERTY = "IEPDChangeLogFile";
	private static final String IEPD_READ_ME_FILE_PROPERTY = "IEPDReadMeFile";
	private static final String IEPD_CONTACT_PROPERTY = "IEPDContact";
	private static final String IEPD_ORGANIZATION_PROPERTY = "IEPDOrganization";
	private static final String IEPD_STATUS_PROPERTY = "IEPDStatus";
	private static final String IEPD_VERSION_PROPERTY = "IEPDVersion";
	private static final String IEPD_NAME_PROPERTY = "IEPDName";
	private static final String IEPD_URI_PROPERTY = "IEPDURI";
	private static final String IEPD_CHANGE_LOG_FILE_DEFAULT = "changelog.txt";
	private static final String IEPD_READ_ME_FILE_DEFAULT = "readme.txt";
	private static final String IEPD_CONTACT_DEFAULT = "Contact";
	private static final String IEPD_ORGANIZATION_DEFAULT = "Organization";
	private static final String IEPD_STATUS_DEFAULT = "Draft";
	private static final String IEPD_VERSION_DEFAULT = "1.0";
	private static final String IEPD_NAME_DEFAULT = "IEPD";
	private static final String IEPD_URI_DEFAULT = "http://local";
	private static final String IEPD_EXTERNAL_SCHEMAS_DEFAULT = "cac=urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2=http://docs.oasis-open.org/ubl/os-UBL-2.1/xsd/common/UBL-CommonAggregateComponents-2.1.xsd,"
			+ "cbc=urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2=http://docs.oasis-open.org/ubl/os-UBL-2.1/xsd/common/UBL-CommonBasicComponents-2.1.xsd,"
			+ "ds=http://www.w3.org/2000/09/xmldsig#=https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd";
	// File locations
	private static final String NIEM_DIR = "niem";
	private static final String WANTLIST_FILE = "wantlist.xml";
	private static final String XML_CATALOG_FILE = "xml-catalog.xml";
	private static final String MPD_CATALOG_FILE = "mpd-catalog.xml";
	private static final String CONFORMANCE_ASSERTION_FILE = "conformance-assertion.pdf";
	// Niem stereotype configuration
	public static final String NIEM_STEREOTYPE_TYPE = "niem-profile:niem";
	private static final String STEREOTYPE_DELIMITER = ":";
	// private static final String NIEM_STEREOTYPE_LABEL = "niem:niem";
	// NIEM mapping spreadsheet column headings, NIEM profile profile stereotype
	private static final String[][] NIEM_STEREOTYPE_MAP = { { "Model Class", "", }, // 0
			{ "Model Attribute", "", }, // 1
			{ "Model Multiplicity", "", }, // 2
			{ "Model Definition", "", }, // 3
			{ "NIEM XPath", "XPath" }, // 4
			{ "NIEM Type", "Type" }, // 5
			{ "NIEM Property, " + REFERENCE_PREFIX + "Reference, (Representation)", "Property" }, // 6
			{ "NIEM Base Type", "BaseType" }, // 7
			{ "NIEM Multiplicity", "Multiplicity" }, // 8
			{ "Old XPath", "OldXPath" }, // 9
			{ "Old Multiplicity", "OldMultiplicity" }, // 10
			{ "NIEM Mapping Notes", "Notes" }, // 11
			{ "Code List Code=Definition;", "CodeList" } }; // 12

	// private static final String NIEM_STEREOTYPE_CLASS = NIEM_STEREOTYPE_TYPE +
	// STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[0][1];
	// private static final String NIEM_STEREOTYPE_ATTRIBUTE = NIEM_STEREOTYPE_TYPE
	// + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[1][1];
	// private static final String NIEM_STEREOTYPE_MODEL_MULTIPLICITY =
	// NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[2][1];
	// private static final String NIEM_STEREOTYPE_DEFINITION = NIEM_STEREOTYPE_TYPE
	// + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[3][1];
	private static final String NIEM_STEREOTYPE_XPATH = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[4][1];
	private static final String NIEM_STEREOTYPE_TYPENAME = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[5][1];
	private static final String NIEM_STEREOTYPE_PROPERTY = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[6][1];
	private static final String NIEM_STEREOTYPE_BASE_TYPE = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[7][1];
	private static final String NIEM_STEREOTYPE_MULTIPLICITY = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[8][1];
	// private static final String NIEM_STEREOTYPE_OLD_XPATH = NIEM_STEREOTYPE_TYPE
	// + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[9][1];
	// private static final String NIEM_STEREOTYPE_OLD_MULTIPLICITY =
	// NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[10][1];
	private static final String NIEM_STEREOTYPE_NOTES = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[11][1];
	private static final String NIEM_STEREOTYPE_CODE_LIST = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[12][1];

	private static Set<String> externalPrefixes = new HashSet<String>();
	private static Map<String, String> externalSchemaURL = new HashMap<String, String>();

	private static UmlClass referenceAbstractType = null;
	private static UmlClass subsetAbstractType = null;
	private static UmlClass subsetAugmentationType = null;
	public static int importPass;
	public static String importPath;
	private static Map<String, UmlItem> NiemElements = new HashMap<String, UmlItem>();
	private static Map<String, List<UmlClassInstance>> NiemElementsInType = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, Namespace> Namespaces = new HashMap<String, Namespace>();
	private static Map<String, String> Prefixes = new HashMap<String, String>();
	private static Map<String, UmlClass> NiemTypes = new HashMap<String, UmlClass>();
	private static Map<String, List<UmlClassInstance>> Substitutions = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, UmlItem> SubsetElements = new HashMap<String, UmlItem>();
	private static Map<String, List<UmlClassInstance>> SubsetElementsInType = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, UmlClass> SubsetTypes = new HashMap<String, UmlClass>();

	private static Map<String, UmlItem> ExtensionElements = new HashMap<String, UmlItem>();
	private static Map<String, List<UmlClassInstance>> ExtensionElementsInType = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, UmlClass> ExtensionTypes = new HashMap<String, UmlClass>();

	private static UmlPackage subsetPackage = null, extensionPackage = null, referencePackage = null;
	private static XPath xPath = XPathFactory.newInstance().newXPath();

	/** returns an element added to reference or extension model */
	private static UmlClassInstance addElement(UmlPackage modelPackage, String elementSchemaURI, String elementName,
			String baseTypeSchemaURI, String baseTypeName, String description, String notes) {

		if (elementName.equals("") || elementName.equals("??"))
			return null;

		// get element if it exists
		UmlClassInstance element = getElement(modelPackage, elementSchemaURI, elementName);

		// if not, create element
		if (element == null) {

			// find base type - default to abstract type if type name not defined
			UmlClass baseType = null;
			if (baseTypeName != null)
				if (modelPackage == referencePackage)
					baseType = getType(referencePackage, baseTypeSchemaURI, baseTypeName);
				else
					baseType = getType(null, baseTypeSchemaURI, baseTypeName);

			if (baseType == null) {
				if (baseTypeName != null)
					UmlCom.trace("addElement: error - base type " + baseTypeName + " not in model with URI "
							+ baseTypeSchemaURI);
				baseType = (modelPackage == referencePackage) ? referenceAbstractType : subsetAbstractType;
			}
			// create element
			UmlClassView nsClassView = getNamespace(modelPackage, getPrefix(elementName), elementSchemaURI);
			if (nsClassView == null) {
				UmlCom.trace("addElement: error - no prefix or schema for element " + elementName);
				return null;
			}
			try {
				element = UmlClassInstance.create(nsClassView, filterUMLElement(getName(elementName)), baseType);
			} catch (RuntimeException e) {
				UmlCom.trace("addElement: error adding element " + elementName + " of type " + baseType.name());
				return null;
			}
			element.set_Description(description);
			String uri = getURI(elementSchemaURI, elementName);
			setURI(element, uri);
			if (modelPackage == referencePackage)
				NiemElements.put(uri, element);
			else if (modelPackage == subsetPackage)
				SubsetElements.put(uri, element);
			else if (modelPackage == extensionPackage)
				ExtensionElements.put(uri, element);
			trace("addElement: added " + elementName);
		}

		// add notes
		setNotes(element, notes);
		return element;
	}

	/** returns an element in type added to reference model or extension */
	private static UmlAttribute addElementInType(UmlClass type, UmlClassInstance element, String multiplicity) {

		// return null if element or type do not exist
		if (type == null || element == null)
			return null;

		// get element in type if it exists
		// trace("addElementInTypes: inserting element " + element.name() + " to type "
		// + type.name());
		String elementInTypeName = getPrefixedName(element);
		String typeName = getPrefixedName(type);
		UmlAttribute elementInType = getElementInType(type, elementInTypeName, multiplicity);

		// create element in type
		if (elementInType == null)
			try {
				elementInType = UmlAttribute.create(type, elementInTypeName);
			} catch (RuntimeException re) {
				// trace("addElementInType: error - element " + elementInTypeName + " already
				// exists in type " + type.name());
				return null;
			}

		// copy element properties
		setURI(elementInType, getURI(element));
		if (element.description() != null)
			elementInType.set_Description(element.description());
		if (multiplicity != null)
			elementInType.set_Multiplicity(multiplicity);

		// relate element in type to element
		relateElementInType(elementInType, element);

		// insert element in type list
		List<UmlClassInstance> elementInTypeList = getElementsInType((UmlPackage) type.parent().parent(), getURI(type));
		elementInTypeList.add(element);
		trace("addElementInTypes: inserted " + elementInTypeName + " to " + typeName);
		return elementInType;
	}

	/** returns a type added to the reference or extension models */
	private static UmlClass addType(UmlPackage modelPackage, String typeSchemaURI, String typeName, String description,
			String notes) {
		// trace("addType: adding " + typeName + " to schema " + typeSchemaURI);
		UmlClass type = getType(modelPackage, typeSchemaURI, typeName);
		if (type == null) {
			// create type
			UmlClassView nsClassView = getNamespace(modelPackage, getPrefix(typeName), typeSchemaURI);
			if (nsClassView == null) {
				UmlCom.trace("addType: error - no prefix or schema for type " + typeName);
				return null;
			}
			try {
				type = UmlClass.create(nsClassView, filterUMLType(getName(typeName)));
			} catch (RuntimeException re) {
				UmlCom.trace("addType: error adding type " + typeName);
				return null;
			}
			String uri = getURI(typeSchemaURI, typeName);
			setURI(type, uri);
			if (modelPackage == referencePackage)
				NiemTypes.put(uri, type);
			else if (modelPackage == subsetPackage)
				SubsetTypes.put(uri, type);
			else if (modelPackage == extensionPackage)
				ExtensionTypes.put(uri, type);
			trace("addType: added " + typeName);
		}
		setDescription(type, description);
		setNotes(type, notes);
		return type;
	}

	/** caches namespaces and prefixes for external schemas */
	private static void cacheExternalSchemas() {
		String externalSchemas = getProperty(IEPD_EXTERNAL_SCHEMAS_PROPERTY);
		String[] external = externalSchemas.split(",");
		for (int schemaIndex = 0; schemaIndex < external.length; schemaIndex++) {
			String[] part = external[schemaIndex].split("=");
			if (part.length > 2) {
				String prefix = part[0].trim();
				String schemaURI = part[1].trim();
				String schemaLocation = part[2].trim();
				externalPrefixes.add(prefix);
				Prefixes.put(prefix, schemaURI);
				externalSchemaURL.put(schemaURI, schemaLocation);
			}
		}
		// trace("cacheExternalSchemas: external schemas cached");
	}

	/**
	 * caches elements, types and elements in types of NIEM reference, subset or
	 * extension model
	 */
	private static void cacheModel(UmlPackage modelPackage) {
		if (modelPackage == null)
			return;

		// Cache namespaces, types and elements
		String schemaURI;
		Map<String, UmlItem> Elements = null;
		Map<String, List<UmlClassInstance>> ElementsInType = null;
		Map<String, UmlClass> Types = null;

		if (modelPackage == referencePackage) {
			Elements = NiemElements;
			ElementsInType = NiemElementsInType;
			Types = NiemTypes;
		} else if (modelPackage == subsetPackage) {
			Elements = SubsetElements;
			ElementsInType = SubsetElementsInType;
			Types = SubsetTypes;
		} else if (modelPackage == extensionPackage) {
			Elements = ExtensionElements;
			ElementsInType = ExtensionElementsInType;
			Types = ExtensionTypes;
		} else
			return;

		// trace("cacheModel: caching namespaces, types and elements");
		for (UmlItem classView : modelPackage.children()) {
			if (classView.kind() != anItemKind.aClassView)
				continue;

			schemaURI = getURI(classView);
			String prefix = classView.propertyValue(PREFIX_PROPERTY);
			if (!Prefixes.containsKey(prefix)) {
				// trace("cacheModel: Adding prefix " + prefix);
				Prefixes.put(prefix, schemaURI);
			}
			Namespace ns = Namespaces.get(schemaURI);
			if ((ns == null) && (schemaURI != null)) {
				// create namespace
				ns = new Namespace(schemaURI);
				Namespaces.put(schemaURI, ns);
			}
			if (modelPackage == referencePackage)
				ns.referenceClassView = (UmlClassView) classView;
			else
				ns.nsClassView = (UmlClassView) classView;

			if (modelPackage == referencePackage || modelPackage == extensionPackage)
				ns.filepath = classView.propertyValue(FILE_PATH_PROPERTY);

			for (UmlItem type : classView.children()) {
				String typeURI = getURI(type);
				if (typeURI != null)
					switch (type.kind().value()) {
					case anItemKind._aClass:
						Types.put(typeURI, (UmlClass) type);
						break;
					case anItemKind._aClassInstance:
						UmlClassInstance element = (UmlClassInstance) type;
						Elements.put(typeURI, element);
						String headElement = element.propertyValue(SUBSTITUTION_PROPERTY);
						if (headElement != null) {
							List<UmlClassInstance> enlist = (List<UmlClassInstance>) (Substitutions.get(headElement));
							if (enlist == null) {
								enlist = new ArrayList<UmlClassInstance>();
								Substitutions.put(headElement, enlist);
							}
							if (!enlist.contains(element))
								enlist.add(element);
						}
						break;
					default:
						break;
					}
			}
		}

		// Cache elements in types
		// trace("cacheModel: caching elements in types");
		for (UmlClass type : Types.values()) {
			String typeURI = getURI(type);
			List<UmlClassInstance> list = (List<UmlClassInstance>) (ElementsInType.get(typeURI));
			if (list == null) {
				list = new ArrayList<UmlClassInstance>();
				ElementsInType.put(typeURI, list);
			}
			for (UmlItem attribute : type.children())
				if (attribute.kind() == anItemKind.anAttribute) {
					// trace("cacheModel: caching " + getURI(attribute));
					UmlClassInstance element = (UmlClassInstance) Elements.get(getURI(attribute));
					list.add(element);
				}
		}

		// trace("cacheModel: store caches and add simple and abstract types");
		if (modelPackage == referencePackage) {
			NiemElements = Elements;
			NiemElementsInType = ElementsInType;
			NiemTypes = Types;

			// add local namespace and abstract type
			getNamespace(referencePackage, LOCAL_PREFIX, LOCAL_URI);
			referenceAbstractType = addType(referencePackage, LOCAL_URI,
					getPrefixedName(LOCAL_PREFIX, ABSTRACT_TYPE_NAME), null, null);

			// add XML namespace, simple types and any element
			getNamespace(referencePackage, XML_PREFIX, XML_URI);
			for (String typeName : XML_TYPE_NAMES)
				addType(referencePackage, XSD_URI, getPrefixedName(XSD_PREFIX, typeName), null, null);
			addElement(referencePackage, XSD_URI, getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME), null, null, null,
					null);
		} else if (modelPackage == subsetPackage) {
			SubsetElements = Elements;
			SubsetElementsInType = ElementsInType;
			SubsetTypes = Types;
			subsetAbstractType = copyType(getPrefixedName(LOCAL_PREFIX, ABSTRACT_TYPE_NAME));
			subsetAugmentationType = copyType(getPrefixedName(STRUCTURES_PREFIX, AUGMENTATION_TYPE_NAME));
			copyElement(getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME));
		} else if (modelPackage == extensionPackage) {
			ExtensionElements = Elements;
			ExtensionElementsInType = ElementsInType;
			ExtensionTypes = Types;
		}
	}

	/** returns an element copied from reference model to subset */
	private static UmlClassInstance copyElement(String elementName) {

		// return subset element if it exists
		String schemaURI = getSchemaURI(elementName);
		UmlClassInstance element = getElement(subsetPackage, schemaURI, elementName);
		if (element != null)
			return element;

		// if element doesn't exist in reference model, return error
		UmlClassInstance sourceElement = getElement(referencePackage, schemaURI, elementName);
		if (sourceElement == null) {
			UmlCom.trace("copyElement: error - element " + elementName + " not in reference model");
			return null;
		}

		// copy base type if not already in subset
		UmlClass sourceBaseType = sourceElement.type();
		String baseTypeName = getPrefixedName(sourceBaseType);
		UmlClass baseType = getType(subsetPackage, getSchemaURI(baseTypeName), baseTypeName);
		if (baseType == null)
			baseType = copyType(baseTypeName);

		// if namespace doesn't exist, create it
		UmlClassView nsClassView = getNamespace(subsetPackage, getPrefix(elementName), schemaURI);
		if (nsClassView == null) {
			UmlCom.trace("addElement: error - no prefix or schema for element " + elementName);
			return null;
		}

		// create element
		try {
			element = UmlClassInstance.create(nsClassView, filterUMLElement(getName(elementName)), baseType);
		} catch (RuntimeException e) {
			UmlCom.trace("copyElement: error copying element " + elementName + " to subset");
			return null;
		}
		element.set_Description(sourceElement.description());
		String uri = getURI(schemaURI, elementName);
		setURI(element, uri);
		SubsetElements.put(uri, element);
		trace("copyElement: element " + elementName + " copied to subset");
		return element;
	}

	/** returns an element in type copied from reference model to subset */
	private static UmlAttribute copyElementInType(UmlClass type, UmlClassInstance element, String multiplicity) {
		String elementInTypeName = getPrefixedName(element);
		String typeName = getPrefixedName(type);
		UmlAttribute attribute = getElementInType(type, elementInTypeName, multiplicity);
		if (attribute == null)
			try {
				attribute = UmlAttribute.create(type, elementInTypeName);
			} catch (RuntimeException re) {
				trace("copyElementInType: error - attribute already exists " + element + " " + re.toString());
			}
		if (attribute == null)
			UmlCom.trace("copyElementInType: error copying element " + elementInTypeName + " in " + typeName);
		else {
			attribute.set_Description(element.description());
			setURI(attribute, getURI(element));
			relateElementInType(attribute, element);
			attribute.set_Multiplicity(multiplicity);
		}
		trace("addElementInTypes: inserted " + elementInTypeName + " to " + typeName);
		return attribute;
	}

	/** returns a type copied from the reference model to subset */
	private static UmlClass copyType(String typeName) {

		if ((typeName == null) || (typeName.equals("")))
			return null;

		// return subset type if it exists
		String schemaURI = getSchemaURI(typeName);
		UmlClass type = getType(subsetPackage, schemaURI, typeName);
		if (type != null)
			return type;

		// find reference type
		UmlClass sourceType = getType(referencePackage, schemaURI, typeName);
		if (sourceType == null) {
			UmlCom.trace("copyType: error - type " + typeName + " not in reference model");
			return null;
		}

		// if subset namespace doesn't exist, create it
		UmlClassView nsClassView = getNamespace(subsetPackage, getPrefix(typeName), schemaURI);
		if (nsClassView == null) {
			UmlCom.trace("copyType: error - no prefix or schema for type " + typeName);
			return null;
		}

		// create type
		// trace("copyType: copying type " + typeName + " to subset schema " +
		// nsClassView.name());
		try {
			type = UmlClass.create(nsClassView, filterUMLType(getName(typeName)));
		} catch (RuntimeException e) {
			trace("copyType: error - type already exists " + typeName + " " + e.toString());
			return null;
		}

		// copy type properties
		type.set_Description(sourceType.description());
		setURI(type, getURI(sourceType));
		String codeList = sourceType.propertyValue(CODELIST_PROPERTY);
		if (codeList != null)
			type.set_PropertyValue(CODELIST_PROPERTY, codeList);
		SubsetTypes.put(getURI(type), type);

		// copy and relate to base type
		UmlClass sourceBaseType = getBaseType(sourceType);
		if (sourceBaseType != null) {
			String baseTypeName = getPrefixedName(getPrefix(sourceBaseType.parent()), sourceBaseType.name());
			UmlClass baseType = copyType(baseTypeName);
			if (baseType != null)
				relateBaseType(type, baseType);
		}

		// copy and insert attributes
		for (UmlItem item : sourceType.children())
			if (isAttribute(item)) {
				UmlClassInstance sourceElement = getElementByURI(referencePackage, getURI(item));
				String attributeName = getPrefixedName(sourceElement);
				UmlClassInstance element = copyElement(attributeName);
				if (element == null)
					UmlCom.trace("copyType: error - no attribute " + attributeName);
				else
					copyElementInType(type, element, ((UmlAttribute) item).multiplicity());
			}

		// copy and relate to attribute groups
		UmlClass attributeGroupType = getAttributeGroup(sourceType);
		if (attributeGroupType != null) {
			String attributeGroupName = getPrefixedName(attributeGroupType);
			UmlClass attributeGroup = copyType(attributeGroupName);
			if (attributeGroup == null)
				UmlCom.trace("copyType: error - no attribute group " + attributeGroupName);
			else
				relateAttributeGroup(type, attributeGroupType);
		}
		return type;
	}

	/** creates Platform Independent Model (NIEM) */
	public static void createNIEM() {
		UmlPackage pimPackage = null;
		trace("createNIEM: Creating NIEM folders");
		// Find or create NIEM packages
		pimPackage = getPackage(UmlBasePackage.getProject(), NIEM_PACKAGE, true);
		subsetPackage = getPackage(pimPackage, NIEM_SUBSET_PACKAGE, true);
		extensionPackage = getPackage(pimPackage, NIEM_EXTENSION_PACKAGE, true);
		referencePackage = getPackage(pimPackage, NIEM_REFERENCE_PACKAGE, true);
		referencePackage.set_Stereotype("framework");
	}

	/** creates NIEM subset and extension models */
	@SuppressWarnings("unchecked")
	public static void createSubsetAndExtension() {

		// cache NIEM namespaces, elements and types
		trace("createSubsetAndExtension: cache models");
		cacheModel(referencePackage);
		cacheModel(subsetPackage);
		cacheModel(extensionPackage);

		Iterator<UmlItem> it = (UmlItem.all.iterator());
		// add types to subset and extension
		trace("createSubsetAndExtension: copy subset types and create extension types");
		it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				continue;
			String typeName = item.propertyValue(NIEM_STEREOTYPE_TYPENAME).trim();
			String elementName = item.propertyValue(NIEM_STEREOTYPE_PROPERTY).trim();
			String notes = item.propertyValue(NIEM_STEREOTYPE_NOTES).trim();
			String baseTypeName = item.propertyValue(NIEM_STEREOTYPE_BASE_TYPE).trim();
			if (baseTypeName.equals(ABSTRACT_TYPE_NAME))
				continue;
			// trace("createSubsetAndExtension: adding type " + typeName + " and base type "
			// + baseTypeName);
			String description = null;
			if (elementName.equals(""))
				if (typeName.endsWith(AUGMENTATION_TYPE_NAME))
					description = "An augmentation type";
				else
					description = item.description().trim();

			// add base type
			if (!baseTypeName.equals(""))
				if (isNiemType(baseTypeName))
					copyType(baseTypeName);
				else
					addType(extensionPackage, getSchemaURI(baseTypeName), baseTypeName, null, null);

			// add type
			if (!typeName.equals(""))
				if (isNiemType(typeName))
					copyType(typeName);
				else
					addType(extensionPackage, getSchemaURI(typeName), typeName, description, notes);
		}

		// relate extension types to base types and attribute groups
		trace("createSubsetAndExtension: copy subset base types and create extension base types");
		UmlClass attributeGroupType = getType(subsetPackage, Prefixes.get(STRUCTURES_PREFIX),
				getPrefixedName(STRUCTURES_PREFIX, SIMPLE_OBJECT_ATTRIBUTE_GROUP));
		it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				continue;
			String typeName = item.propertyValue(NIEM_STEREOTYPE_TYPENAME).trim();
			String elementName = item.propertyValue(NIEM_STEREOTYPE_PROPERTY).trim();
			String baseTypeName = item.propertyValue(NIEM_STEREOTYPE_BASE_TYPE).trim();
			if (typeName.equals("") || isNiemType(typeName))
				continue;
			UmlClass type = getType(null, getSchemaURI(typeName), typeName);
			if (type == null)
				continue;
			UmlClass baseType = null;
			if (baseTypeName.equals("") || typeName.endsWith(AUGMENTATION_TYPE_NAME))
				baseType = subsetAugmentationType;
			else {
				if (!elementName.equals(""))
					continue;
				if (baseTypeName.equals("")) {
					UmlCom.trace("createSubsetAndExtension: base type not defined for type " + typeName
							+ "; using default base type.");
					baseTypeName = getPrefixedName(STRUCTURES_PREFIX, OBJECT_TYPE_NAME);
				}
				baseType = getType(null, getSchemaURI(baseTypeName), baseTypeName);
				if (baseType == null) {
					UmlCom.trace("createSubsetAndExtension: base type " + baseTypeName + " not found.");
					continue;
				}
			}

			// relate type to base type
			relateBaseType(type, baseType);

			// If type is based on simple type, add attribute group
			String baseTypePrefix = getPrefix(baseType);
			if (baseTypePrefix != null && baseTypePrefix.equals(XSD_PREFIX) && attributeGroupType != null)
				relateAttributeGroup(type, attributeGroupType);
		}

		// Copy subset elements and create extension elements
		trace("createSubsetAndExtension: copy subset elements and create extension elements");
		it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				continue;
			String typeName = item.propertyValue(NIEM_STEREOTYPE_TYPENAME).trim();
			String elementList = item.propertyValue(NIEM_STEREOTYPE_PROPERTY).trim();
			String baseTypeName = item.propertyValue(NIEM_STEREOTYPE_BASE_TYPE).trim();
			String multiplicity = item.propertyValue(NIEM_STEREOTYPE_MULTIPLICITY).trim();
			String description = item.description().trim();
			String mappingNotes = item.propertyValue(NIEM_STEREOTYPE_NOTES).trim();
			String codeList = item.propertyValue(NIEM_STEREOTYPE_CODE_LIST).trim();

			boolean substitution = elementList.contains("(");
			String headElement = null;
			String[] elementNames = elementList.split(",");
			for (String elementName : elementNames) {
				boolean representation = false;
				if (elementName.contains("(")) {
					elementName = elementName.replaceAll("\\(|\\)", "");
					representation = true;
				}
				elementName = elementName.trim();
				if (elementName.equals(""))
					continue;
				if (elementName.contains("Augmentation") && description.equals(""))
					description = "An augmentation";
				Boolean isNillable = elementName.startsWith(REFERENCE_PREFIX);
				if (isNillable)
					elementName = elementName.substring(1);
				// trace("createSubsetAndExtension: adding element " + elementName + " in type "
				// + typeName);
				if (substitution && !representation && headElement == null)
					headElement = elementName;
				String baseTypeName2 = baseTypeName;
				if (baseTypeName.equals(ABSTRACT_TYPE_NAME) || (substitution && !representation))
					baseTypeName2 = getPrefixedName(LOCAL_PREFIX, ABSTRACT_TYPE_NAME);

				// copy NIEM element or add extension element
				UmlClassInstance element = (isNiemElement(elementName)) ? copyElement(elementName)
						: addElement(extensionPackage, getSchemaURI(elementName), elementName,
								getSchemaURI(baseTypeName2), baseTypeName2, description, mappingNotes);
				if (element == null)
					continue;

				// copy element in type
				if ((!substitution || !representation) && !typeName.equals("")) {
					UmlClass type = getType(null, getSchemaURI(typeName), typeName);
					if (type != null)
						if (isNiemType(typeName))
							copyElementInType(type, element, multiplicity);
						else
							addElementInType(type, element, multiplicity);
				}

				if (isNillable)
					element.set_PropertyValue(NILLABLE_PROPERTY, "true");
				if (headElement != null && substitution && representation)
					element.set_PropertyValue(SUBSTITUTION_PROPERTY, headElement);
				if (codeList != null && !codeList.equals("") && (!substitution || !representation))
					element.set_PropertyValue(CODELIST_PROPERTY, codeList);
			}
		}

		// Sorting
		trace("createSubsetAndExtension: sorting namespaces");
		subsetPackage.sort();
		extensionPackage.sort();
	}

	/** deletes NIEM mappings */
	public static void deleteMapping() {
		@SuppressWarnings("unchecked")
		Iterator<UmlItem> it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE) && item.kind() != anItemKind.aClassInstance)
				for (int property = 4; property < NIEM_STEREOTYPE_MAP.length; property++)
					item.set_PropertyValue(getNiemProperty(property), "");
		}
	}

	/** deletes NIEM models */
	public static void deleteNIEM(boolean deleteReferenceModel) {

		// Find NIEM package
		UmlPackage pimPackage = getPackage(UmlBasePackage.getProject(), NIEM_PACKAGE, true);

		// delete reference model
		if (deleteReferenceModel) {
			trace("deleteSubset: deleting reference model");
			referencePackage = getPackage(pimPackage, NIEM_REFERENCE_PACKAGE, false);
			if (referencePackage != null) {
				referencePackage.deleteIt();
				referencePackage.unload(true, true);
			}
		}

		// delete subset and extension models
		trace("deleteSubset: deleting subset and extension model");
		subsetPackage = getPackage(pimPackage, NIEM_SUBSET_PACKAGE, false);
		if (subsetPackage != null) {
			subsetPackage.deleteIt();
			subsetPackage.unload(true, true);
		}
		extensionPackage = getPackage(pimPackage, NIEM_EXTENSION_PACKAGE, false);
		if (extensionPackage != null) {
			extensionPackage.deleteIt();
			subsetPackage.unload(true, true);
		}
	}

	/** exports a Genericode code list */
	private static void exportCodeList(String dir, String elementName, String codeListURI, String codeList,
			String version, String date) {
		try {
			FileWriter fw;

			// export code list
			fw = new FileWriter(Paths.get(dir, elementName + GC_FILE_TYPE).toFile());
			fw.write(XML_HEADER + XML_ATTRIBUTION + "<gc:CodeList ");
			writeXmlNs(fw, CT_PREFIX, CT_URI);
			writeXmlNs(fw, GC_PREFIX, GC_URI);
			writeXmlNs(fw, GC_APPINFO_PREFIX, GC_APPINFO_URI);
			writeXmlNs(fw, XSI_PREFIX, XSI_URI);
			writeXmlAttribute(fw, XSI_PREFIX + ":schemaLocation", GC_URI + " " + GC_LOCATION);
			fw.write(">" + "<Annotation>" + "<AppInfo>" + "<gca:ConformanceTargets ct:conformanceTargets=\""
					+ CODELIST_URI + "#GenericodeCodeListDocument\"/>" + "</AppInfo>" + "</Annotation>"
					+ "<Identification>" + "<ShortName>" + elementName + "</ShortName>" + "<Version>" + version
					+ "</Version>" + "<CanonicalUri>" + codeListURI + "</CanonicalUri>" + "<CanonicalVersionUri>"
					+ codeListURI + "/" + date + "</CanonicalVersionUri>" + "</Identification>" + "<ColumnSet>"
					+ "<Column Id=\"" + CODELIST_CODE + "\" Use=\"required\">" + "<ShortName>" + CODELIST_CODE
					+ "</ShortName>" + "<CanonicalUri>" + CODELIST_URI + "column/" + CODELIST_CODE + "</CanonicalUri>"
					+ "<Data Type=\"normalizedString\" Lang=\"en\"/>" + "</Column>" + "<Column Id=\""
					+ CODELIST_DEFINITION + "\" Use=\"optional\">" + "<ShortName>" + CODELIST_DEFINITION
					+ "</ShortName>" + "<CanonicalUri>" + CODELIST_URI + "column/" + CODELIST_DEFINITION
					+ "</CanonicalUri>" + "<Data Type=\"normalizedString\" Lang=\"en\"/>" + "</Column>"
					+ "<Key Id=\"codeKey\">" + "<ShortName>CodeKey</ShortName>" + "<ColumnRef Ref=\"" + CODELIST_CODE
					+ "\"/>" + "</Key>" + "</ColumnSet>" + "<SimpleCodeList>");
			if (codeList.contains(CODELIST_DELIMITER)) {
				String[] codes = codeList.split(CODELIST_DELIMITER);
				for (String code : codes) {
					String[] pairs = code.split(CODELIST_DEFINITION_DELIMITER);
					fw.write("<Row><Value ColumnRef=\"" + CODELIST_CODE + "\"><SimpleValue>" + pairs[0].trim()
							+ "</SimpleValue></Value>");
					if (pairs.length > 1)
						fw.write("<Value ColumnRef=\"" + CODELIST_DEFINITION + "\"><SimpleValue>" + pairs[1].trim()
								+ "</SimpleValue></Value>");
					fw.write("</Row>");
				}
			}
			fw.write("</SimpleCodeList></gc:CodeList>");
			fw.close();

		} catch (IOException e) {
			UmlCom.trace("exportCodeList: IO exception: " + e.toString());
		} catch (RuntimeException e) {
			UmlCom.trace("exportCodeList: Runtime Exception: " + e.toString());
		}

	}

	/**
	 * exports a NIEM mapping spreadsheet in CSV format
	 * 
	 * roundtripping is supported with importCsv()
	 */
	@SuppressWarnings("unchecked")
	public static void exportCsv(String dir, String filename) {

		cacheExternalSchemas();

		UmlItem.directory = dir;
		String path = Paths.get(dir, filename).toString();

		try {
			FileWriter fw = new FileWriter(path);
			CSVWriter writer = new CSVWriter(fw);

			// Write header
			String[] nextLine = new String[NIEM_STEREOTYPE_MAP.length];
			for (int column = 0; column < NIEM_STEREOTYPE_MAP.length; column++)
				nextLine[column] = NIEM_STEREOTYPE_MAP[column][0];
			writer.writeNext(nextLine);

			// Export NIEM Mappings for Classes
			Iterator<UmlItem> it = (UmlClass.classes.iterator());
			while (it.hasNext()) {
				UmlItem thisClass = (UmlItem) it.next();
				if (thisClass.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
					nextLine = getItemCsv(thisClass);
					writer.writeNext(nextLine);

					// Export NIEM Mapping for Attributes and Relations
					for (UmlItem item : thisClass.children())
						if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
							nextLine = getItemCsv(item);
							if (nextLine != null)
								writer.writeNext(nextLine);
						}
				}
			}
			writer.close();
			trace("exportCsv: CSV file created " + path);

		} catch (Exception e) {
			UmlCom.trace("exportCsv: error " + e.toString());
		}
	}

	/** exports a NIEM mapping spreadsheet in HTML format */
	@SuppressWarnings("unchecked")
	public static void exportHtml(String dir, String filename) {

		cacheExternalSchemas();
		// cache NIEM namespaces, elements and types
		cacheModel(referencePackage);
		try {
			// Write rest of header
			FileWriter fw = new FileWriter(Paths.get(dir, filename + HTML_FILE_TYPE).toFile());
			fw.write("<html>");
			fw.write("<head><title>" + MAPPING_SPREADSHEET_TITLE
					+ "</title><link rel=\"stylesheet\" href=\"style.css\" type=\"text/css\" /></head>"
					+ "<body><div class = \"title\">" + MAPPING_SPREADSHEET_TITLE + "</div>"
					+ "<table style=\"table-layout: fixed; width: 100%\"><tr bgcolor=\"#f0f0f0\">");
			for (int column = 0; column < NIEM_STEREOTYPE_MAP.length; column++)
				fw.write("<td style=\"word-wrap: break-word\">" + NIEM_STEREOTYPE_MAP[column][0] + "</td>");
			fw.write("</tr>\n");

			// Show NIEM Mappings for Classes
			Iterator<UmlItem> it = (UmlClass.classes.iterator());
			while (it.hasNext()) {
				UmlItem thisClass = (UmlItem) it.next();
				if (thisClass.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
					writeLineHtml(fw, thisClass);

					// Show NIEM Mapping for Attributes and Relations
					for (UmlItem item : thisClass.children())
						if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
							writeLineHtml(fw, item);
				}
			}
			fw.write("</table>\n");
			fw.write("</body></html>");
			fw.close();
		} catch (Exception e) {
			UmlCom.trace("exportHtml: error " + e.toString());
		}
	}

	/** exports a NIEM IEPD including extension and exchange schema */
	@SuppressWarnings("unchecked")
	public static void exportIEPD(String xmlDir, String jsonDir) {

		cacheExternalSchemas();
		cacheModel(referencePackage);
		cacheModel(subsetPackage);
		cacheModel(extensionPackage);

		DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date();
		String today = dateFormat.format(date);

		exportSchema(subsetPackage, null, Paths.get(jsonDir, NIEM_DIR).toString());
		exportSchema(extensionPackage, xmlDir, jsonDir);

		Boolean exportXML = (xmlDir != null);
		Boolean exportJSON = (jsonDir != null);

		try {
			Set<String> CodeListNamespaces = new HashSet<String>();

			// export code lists for extension elements
			for (UmlItem item : extensionPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					classView.sort();
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClassInstance) {
							UmlClassInstance element = (UmlClassInstance) item2;
							String elementName = element.name();
							String codeList = element.propertyValue(CODELIST_PROPERTY);
							if (codeList != null) {
								String codeListURI = getExtensionSchema(elementName);
								exportCodeList(xmlDir, elementName, codeListURI, codeList,
										getProperty(IEPD_VERSION_PROPERTY), today);
								CodeListNamespaces.add(elementName);
							}
						}
				}

			// export code lists for subset elements
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					classView.sort();
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClassInstance) {
							UmlClassInstance element = (UmlClassInstance) item2;
							String elementName = element.name();
							String codeList = element.propertyValue(CODELIST_PROPERTY);
							if (codeList != null) {
								String codeListURI = getExtensionSchema(elementName);
								exportCodeList(xmlDir, elementName, codeListURI, codeList,
										getProperty(IEPD_VERSION_PROPERTY), today);
								CodeListNamespaces.add(elementName);
							}
						}
				}

			if (exportXML) {
				// export catalog file
				exportXMLCatalog(xmlDir, CodeListNamespaces);
			}

			// cache list of ports, operations and messages
			trace("exportIEPD: cache ports, operations and messages");
			Map<String, UmlClass> ports = new TreeMap<String, UmlClass>();
			Map<String, UmlOperation> operations = new TreeMap<String, UmlOperation>();
			Set<String> messages = new TreeSet<String>();
			Map<String, String> outputMessages = new TreeMap<String, String>();
			Map<String, ArrayList<String>> inputMessages = new TreeMap<String, ArrayList<String>>();
			Iterator<UmlItem> it = (UmlClass.classes.iterator());
			while (it.hasNext()) {
				UmlItem item = (UmlItem) it.next();
				if (item.stereotype().equals("interface")) {
					UmlClass type = (UmlClass) item;
					String portName = type.name();
					ports.put(portName, type);
					trace("exportIEPD: port: " + type.name());
					for (UmlItem item2 : type.children()) {
						if (item2.kind() == anItemKind.anOperation) {
							UmlOperation operation = (UmlOperation) item2;
							String operationName = operation.name();
							trace("exportIEPDa: operation: " + operationName);
							operations.put(operationName, operation);
							UmlClass type2 = null, type3 = null;
							UmlParameter[] params = operation.params();
							if (params != null)
								for (UmlParameter param : params) {
									try {
										type3 = param.type.type;
										// String mult = param.multiplicity;
									} catch (Exception e) {
										UmlCom.trace("exportIEPD: error - no input message for " + operationName);
									}
									if (type3 != null) {
										if (type3.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
											String inputMessage = type3.propertyValue(NIEM_STEREOTYPE_XPATH);
											if (inputMessage != null && !inputMessage.equals("")) {
												trace("exportIEPD: input Message: " + inputMessage + " from operation "
														+ operationName);
												messages.add(inputMessage);
												if (param.multiplicity != null)
													inputMessage = inputMessage + "," + param.multiplicity;
												else
													inputMessage = inputMessage + ",1";
												ArrayList<String> inputs = inputMessages.get(operationName);
												if (inputs == null)
													inputs = new ArrayList<String>();
												if (!inputs.contains(inputMessage))
													inputs.add(inputMessage);
												inputMessages.put(operationName, inputs);
											}
										}
									}
								}
							try {
								type2 = operation.returnType().type;
							} catch (Exception e) {
								UmlCom.trace("exportIEPD: error - no output message for " + operationName + " "
										+ e.toString());
							}
							if (type2 != null) {
								if (type2.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
									String outputMessage = type2.propertyValue(NIEM_STEREOTYPE_XPATH);
									if (outputMessage != null && !outputMessage.equals("")) {
										trace("exportIEPD: output Message: " + outputMessage + " from operation "
												+ operationName);
										messages.add(outputMessage);
										outputMessages.put(operationName, outputMessage);
									}
								}
							}
						}
					}
				}
			}

			if (exportXML) {
				exportMPDCatalog(xmlDir, CodeListNamespaces, messages);
				exportWSDL(xmlDir, ports, operations, messages, outputMessages, inputMessages);
			}

			if (exportJSON) {
				// TODO export OpenAPI file
			}

		} catch (IOException e) {
			UmlCom.trace("exportIEPD: IO exception: " + e.toString());
		}
	}

	/** exports a NIEM MPD catalog */
	private static void exportMPDCatalog(String xmlDir, Set<String> CodeListNamespaces, Set<String> messages)
			throws IOException {
		DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date();
		String today = dateFormat.format(date);

		UmlCom.trace("Generating MPD catalog");
		FileWriter xml = new FileWriter(Paths.get(xmlDir, MPD_CATALOG_FILE).toFile());
		xml.write(XML_HEADER);
		xml.write("<c:Catalog");
		for (Entry<String, String> entry : Prefixes.entrySet()) {
			String prefix = entry.getKey();
			if (prefix.equals(NC_PREFIX))
				writeXmlNs(xml, prefix, MPD_NC_URI);
			else if (prefix.equals(STRUCTURES_PREFIX))
				writeXmlNs(xml, prefix, MPD_STRUCTURES_URI);
			else
				writeXmlNs(xml, prefix, Prefixes.get(prefix));
		}
		writeXmlNs(xml, "c", MPD_CATALOG_URI);
		writeXmlAttribute(xml, XSI_PREFIX + ":schemaLocation", MPD_CATALOG_URI + " " + MPD_CATALOG_LOCATION);
		xml.write(">");
		xml.write("<c:MPD c:mpdURI=\"" + getExtensionSchema("") + "\"");
		writeXmlAttribute(xml, "c:mpdClassURIList", MPD_URI + "#MPD " + MPD_URI + "#IEPD");
		xml.write(" c:mpdName=\"" + getProperty(IEPD_NAME_PROPERTY) + "\" c:mpdVersionID=\""
				+ getProperty(IEPD_VERSION_PROPERTY) + "\">");
		xml.write("<c:MPDInformation>" + "<c:AuthoritativeSource>" + "<nc:EntityOrganization>" + "<nc:OrganizationName>"
				+ getProperty(IEPD_ORGANIZATION_PROPERTY) + "</nc:OrganizationName>"
				+ "<nc:OrganizationPrimaryContactInformation>" + "<nc:ContactWebsiteURI>"
				+ getProperty(IEPD_CONTACT_PROPERTY) + "</nc:ContactWebsiteURI>"
				+ "</nc:OrganizationPrimaryContactInformation>" + "</nc:EntityOrganization>"
				+ "</c:AuthoritativeSource>" + "<c:CreationDate>" + today + "</c:CreationDate>" + "<c:StatusText>"
				+ getProperty(IEPD_STATUS_PROPERTY) + "</c:StatusText>" + "</c:MPDInformation>");
		for (String message : messages) {
			UmlClassInstance element = null;
			if (isNiemElement(message))
				element = getElement(subsetPackage, getSchemaURI(message), message);
			else
				element = getElement(extensionPackage, getSchemaURI(message), message);
			xml.write("<c:IEPConformanceTarget structures:id=\"" + getName(message) + "\">");
			if (element == null)
				UmlCom.trace("exportMPDCatalog: error - no root element " + message);
			else
				xml.write("<nc:DescriptionText>" + element.description() + "</nc:DescriptionText>");
			xml.write("<c:HasDocumentElement c:qualifiedNameList=\"" + message + "\"/>" + "<c:XMLSchemaValid>"
					+ "<c:XMLCatalog c:pathURI=\"" + XML_CATALOG_FILE + "\"/>" + "</c:XMLSchemaValid>"
					+ "<c:IEPSampleXMLDocument c:pathURI=\"" + getName(message) + XML_FILE_TYPE + "\"/>"
					+ "</c:IEPConformanceTarget>");
		}
		xml.write("<c:ReadMe c:pathURI=\"" + getProperty(IEPD_READ_ME_FILE_PROPERTY) + "\"/>"
				+ "<c:MPDChangeLog c:pathURI=\"" + getProperty(IEPD_CHANGE_LOG_FILE_PROPERTY) + "\"/>"
				+ "<c:Wantlist c:pathURI=\"" + Paths.get(NIEM_DIR, WANTLIST_FILE).toString() + "\"/>"
				+ "<c:ConformanceAssertion c:pathURI=\"" + CONFORMANCE_ASSERTION_FILE + " \"/>");

		for (Entry<String, String> entry : Prefixes.entrySet()) {
			String prefix = entry.getKey();
			String schemaURI = Prefixes.get(prefix);
			if (schemaURI != null) {
				Namespace ns = Namespaces.get(schemaURI);
				if (ns != null) {
					if ((ns.referenceClassView == null) && (ns.filepath != null))
						xml.write("<c:ExtensionSchemaDocument c:pathURI=\"" + ns.filepath + "\"/>");
				}
			}
		}
		for (String codeList : CodeListNamespaces)
			xml.write("<c:BusinessRulesArtifact c:pathURI=\"" + codeList + GC_FILE_TYPE + "\"/>\n");
		xml.write("<c:ReadMe c:pathURI=\"" + getProperty(IEPD_READ_ME_FILE_PROPERTY) + "\"/>");
		xml.write("<c:MPDChangeLog c:pathURI=\"" + getProperty(IEPD_CHANGE_LOG_FILE_PROPERTY) + "\"/>");
		xml.write("</c:MPD></c:Catalog>");
		xml.close();
		trace("exportMPDCatalog: done generating MPD catalog");
	}

	/** exports NIEM extension and exchange schema */
	private static void exportSchema(UmlPackage schemaPackage, String xmlDir, String jsonDir) {

		Boolean exportXML = (xmlDir != null);
		Boolean exportJSON = (jsonDir != null);
		// UmlCom.trace("exportSchema: xmldir:" + xmlDir + " exportXML: " + exportXML);

		try {
			FileWriter xml = null, json = null;
			// Set<String> CodeListNamespaces = new HashSet<String>();

			// export each schema
			for (UmlItem item : schemaPackage.children()) {
				if (item.kind() != anItemKind.aClassView)
					continue;
				UmlClassView classView = (UmlClassView) item;
				classView.sort();
				String prefix = classView.propertyValue(PREFIX_PROPERTY);
				if (prefix == null) {
					UmlCom.trace("exportSchema: prefix for " + classView.propertyValue(PREFIX_PROPERTY) + " is null");
					continue;
				}
				if (isExternalPrefix(prefix))
					continue;
				String schemaURI = getURI(classView);
				trace("exportSchema: exporting schema " + prefix);

				// build list of referenced namespaces
				Set<String> RefNamespaces = new TreeSet<String>();
				RefNamespaces.add(XSD_PREFIX);
				for (UmlItem item2 : classView.children()) {
					if (item2.kind() != anItemKind.aClass)
						continue;
					UmlClass type = (UmlClass) item2;
					UmlClass baseType = getBaseType(type);
					if (baseType != null)
						RefNamespaces.add(getPrefix(baseType.parent()));
					UmlClass baseType2 = null;
					UmlClass type2 = type;
					while (type2 != null) {
						for (UmlItem item4 : type2.children()) {
							if (item4.kind() == anItemKind.anAttribute) {
								UmlAttribute elementInType = (UmlAttribute) item4;
								UmlClassInstance element = getElementByURI(null, getURI(elementInType));
								RefNamespaces.add(getPrefix(element.parent()));
							}
							if (item4.kind() == anItemKind.aRelation) {
								UmlRelation relation = (UmlRelation) item4;
								if (relation.relationKind() == aRelationKind.aGeneralisation)
									baseType2 = relation.roleType();
							}
						}
						type2 = baseType2;
						baseType2 = null;
					}
				}
				for (UmlItem item2 : classView.children()) {
					if (item2.kind() != anItemKind.aClassInstance)
						continue;
					UmlClassInstance element = (UmlClassInstance) item2;
					UmlClass baseType = element.type();
					RefNamespaces.add(getPrefix(baseType.parent()));
					String headElement = element.propertyValue(SUBSTITUTION_PROPERTY);
					if (headElement != null)
						RefNamespaces.add(getPrefix(headElement));
				}

				if (exportXML) {
					// Open XSD file for each extension schema and write header
					String nsSchemaURI = Prefixes.get(prefix);
					Namespace ns = Namespaces.get(nsSchemaURI);
					if (ns.filepath == null)
						continue;
					String filename = Paths.get(xmlDir, ns.filepath).toString();
					File file = new File(filename);
					file.getParentFile().mkdirs();
					xml = new FileWriter(filename);
					trace("exportSchema: schema " + prefix + XSD_FILE_TYPE);
					xml.write(XML_HEADER + XML_ATTRIBUTION + "<" + "xs:schema targetNamespace=\"" + schemaURI + "\"\n");

					// export XML namespace definitions
					writeXmlNs(xml, "", getURI(classView));
					writeXmlNs(xml, XSI_PREFIX, XSI_URI);
					for (String nsPrefix : RefNamespaces)
						if (!nsPrefix.equals(LOCAL_PREFIX))
							writeXmlNs(xml, nsPrefix, Prefixes.get(nsPrefix));

					writeXmlNs(xml, CODELIST_APPINFO_PREFIX, CODELIST_APPINFO_URI);
					writeXmlNs(xml, CT_PREFIX, CT_URI);
					writeXmlNs(xml, TERM_PREFIX, TERM_URI);
					writeXmlAttribute(xml, "ct:conformanceTargets",
							NDR_URI + "#ExtensionSchemaDocument " + CODELIST_URI + "#SchemaDocument");
					writeXmlAttribute(xml, "elementFormDefault", "qualified");
					writeXmlAttribute(xml, "attributeFormDefault", "unqualified");
					writeXmlAttribute(xml, "version", getProperty(IEPD_VERSION_PROPERTY));

					// close top level element
					xml.write(">\n");
					xml.write("<xs:annotation>\n" + "<xs:documentation> Schema for namespace " + Prefixes.get(prefix)
							+ "</xs:documentation>\n" + "</xs:annotation>");

					// export import namespaces
					trace("exportSchema: exporting namespaces");
					Path path1 = Paths.get(file.getParent());
					if (path1 == null)
						UmlCom.trace("exportSchema: error - path is null");
					for (String nsPrefix : RefNamespaces) {
						if ((nsPrefix.equals(LOCAL_PREFIX)) || (nsPrefix.equals(XSD_PREFIX)))
							continue;
						// trace("exportSchema: exporting prefix " + nsPrefix);
						String nsSchemaURI2 = Prefixes.get(nsPrefix);
						if (nsSchemaURI2 == null) {
							UmlCom.trace("exportSchema: error - prefix " + nsPrefix + " not in model");
							;
							continue;
						}
						if (isExternalPrefix(nsPrefix) && exportXML)
							xml.write("<xs:import namespace=\"" + nsSchemaURI2 + "\" schemaLocation=\""
									+ externalSchemaURL.get(nsSchemaURI2) + "\"/>");
						else {
							Namespace ns2 = Namespaces.get(nsSchemaURI2);
							if (ns2 == null) {
								UmlCom.trace("exportSchema: error - namespace " + nsSchemaURI2 + " not in model");
								continue;
							}
							Path p2 = Paths.get(xmlDir, ns2.filepath);
							Path p3 = path1.relativize(p2);
							if (!nsSchemaURI2.equals(schemaURI) && !nsSchemaURI2.equals(LOCAL_URI)
									&& !nsSchemaURI2.equals(XSD_URI) && ns2 != null && exportXML)
								xml.write("<xs:import namespace=\"" + nsSchemaURI2 + "\" schemaLocation=\""
										+ p3.toString() + "\"/>");
						}
					}
				}
				try {
					if (exportJSON) {
						// Open JSON schema file for each extension schema and write header
						trace("exportSchema: schema " + jsonDir + prefix + JSON_SCHEMA_FILE_TYPE);
						json = new FileWriter(Paths.get(jsonDir, prefix + JSON_SCHEMA_FILE_TYPE).toFile());
						json.write("{");
						writeJson(json, "$id", schemaURI);
						writeJson(json, "$schema", JSON_SCHEMA_URI);
						writeJson(json, "type", "object");
						json.write("\"additionalProperties\" : false,\n");

						// export JSON-LD namespace definitions
						json.write("\"@context\" : {\n");
						for (String nsPrefix : RefNamespaces)
							writeJson(json, nsPrefix, Prefixes.get(nsPrefix) + "#");
						writeJson(json, CODELIST_APPINFO_PREFIX, CODELIST_APPINFO_URI + "#");
						writeJson(json, CT_PREFIX, CT_URI + "#");
						writeJsonLast(json, TERM_PREFIX, TERM_URI + "#");
						json.write("},");
					}
				} catch (Exception e1) {
					UmlCom.trace("exportSchema: error exporting JSON header " + e1.toString());
				}

				// export types
				trace("exportSchema: exporting types");
				TreeSet<String> jsonTypes = new TreeSet<String>();
				for (UmlItem item2 : classView.children())
					if (item2.kind() != anItemKind.aClass)
						continue;
					else
						try {
							UmlClass type = (UmlClass) item2;
							String jsonType = null;
							String typeName = getName(type);
							String description = type.description();
							String baseTypeName = null;
							String baseTypeCodeList = null;
							String mappingNotes = type.propertyValue(NOTES_PROPERTY);
							if (exportXML && mappingNotes != null && !mappingNotes.equals(""))
								xml.write("<!--" + mappingNotes + "-->");
							String codelist = type.propertyValue(CODELIST_PROPERTY);
							if (codelist != null && codelist.equals(""))
								codelist = null;
							String augmentationPoint = null, augmentationPointMin = null, augmentationPointMax = null;
							// trace("exportSchema: exporting type " + typeName);
							for (UmlItem item3 : type.children()) {
								if (item3.kind() != anItemKind.aRelation)
									continue;
								UmlRelation relation = (UmlRelation) item3;
								if (relation.relationKind() != aRelationKind.aGeneralisation)
									continue;
								UmlClass baseType = relation.roleType();
								baseTypeName = getPrefixedName(baseType);
								// trace("exportSchema: base type name " + baseTypeName);
								baseTypeCodeList = baseType.propertyValue(CODELIST_PROPERTY);
								if (baseTypeCodeList != null && baseTypeCodeList.equals(""))
									baseTypeCodeList = null;
								break;
							}

							if (baseTypeName == null) {// abstract
								trace("exportSchema: exporting abstract type " + typeName);
								if (exportXML) {
									xml.write("<xs:complexType name=\"" + typeName + "\" abstract=\"true\">\n"
											+ "<xs:annotation>\n" + "<xs:documentation>" + description
											+ "</xs:documentation>\n" + "</xs:annotation>\n" + "</xs:complexType>");
								}
								// XSD simple types
								if (exportJSON && prefix.equals(XSD_PREFIX)) {
									String jsonPrimitive = "string";
									switch (typeName) {
										case "boolean": 
											jsonPrimitive = "boolean"; break;
										case "decimal":
										case "double":
										case "float":
										case "int":
										case "integer": 
										case "long":
										case "negativeInteger":
										case "nonNegativeInteger":
										case "nonPositiveInteger":
										case "positiveInteger":
										case "short":
										case "unsignedInt":
										case "unsignedLong":
										case "unsignedShort":
											jsonPrimitive = "number"; break;
									}		
									jsonType = "\"" + getPrefixedName(type) + "\": {\n" 
											+ "\"type\": \"" + jsonPrimitive + "\"\n" + "}\n";
									jsonTypes.add(jsonType);
								}
								continue;
							}

							Boolean complexContent = false;
							if (codelist != null) { // code list simple type
								trace("exportSchema: exporting code list simple type " + typeName);
								if (exportXML) {
									xml.write("<xs:simpleType name=\"" + typeName + "\">\n" + "<xs:annotation>\n"
											+ "<xs:documentation>" + description + "</xs:documentation>\n"
											+ "</xs:annotation>\n" + "<xs:restriction base=\"" + baseTypeName
											+ "\">\n");
								}
								String[] codes = codelist.split(CODELIST_DELIMITER);
								Set<String> enums = new HashSet<String>();
								for (String code : codes) {
									if (code.equals(""))
										continue;
									String[] codeParams = code.split(CODELIST_DEFINITION_DELIMITER);
									String code2 = codeParams[0].trim().replace("&", "&amp;");
									String codeDescription = "";
									if (codeParams.length > 1 && !codeParams[1].equals(""))
										codeDescription = codeParams[1].trim().replace("&", "&amp;");
									if (code2.equals(""))
										continue;
									enums.add("\"" + code2 + "\"");
									if (exportXML) {
										xml.write("<xs:enumeration value=\"" + code2 + "\">\n");
										if (!codeDescription.equals(""))
											xml.write("<xs:annotation>\n" + "<xs:documentation>" + codeDescription
													+ "</xs:documentation>\n" + "</xs:annotation>\n");
										xml.write("</xs:enumeration>\n");
									}
								}
								if (exportXML)
									xml.write("</xs:restriction>");
								if (exportJSON) {
									jsonType = "\"" + getPrefixedName(type) + "\": {\n" + "\"description\": \""
											+ filterQuotes(description) + "\",\n" + "\"$ref\": \""
											+ getJSONType(baseTypeName, prefix) + "\",\n" 
											+ "\"enums\": [" + String.join(",", enums) + "]\n" + "}\n";
									jsonTypes.add(jsonType);
								}

							} else if (baseTypeCodeList != null) { // code list complex type
								trace("exportSchema: exporting code list complex type " + typeName);
								if (exportXML) {
									xml.write("<xs:complexType name=\"" + typeName + "\">\n" + "<xs:annotation>\n"
											+ "<xs:documentation>" + description + "</xs:documentation>\n"
											+ "</xs:annotation>\n" + "<xs:simpleContent>\n" + "<xs:extension base=\""
											+ baseTypeName + "\">\n");
									xml.write("</xs:extension>\n");
								}
								if (exportJSON) {
									jsonType = "\"" + getPrefixedName(type) + "\": {\n" + "\"description\": \""
											+ filterQuotes(description) + "\",\n" + "\"$ref\": \""
											+ getJSONType(baseTypeName, prefix) + "\"\n" + "}\n";
									jsonTypes.add(jsonType);
								}

							} else {
								trace("exportSchema: exporting complex type " + typeName); // complexContent
								complexContent = true;
								if (exportXML) {
									xml.write("<xs:complexType name=\"" + typeName + "\">\n" + "<xs:annotation>\n"
											+ "<xs:documentation>" + description + "</xs:documentation>\n"
											+ "</xs:annotation>\n" + "<xs:complexContent>\n" + "<xs:extension base=\""
											+ baseTypeName + "\">\n");
									xml.write("<xs:sequence>\n");
								}
							}

							type.sortChildren();
							TreeSet<String> required = new TreeSet<String>();
							TreeSet<String> properties = new TreeSet<String>();
							String anyElement = getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME);
							Boolean anyJSON = false;
							UmlClass type2 = type, baseType = null;
							while (type2 != null) {
								try {
									for (UmlItem item4 : type2.children()) {
										if (item4.kind() == anItemKind.anAttribute) {
											UmlAttribute attribute = (UmlAttribute) item4;
											UmlClassInstance element = getElementByURI(null, getURI(attribute));
											String elementName = getPrefixedName(element);
											String multiplicity = attribute.multiplicity();
											String minoccurs, maxoccurs;
											if ((multiplicity.equals("")))
												minoccurs = maxoccurs = "1";
											else if (multiplicity.contains(",")) {
												String[] occurs = multiplicity.split(",");
												minoccurs = occurs[0];
												maxoccurs = occurs[1];
											} else
												minoccurs = maxoccurs = multiplicity;
											try {
												if (Integer.parseInt(minoccurs) < 0)
													throw new NumberFormatException();
												if (!maxoccurs.equals("unbounded") && (Integer.parseInt(maxoccurs) < 1))
													throw new NumberFormatException();
											} catch (NumberFormatException e) {
												UmlCom.trace("exportSchema: error - invalid multiplicity "
														+ multiplicity + " for " + typeName + "/" + elementName);
											}
											String elementMappingNotes = attribute.propertyValue(NOTES_PROPERTY);
											if (elementMappingNotes != null && !elementMappingNotes.equals(""))
												if (type2 == type && exportXML && complexContent)
													xml.write("<!--" + elementMappingNotes + "-->");
											trace("exportSchema: exporting element in type " + elementName);
											if (elementName.equals(anyElement)) {
												trace("exportSchema: exporting any in type");
												if (type2 == type && exportXML && complexContent)
													xml.write("<xs:any/>");
												if (exportJSON && complexContent) {
													anyJSON = true;
												}
											} else if (type2 == type && elementName.endsWith(AUGMENTATION_POINT_NAME)) {
												augmentationPoint = elementName;
												augmentationPointMin = minoccurs;
												augmentationPointMax = maxoccurs;
											} else {
												if (type2 == type && exportXML && complexContent)
													xml.write("<xs:element ref=\"" + elementName + "\" minOccurs=\""
															+ minoccurs + "\" maxOccurs=\"" + maxoccurs + "\"/>\n");
												if (exportJSON) {
													UmlClass elementBaseType = element.type();
													if (isAttribute(element))
														if (!elementName.equals(getPrefixedName(STRUCTURES_PREFIX,"@id"))) {
															elementName = elementName.replaceAll(ATTRIBUTE_PREFIX, "");
															if ((elementBaseType != subsetAbstractType)
																&& (elementBaseType != referenceAbstractType)) {												
																properties.add(getJSONProperty(elementName, minoccurs,
																	maxoccurs, prefix));
															if (Integer.parseInt(minoccurs) > 0)
																required.add("\"" + elementName + "\"");
															}
															if (Substitutions.containsKey(elementName)) {
																List<UmlClassInstance> enlist = (List<UmlClassInstance>) (Substitutions
																	.get(elementName));
																for (UmlClassInstance element2 : enlist)
																	properties.add(getJSONProperty(element2.name(), minoccurs,
																		maxoccurs, prefix));
															}
														}
												}
											}
										}
										if (item4.kind() == anItemKind.aRelation) {
											UmlRelation relation = (UmlRelation) item4;
											if (relation.relationKind() == aRelationKind.aGeneralisation)
												baseType = relation.roleType();
										}
									}
									type2 = baseType;
									baseType = null;
								} catch (Exception e) {
									UmlCom.trace("exportSchema: error exporting element in type" + e.toString());
								}
							}
							if (augmentationPoint != null) {
								if (exportXML && complexContent)
									xml.write("<xs:element ref=\"" + augmentationPoint + "\" minOccurs=\""
											+ augmentationPointMin + "\" maxOccurs=\"" + augmentationPointMax
											+ "\"/>\n");
							}
							if (exportXML && complexContent)
								xml.write("</xs:sequence>\n");

							// export attributes and attribute groups
							for (UmlItem item4 : type.children()) {
								if (item4.kind() == anItemKind.anAttribute) {
									try {
										UmlAttribute attribute = (UmlAttribute) item4;
										UmlClassInstance element = getElementByURI(null, getURI(attribute));
										String elementName = getName(element);
										String multiplicity = attribute.multiplicity();
										if (isAttribute(element)) { // attribute
											if (exportXML) {
												String use = multiplicity.equals("0,1") ? "optional" : "required";
												xml.write("<xs:attribute ref=\"" + elementName + "\" use = \"" + use
														+ "\"/>");
											}
										}
									} catch (Exception e) {
										UmlCom.trace("exportSchema: error exporting attribute in type" + e.toString());

									}
								} else if (item4.kind() == anItemKind.aRelation) {
									UmlRelation relation = (UmlRelation) item4;
									if (relation.relationKind() == aRelationKind.aDirectionalAggregation) {
										try {
											// attributeGroup
											UmlClass sourceBaseType = relation.roleType();
											if (exportXML) {
												xml.write("<xs:attributeGroup ref=\"" + getPrefixedName(sourceBaseType)
														+ "\"/>");
											}
											if (exportJSON) {
												for (UmlItem item5 : sourceBaseType.children()) {
													if (item5.kind() != anItemKind.anAttribute)
														continue;
													UmlAttribute attribute = (UmlAttribute) item5;
													UmlClassInstance element = getElementByURI(null, getURI(attribute));
													String elementName = getPrefixedName(element);
													UmlClass elementBaseType = element.type();
													if (isAttribute(element))
														elementName = elementName.replaceAll(ATTRIBUTE_PREFIX, "");
													String multiplicity = attribute.multiplicity();
													String minoccurs;
													if ((multiplicity.equals("")))
														minoccurs = "1";
													else if (multiplicity.contains(",")) {
														String[] occurs = multiplicity.split(",");
														minoccurs = occurs[0];
													} else
														minoccurs = multiplicity;
													if ((elementBaseType != subsetAbstractType)
															&& (elementBaseType != referenceAbstractType)) {
														properties.add(
																getJSONProperty(elementName, minoccurs, "1", prefix));
														if (Integer.parseInt(minoccurs) > 0)
															required.add("\"" + elementName + "\"");
													}
												}
											}
										} catch (Exception e) {
											UmlCom.trace("exportSchema: error exporting attribute group in type"
													+ e.toString());
										}
									}
								}
							}

							try {
								if (exportXML) {
									if (codelist != null)
										xml.write("</xs:simpleType>\n");
									else if (baseTypeCodeList != null)
										xml.write("</xs:simpleContent>\n</xs:complexType>\n");
									else if (complexContent)
										xml.write("</xs:extension>\n</xs:complexContent>\n</xs:complexType>\n");
								}

								if (exportJSON) {
									jsonType = "\"" + getPrefixedName(type) + "\": {\n";
									if (description != null)
										jsonType += "\"description\": \"" + filterQuotes(description) + "\",\n";
									jsonType += "\"type\": \"object\",\n" + "\"additionalProperties\" :" + anyJSON
											+ ",\n";
									if (properties != null)
										jsonType += "\"properties\": {\n" + String.join(",", properties) + "\n"
												+ "},\n";
									if (required != null)
										jsonType += "\"required\" : [\n" + String.join(",", required) + "\n" + "]\n";
									jsonType += "}\n";
									jsonTypes.add(jsonType);
								}
							} catch (Exception e) {
								UmlCom.trace("exportSchema: error closing type" + e.toString());

							}
						} catch (Exception e) {
							UmlCom.trace("exportSchema: error exporting types " + e.toString());
						}

				// export elements
				trace("exportSchema: exporting elements");
				TreeSet<String> jsonElements = new TreeSet<String>();
				for (UmlItem item2 : classView.children())
					if (item2.kind() != anItemKind.aClassInstance)
						continue;
					else
						try {
							UmlClassInstance element = (UmlClassInstance) item2;
							String elementName = getName(element);
							String description = element.description();
							UmlClass baseType = element.type();
							String baseTypeName = getPrefixedName(baseType);
							String mappingNotes = element.propertyValue(NOTES_PROPERTY);
							String headElement = element.propertyValue(SUBSTITUTION_PROPERTY);
							String codeList = element.propertyValue(CODELIST_PROPERTY);
							String isNillable = element.propertyValue(NILLABLE_PROPERTY);
							if (isNillable == null)
								isNillable = "false";
							if (mappingNotes != null && !mappingNotes.equals(""))
								if (exportXML)
									xml.write("<!--" + mappingNotes + "-->");
							if ((baseType == subsetAbstractType) || (baseType == referenceAbstractType)) {
								if (exportXML)
									xml.write("<xs:element name=\"" + elementName + "\" abstract=\"true\">\n");
							} else if (isAttribute(element)) {
								if (!elementName.equals(getPrefixedName(STRUCTURES_PREFIX,"@id")))
									jsonElements.add("\"" + getPrefixedName(element).replaceAll(ATTRIBUTE_PREFIX, "") + "\": {\n" + "\"description\": \""
										+ filterQuotes(description) + "\",\n" + "\"$ref\": \""
										+ getJSONType(baseTypeName, prefix) + "\"\n" + "}");
								continue;
							} else if (headElement != null) {
								if (exportXML)
									xml.write("<xs:element name=\"" + elementName + "\" type=\"" + baseTypeName
											+ "\" substitutionGroup=\"" + headElement + "\" nillable=\"" + isNillable
											+ "\">\n");
								if (exportJSON)
									jsonElements.add("\"" + getPrefixedName(element) + "\": {\n" + "\"description\": \""
											+ filterQuotes(description) + "\",\n" + "\"$ref\": \""
											+ getJSONType(baseTypeName, prefix) + "\"\n" + "}");
							} else {
								if (baseType == null && elementName.endsWith(AUGMENTATION_TYPE_NAME)) {
									baseType = subsetAugmentationType;
									baseTypeName = getPrefixedName(subsetAugmentationType);
								}
								if (exportXML)
									xml.write("<xs:element name=\"" + elementName + "\" type=\"" + baseTypeName
											+ "\" nillable=\"" + isNillable + "\">\n");
								if (exportJSON) {
									jsonElements.add("\"" + getPrefixedName(element) + "\": {\n" + "\"description\": \""
											+ filterQuotes(description) + "\",\n" + "\"$ref\": \""
											+ getJSONType(baseTypeName, prefix) + "\"\n" + "}");
								}
							}
							if (exportXML)
								xml.write("<xs:annotation>\n" + "<xs:documentation>" + description
										+ "</xs:documentation>\n");
							if (codeList != null) {
								String codeListURI = getExtensionSchema(elementName);
								if (exportXML)
									xml.write("<xs:appinfo>" + "<clsa:SimpleCodeListBinding codeListURI=\""
											+ codeListURI + "\"/>" + " </xs:appinfo>");
							}
							if (exportXML)
								xml.write("</xs:annotation>\n" + "</xs:element>\n");
						} catch (Exception e) {
							UmlCom.trace("exportSchema: error exporting elements " + e.toString());
						}
				if (exportXML) {
					xml.write("</xs:schema>\n");
					xml.close();
				}
				if (exportJSON) {
					json.write("\"definitions\": {\n" + String.join(",", jsonTypes) + "\n" + "},\n"
							+ "\"properties\" : {" + String.join(",", jsonElements) + "}\n" + "}");
					json.close();
				}
			}
		} catch (IOException e) {
			UmlCom.trace("exportSchema: IO exception: " + e.toString());
		} catch (RuntimeException e) {
			UmlCom.trace("exportSchema: RuntimeException: " + e.toString());
		}
	}

	/**
	 * exports a NIEM wantlist for import into Subset Schema Generator Tool (SSGT)
	 */
	public static void exportWantlist(String dir, String filename) {

		// createSubset();
		cacheExternalSchemas();

		UmlItem.directory = dir;
		try {
			// Export schema
			trace("exportWantlist: create header");
			FileWriter fw = new FileWriter(Paths.get(dir, filename).toFile());
			fw.write(XML_HEADER);
			fw.write(XML_ATTRIBUTION);
			fw.write("<w:WantList w:release=\"" + getNiemVersion()
					+ "\" w:product=\"NIEM\" w:nillableDefault=\"true\" ");
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					String prefix = item.propertyValue(PREFIX_PROPERTY);
					String schemaURI = Prefixes.get(prefix);
					if (!prefix.equals(LOCAL_PREFIX) && (!prefix.equals(XSD_PREFIX)))
						writeXmlNs(fw, prefix, schemaURI);
				}
			writeXmlNs(fw, "w", WANTLIST_URI);
			fw.write(">");

			// export elements
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					String prefix = classView.propertyValue(PREFIX_PROPERTY);
					String anyElement = getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME);
					if (prefix.equals(LOCAL_PREFIX) || prefix.equals(XSD_PREFIX) || prefix.equals(STRUCTURES_PREFIX))
						continue;
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClassInstance) {
							UmlClassInstance element = (UmlClassInstance) item2;
							String elementName = getPrefixedName(element);
							if (elementName.equals(anyElement))
								continue;
							if (isAttribute(element)) {
								elementName = getPrefixedName(getPrefix(elementName),
										getName(elementName).replaceAll(ATTRIBUTE_PREFIX, ""));
								trace("exportWantlist: export attribute " + elementName);
								fw.write("<w:Attribute w:name=\"" + elementName + "\"/>\n");
								continue;
							}
							trace("exportWantlist: export element " + elementName);
							String isNillable = element.propertyValue(NILLABLE_PROPERTY);
							if (isNillable == null)
								isNillable = "false";
							fw.write("<w:Element w:name=\"" + elementName + "\" w:isReference=\"false\" w:nillable=\""
									+ isNillable + "\"/>\n");
						}
				}

			// export types
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					String prefix = classView.propertyValue(PREFIX_PROPERTY);
					if (prefix.equals(LOCAL_PREFIX) || prefix.equals(XSD_PREFIX) || prefix.equals(STRUCTURES_PREFIX))
						continue;
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClass) {
							UmlClass type = (UmlClass) item2;
							String typeName = getPrefixedName(type);
							trace("exportWantlist: export type " + typeName);

							// do not export structures:AugmentationType
							if (type == subsetAugmentationType)
								continue;

							// attribute groups are not supported in wantlists
							if (isAttribute(type))
								continue;

							fw.write("<w:Type w:name=\"" + typeName + "\" w:isRequested=\"true\">\n");

							for (UmlItem item3 : type.children())
								if (item3.kind() == anItemKind.anAttribute) {
									UmlAttribute attribute = (UmlAttribute) item3;
									String elementName = attribute.name();
									// trace("exportWantlist: adding element " + elementName);
									String multiplicity = attribute.multiplicity();
									String minoccurs, maxoccurs;
									if ((multiplicity.equals("")))
										minoccurs = maxoccurs = "1";
									else if (multiplicity.contains(",")) {
										String[] occurs = multiplicity.split(",");
										minoccurs = occurs[0];
										maxoccurs = occurs[1];
									} else
										minoccurs = maxoccurs = multiplicity;
									try {
										if (Integer.parseInt(minoccurs) < 0)
											throw new NumberFormatException();
										if (!maxoccurs.equals("unbounded") && (Integer.parseInt(maxoccurs) < 1))
											throw new NumberFormatException();
									} catch (NumberFormatException e) {
										UmlCom.trace("exportWantlist: error - invalid multiplicity " + multiplicity
												+ " for " + typeName + "/" + elementName);
									}
									// if (((!minoccurs.equals("0") && !minoccurs.equals("1"))) ||
									// ((!maxoccurs.equals("1") && !maxoccurs.equals("unbounded"))))
									// UmlCom.trace("createSubset: unusual multiplicity " + multiplicity + " for
									// element " + elementName);;

									if (isAttribute(attribute)) {
										elementName = getPrefixedName(getPrefix(elementName),
												getName(elementName).replaceAll(ATTRIBUTE_PREFIX, ""));
										trace("exportWantlist: export attribute " + elementName);
										fw.write("<w:AttributeInType w:name=\"" + elementName + "w:minOccurs=\""
												+ minoccurs + "\" w:maxOccurs=\"" + maxoccurs + "\"/>\n");
										continue;
									}
									// trace("exportWantlist: export element " + elementName + " in type " +
									// typeName);
									fw.write("\t<w:ElementInType w:name=\"" + elementName
											+ "\" w:isReference=\"false\" w:minOccurs=\"" + minoccurs
											+ "\" w:maxOccurs=\"" + maxoccurs + "\"/>\n");
								}

							// export enumerations
							String codeList = type.propertyValue(CODELIST_PROPERTY);
							if (codeList != null) {
								// trace("exportWantlist: exporting enumerations for " + getPrefixedName(type));
								if (codeList.trim().contains(CODELIST_DELIMITER)) {
									String[] codes = codeList.split(CODELIST_DELIMITER);
									for (String code : codes) {
										String[] pairs = code.split(CODELIST_DEFINITION_DELIMITER);
										String value = pairs[0].trim();
										if (!value.equals(""))
											fw.write("<w:Facet w:facet=\"enumeration\" w:value=\"" + filterQuotes(value)
													+ "\"/>");
									}
								}
							}
							fw.write("</w:Type>");
						}
				}

			fw.write("</w:WantList>");
			fw.close();

		} catch (IOException e) {
			UmlCom.trace("exportWantlist: IO exception: " + e.toString());
		}
	}

	/** exports a WSDL definitions file */
	private static void exportWSDL(String xmlDir, Map<String, UmlClass> ports, Map<String, UmlOperation> operations,
			Set<String> messages, Map<String, String> outputMessages, Map<String, ArrayList<String>> inputMessages)
			throws IOException {

		String WSDLURI = getProperty(IEPD_URI_PROPERTY) + WSDL_SUFFIX;
		String WSDLXSDURI = getProperty(IEPD_URI_PROPERTY) + WSDL_XSD_SUFFIX;

		UmlCom.trace("Generating document/literal wrapper schema");
		FileWriter xml = new FileWriter(Paths.get(xmlDir, WSDL_XSD_SUFFIX + XSD_FILE_TYPE).toFile());
		xml.write("<xs:schema targetNamespace=\"" + WSDLXSDURI + "\"");
		writeXmlNs(xml, WSDL_XSD_PREFIX, WSDLXSDURI);

		// build list of referenced namespaces
		Set<String> RefNamespaces = new TreeSet<String>();
		RefNamespaces.add(XSD_PREFIX);
		// RefNamespaces.add(structuresPrefix);
		for (String message : messages)
			RefNamespaces.add(getPrefix(message));
		for (String nsPrefix : RefNamespaces)
			xml.write(" " + NAMESPACE_ATTRIBUTE + ":" + nsPrefix + "=\"" + Prefixes.get(nsPrefix) + "\"");
		xml.write(" elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\">");
		for (String nsPrefix : RefNamespaces) {
			String nsSchemaURI = Prefixes.get(nsPrefix);
			if (isExternalPrefix(nsPrefix)) {
				if (nsSchemaURI != null)
					xml.write("<xs:import namespace=\"" + nsSchemaURI + "\" schemaLocation=\""
							+ externalSchemaURL.get(nsSchemaURI) + "\"/>");
			} else if (!nsPrefix.equals(XSD_PREFIX)) {
				Namespace ns = Namespaces.get(nsSchemaURI);
				if (ns != null)
					xml.write("<xs:import namespace=\"" + Prefixes.get(nsPrefix) + "\" schemaLocation=\"" + ns.filepath
							+ "\"/>");
			}
		}

		xml.write("<!-- document/literal wrappers -->");
		for (UmlOperation operation : operations.values()) {
			String operationName = operation.name();
			trace("exportWSDL: generating document/literal wrapper for " + operationName);
			ArrayList<String> inputs = inputMessages.get(operationName);
			if (inputs != null) {
				String inputType = operationName + "RequestType";
				xml.write("<xs:complexType name=\"" + inputType + "\">" + "<xs:sequence>");
				for (String inputMessage : inputs) {
					String inputMessage2 = inputMessage;
					String mult = "1";
					if (inputMessage.contains(",")) {
						String inputMessageParts[] = inputMessage.split(",");
						inputMessage2 = inputMessageParts[0];
						if (inputMessageParts.length > 1) {
							mult = inputMessageParts[1];
						}
					}
					String minoccurs = "1";
					String maxoccurs = "1";
					if (!(mult.equals(""))) {
						if (mult.contains("..")) {
							String[] occurs = mult.split("\\.\\.");
							minoccurs = occurs[0];
							maxoccurs = occurs[1];
						} else
							minoccurs = maxoccurs = mult;
					}
					if (maxoccurs.equals("*"))
						maxoccurs = "unbounded";

					if (isExternalPrefix(getPrefix(inputMessage2)))
						xml.write("<!--xs:element ref=\"" + inputMessage2 + "\" minOccurs=\"" + minoccurs
								+ "\" maxOccurs=\"" + maxoccurs + "\"/-->\n");
					else
						xml.write("<xs:element ref=\"" + inputMessage2 + "\" minOccurs=\"" + minoccurs
								+ "\" maxOccurs=\"" + maxoccurs + "\"/>\n");

				}
				xml.write("</xs:sequence>" + "</xs:complexType>" + "<xs:element name=\"" + operationName
						+ "Request\" type=\"" + getPrefixedName(WSDL_XSD_PREFIX, inputType) + "\"/>");
			}
			String outputMessage = outputMessages.get(operationName);
			if (outputMessage != null) {
				String outputType = operationName + "ResponseType";
				xml.write("<xs:complexType name=\"" + outputType + "\">" + "<xs:sequence>");
				if (isExternalPrefix(getPrefix(outputMessage)))
					xml.write("<!--xs:element ref=\"" + outputMessage + "\"/-->");
				else
					xml.write("<xs:element ref=\"" + outputMessage + "\"/>");
				xml.write("</xs:sequence>" + "</xs:complexType>" + "<xs:element name=\"" + operationName
						+ "Response\" type=\"" + getPrefixedName(WSDL_XSD_PREFIX, outputType) + "\"/>");
			}
		}
		xml.write("</xs:schema>");
		xml.close();

		UmlCom.trace("Generating WSDLs");
		for (UmlClass port : ports.values()) {
			String portName = port.name();
			xml = new FileWriter(Paths.get(xmlDir, portName + WSDL_FILE_TYPE).toFile());
			trace("WSDL: " + portName + ".wsdl");
			xml.write("<definitions targetNamespace=\"" + WSDLURI + "/" + portName + "\"");
			writeXmlNs(xml, WSDL_PREFIX, WSDLURI + "/" + portName);
			writeXmlNs(xml, WSDL_XSD_PREFIX, WSDLXSDURI);
			writeXmlNs(xml, "xsd", XSD_URI);
			writeXmlNs(xml, SOAP_PREFIX, SOAP_URI);
			writeXmlNs(xml, WSDL_SCHEMA_PREFIX, WSDL_SCHEMA_URI);
			writeXmlNs(xml, "", WSDL_SCHEMA_URI);
			writeXmlNs(xml, WSP_PREFIX, WSP_URI);
			writeXmlNs(xml, WSRMP_PREFIX, WSRMP_URI);
			writeXmlNs(xml, WSU_PREFIX, WSU_URI);
			xml.write(">");
			xml.write("<wsp:UsingPolicy wsdl:required=\"true\"/>" + "<wsp:Policy wsu:Id=\"" + WSP_POLICY + "\">"
					+ "<wsrmp:RMAssertion/>" + "</wsp:Policy>" + "<wsdl:types>" + "<xsd:schema>"
					+ "<xsd:import namespace=\"" + WSDLXSDURI + "\" schemaLocation=\"" + WSDL_XSD_SUFFIX + XSD_FILE_TYPE
					+ "\"/>" + "</xsd:schema>" + "</wsdl:types>");

			xml.write("<!-- messages -->");
			// for (UmlOperation operation : operations.values())
			// {
			// String operationName = operation.name();
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					UmlOperation operation = (UmlOperation) item;
					String operationName = operation.name();
					xml.write("<message name=\"" + operationName + REQUEST_MESSAGE_SUFFIX + "\">"
							+ "<part name=\"body\" element=\"" + getPrefixedName(WSDL_XSD_PREFIX, operationName)
							+ REQUEST_MESSAGE_SUFFIX + "\"/>" + "</message>" + "<message name=\"" + operationName
							+ RESPONSE_MESSAGE_SUFFIX + "\">" + "<part name=\"body\" element=\""
							+ getPrefixedName(WSDL_XSD_PREFIX, operationName) + RESPONSE_MESSAGE_SUFFIX + "\"/>"
							+ "</message>");
				}
			}

			xml.write("<!-- ports -->");
			// for (UmlClass port : ports.values())
			// {
			// String portName = port.name();
			xml.write("<portType name=\"" + portName + "\">");
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					UmlOperation operation = (UmlOperation) item;
					String operationName = operation.name();
					xml.write("<operation name=\"" + operationName + "\">" + "<input message=\""
							+ getPrefixedName(WSDL_PREFIX, operationName) + REQUEST_MESSAGE_SUFFIX + "\"/>"
							+ "<output message=\"" + getPrefixedName(WSDL_PREFIX, operationName)
							+ RESPONSE_MESSAGE_SUFFIX + "\"/>" + "</operation>");
				}
			}
			xml.write("</portType>");
			// }

			xml.write("<!-- bindings -->");
			// for (UmlClass port : ports.values())
			// {
			// String portName = port.name();
			xml.write("<binding name=\"" + portName + "Soap\" type=\"" + getPrefixedName(WSDL_PREFIX, portName) + "\">"
					+ "<wsp:PolicyReference URI=\"#" + WSP_POLICY + "\"/>"
					+ "<soap:binding style=\"document\" transport=\"" + SOAP_HTTP_BINDING_URI + "\"/>");
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					UmlOperation oper = (UmlOperation) item;
					String operationName = oper.name();
					xml.write("<operation name=\"" + operationName + "\">" + "<soap:operation soapAction=\"" + WSDLURI
							+ "/" + portName + "/" + operationName + "\"/>" + "<input>"
							+ "	<soap:body use=\"literal\"/>" + "</input>" + "<output>"
							+ "	<soap:body use=\"literal\"/>" + "</output>" + "</operation>");
				}
			}
			xml.write("</binding>");
			// }
			xml.write(
					"<!-- services not defined here...defined in an implementation-specific WSDL that imports this one -->"
							+ "</definitions>");
			xml.close();
		}
	}

	/** exports XML catalog file */
	private static void exportXMLCatalog(String xmlDir, Set<String> CodeListNamespaces) throws IOException {
		FileWriter xml;
		UmlCom.trace("Generating XML catalog");
		xml = new FileWriter(Paths.get(xmlDir, XML_CATALOG_FILE).toFile());
		xml.write(XML_HEADER + XML_ATTRIBUTION + XML_CATALOG_HEADER + "<catalog prefer=\"public\" "
				+ NAMESPACE_ATTRIBUTE + "=\"" + XML_CATALOG_URI + "\">\n");
		for (Entry<String, String> entry : Prefixes.entrySet()) {
			String prefix = entry.getKey();
			String schemaURI = Prefixes.get(prefix);
			Namespace ns = Namespaces.get(schemaURI);
			if (isExternalPrefix(prefix))
				xml.write("<uri name=\"" + schemaURI + "\" uri=\"" + externalSchemaURL.get(schemaURI) + "\"/>\n");
			else if (ns.referenceClassView == null)
				xml.write("<uri name=\"" + schemaURI + "\" uri=\"" + ns.filepath + "\"/>\n");
		}
		for (String codeList : CodeListNamespaces)
			xml.write("<uri name=\"" + getExtensionSchema(codeList) + "\" uri=\"" + codeList + GC_FILE_TYPE + "\"/>\n");
		xml.write(
				"<nextCatalog  catalog=\"" + Paths.get(NIEM_DIR, XML_CATALOG_FILE).toString() + "\" />\n</catalog>\n");
		xml.close();
	}

	/** filter non-ASCII characters */
	private static String filterASCII(String string) {
		return string.replaceAll("[^\\p{ASCII}]", "");
	}

	/** filter illegal characters in enumerations */
	private static String filterEnum(String string) {
		return string.replaceAll(CODELIST_DELIMITER + CODELIST_DEFINITION_DELIMITER, "");
	}

	/** filter illegal characters in XML names */
	// private static String filterNameToken(String string) {
	// return string.replaceAll("[^-._:A-Za-z0-9]", "");
	// }

	/** filter illegal characters in XML prefix */
	private static String filterPrefix(String prefix) {
		return prefix.replaceAll("[^-._A-Za-z0-9]", "");
	}

	/** filter illegal characters in XML strings */
	private static String filterQuotes(String string) {
		return string.replaceAll("&", "&amp;").replaceAll("\"", "&quot;").replaceAll("\r|\n","");
	}

	/** filter whitespace */
	// private static String filterToken(String string) {
	// return string.replaceAll("\\s", "");
	// }

	/** filter illegal characters in UML elements */
	private static String filterUMLElement(String string) {
		return string.replaceAll("[^A-Za-z0-9_@#$-`~,.<?;:'\"\\\\]", "");
	}

	/** filter illegal characters in UML types */
	private static String filterUMLType(String string) {
		return string.replaceAll("[^A-Za-z0-9_@#$`~,.<?;:'\"\\\\]", "");
	}

	/** return attribute group related to a type */
	private static UmlClass getAttributeGroup(UmlClass type) {
		for (UmlItem item : type.children())
			if (item.kind() == anItemKind.aRelation) {
				UmlRelation r = (UmlRelation) item;
				if (r.relationKind() == aRelationKind.aDirectionalAggregation)
					return r.roleType();
			}
		// trace("getAttributeGroup: error - attribute group not found for " +
		// type.name());
		return null;
	}

	/** return find base type related to a type */
	private static UmlClass getBaseType(UmlClass type) {
		for (UmlItem item : type.children())
			if (item.kind() == anItemKind.aRelation) {
				UmlRelation r = (UmlRelation) item;
				if (r.relationKind() == aRelationKind.aGeneralisation)
					return r.roleType();
			}
		// trace("getBaseType: error - base type not found for " + type.name());
		return null;
	}

	/** returns the html for a column */
	private static String getColumnHtml(String value, String bgcolor, String fgcolor, Boolean wordwrap) {
		String style = wordwrap ? "word-wrap: break-word" : "";
		return "<td  style=\"" + style + "\" bgcolor=\"" + bgcolor + "\"><font color = \"" + fgcolor + "\">" + value
				+ "</font></td>";
	}

	/** return the default schema URI for the current file */
	private static String getDefaultSchemaURI(String filename, Document doc) {
		String defaultSchemaURI = doc.lookupNamespaceURI(null);
		if (defaultSchemaURI == null) {
			// trace("getDefaultSchemaURI: no default namespace found in " + filename);
			defaultSchemaURI = LOCAL_PREFIX;
		}
		return defaultSchemaURI;
	}

	/** return an element in schema schemaURI with name elementName */
	private static UmlClassInstance getElement(UmlPackage modelPackage, String schemaURI, String elementName) {
		String uri = getURI(schemaURI, elementName);
		if (modelPackage == null)
			modelPackage = isNiemPrefix(getPrefix(elementName)) ? subsetPackage : extensionPackage;
		if (modelPackage == referencePackage)
			return (UmlClassInstance) NiemElements.get(uri);
		else if (modelPackage == subsetPackage)
			return (UmlClassInstance) SubsetElements.get(uri);
		else if (modelPackage == extensionPackage)
			return (UmlClassInstance) ExtensionElements.get(uri);
		UmlCom.trace("findElement: error - element " + elementName + " not in schema " + schemaURI);
		return null;
	}

	/** return an element in modelPackage with uri elementUri */
	private static UmlClassInstance getElementByURI(UmlPackage modelPackage, String elementUri) {
		if (modelPackage == referencePackage)
			return (UmlClassInstance) NiemElements.get(elementUri);
		return (SubsetElements.containsKey(elementUri)) ? (UmlClassInstance) SubsetElements.get(elementUri)
				: (UmlClassInstance) ExtensionElements.get(elementUri);
	}

	/** returns an element in type and checks the multiplicity */
	private static UmlAttribute getElementInType(UmlClass type, String elementInTypeName, String multiplicity) {
		for (UmlItem item : type.children())
			if (item.kind() == anItemKind.anAttribute && item.name().equals(elementInTypeName)) {
				String previousMultiplicity = ((UmlAttribute) item).multiplicity();
				if (!previousMultiplicity.equals(multiplicity))
					UmlCom.trace("getElementInType:  error - " + getPrefixedName(type) + "/" + elementInTypeName
							+ " has conflicting multiplicities " + previousMultiplicity + " and " + multiplicity);
				return (UmlAttribute) item;
			}
		return null;
	}

	/** return an element in type in modelPackage with uri typeURI */
	private static List<UmlClassInstance> getElementsInType(UmlPackage modelPackage, String typeURI) {
		List<UmlClassInstance> elementInTypeList = null;
		if (modelPackage == referencePackage) {
			elementInTypeList = (List<UmlClassInstance>) (NiemElementsInType.get(typeURI));
			if (elementInTypeList == null) {
				elementInTypeList = new ArrayList<UmlClassInstance>();
				NiemElementsInType.put(typeURI, elementInTypeList);
			}
		} else if (modelPackage == subsetPackage) {
			elementInTypeList = (List<UmlClassInstance>) (SubsetElementsInType.get(typeURI));
			if (elementInTypeList == null) {
				elementInTypeList = new ArrayList<UmlClassInstance>();
				SubsetElementsInType.put(typeURI, elementInTypeList);
			}
		} else if (modelPackage == extensionPackage) {
			elementInTypeList = (List<UmlClassInstance>) (ExtensionElementsInType.get(typeURI));
			if (elementInTypeList == null) {
				elementInTypeList = new ArrayList<UmlClassInstance>();
				ExtensionElementsInType.put(typeURI, elementInTypeList);
			}
		}
		return elementInTypeList;
	}

	/** returns an extension schema URI */
	private static String getExtensionSchema(String prefix) {
		return getProperty(IEPD_URI_PROPERTY) + prefix;
	}

	/** returns a line of the NIEM mapping spreadsheet in CSV format */
	private static String[] getItemCsv(UmlItem item) {
		String[] nextLine = new String[NIEM_STEREOTYPE_MAP.length];
		try {
			// Export Class and Property
			switch (item.kind().value()) {
			case anItemKind._aClass:
				nextLine[0] = item.name();
				nextLine[1] = "";
				nextLine[2] = "";
				break;
			case anItemKind._anAttribute:
				nextLine[0] = item.parent().name();
				nextLine[1] = item.name();
				UmlAttribute a = (UmlAttribute) item;
				nextLine[2] = a.multiplicity();
				break;
			case anItemKind._aRelation:
				nextLine[0] = item.parent().name();
				UmlRelation r = (UmlRelation) item;
				nextLine[1] = r.name();
				nextLine[2] = r.multiplicity();
				break;
			case anItemKind._aClassInstance:
				nextLine[0] = "";
				nextLine[1] = item.name();
				nextLine[2] = "";
				break;
			default:
				nextLine[0] = item.parent().name();
				nextLine[1] = item.name();
				nextLine[2] = "";
				break;
			}
		} catch (Exception e) {
			UmlCom.trace("itemCsv: error importing class, property multiplicity " + e.toString());
		}

		// Export Description
		nextLine[3] = item.description();

		// Export NIEM Mapping
		if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
			for (int column = 4; column < NIEM_STEREOTYPE_MAP.length; column++)
				nextLine[column] = item.propertyValue(getNiemProperty(column));

		return nextLine;
	}

	/** return JSON Pointer to an element with name elementName */
	private static String getJSONElement(String elementName, String localPrefix) {
		if (elementName == null)
			return "";
		String prefix = getPrefix(elementName);
		if (prefix == null)
			return "";
		if (isExternalPrefix(prefix))
			return "";
		else if (prefix.equals(localPrefix))
			return "#/properties/" + elementName;
		else if (isNiemPrefix(prefix) && !isNiemPrefix(localPrefix))
			return NIEM_DIR + "/" + prefix + JSON_SCHEMA_FILE_TYPE + "#/properties/" + elementName;
		else if (!isNiemPrefix(prefix) && isNiemPrefix(localPrefix))
			return "../" + prefix + JSON_SCHEMA_FILE_TYPE + "#/properties/" + elementName;
		else
			return "" + prefix + JSON_SCHEMA_FILE_TYPE + "#/properties/" + elementName;
	}

	/**
	 * return JSON property description of an element with name elementName and
	 * cardinality minOccurs and maxOccurs
	 */
	private static String getJSONProperty(String elementName, String minoccurs, String maxoccurs, String localPrefix) {
		String property = "";
		property += "\"" + elementName + "\": {\n";
		if (maxoccurs.equals("1"))
			property += "\"$ref\": \"" + getJSONElement(elementName, localPrefix) + "\"\n";
		else {
			property += "\"oneOf\": [";
			if (minoccurs.equals("0") || minoccurs.equals("1")) {
				property += "{\n" + "\"$ref\": \"" + getJSONElement(elementName, localPrefix) + "\"\n" + "},\n";
			}
			property += "{\n" + "\"items\": {\n" + "\"$ref\": \"" + getJSONElement(elementName, localPrefix) + "\"\n"
					+ "},\n" + "\n\"minItems\": " + minoccurs + ",\n";
			if (!maxoccurs.equals("unbounded"))
				property += "\n\"maxItems\": " + maxoccurs + ",\n";
			property += "\"type\": \"array\"\n" + "}\n" + "]\n";
		}
		property += "}";

		return property;
	}

	/** return JSON Pointer to a type with name typeName */
	private static String getJSONType(String typeName, String localPrefix) {
		if (typeName == null)
			return "";
		String prefix = getPrefix(typeName);
		if (prefix == null)
			return "";
		if (isExternalPrefix(prefix))
			return "";
		else if (prefix.equals(localPrefix))
			return "#/definitions/" + typeName;
		if (isNiemPrefix(prefix) && !isNiemPrefix(localPrefix))
			return NIEM_DIR + "/" + prefix + JSON_SCHEMA_FILE_TYPE + "#/definitions/" + typeName;
		else if (!isNiemPrefix(prefix) && isNiemPrefix(localPrefix))
			return "../" + prefix + JSON_SCHEMA_FILE_TYPE + "#/definitions/" + typeName;
		else
			return "" + prefix + JSON_SCHEMA_FILE_TYPE + "#/definitions/" + typeName;
	}

	/** return tagname from XML tag */
	private static String getName(String tagName) {
		if (tagName == null)
			return "";
		int i = tagName.indexOf(NAMESPACE_DELIMITER);
		String name = (i >= 0) ? tagName.substring(i + 1) : tagName;
		// return name.replaceAll("[^-._:A-Za-z0-9]", "");
		return name.replaceAll("[^-._:A-Za-z0-9@]", "");
	}

	/** return tagname for UmlItem item */
	private static String getName(UmlItem item) {
		return getName(item.name());
	}

	/**
	 * return namespace for schema schemaURI in model modelPackage; create it with
	 * prefix if doesn't exist
	 */
	private static UmlClassView getNamespace(UmlPackage modelPackage, String prefix, String schemaURI) {
		if (schemaURI == null || prefix == null)
			return null;
		Namespace ns = Namespaces.get(schemaURI);
		if (ns == null) {
			// create namespace
			ns = new Namespace(schemaURI);
			Namespaces.put(schemaURI, ns);
			trace("getNamespace: added namespace " + schemaURI);
		}

		String prefix2 = filterPrefix(prefix);
		if (!Prefixes.containsKey(prefix2)) {
			// create prefix
			Prefixes.put(prefix2, schemaURI);
			trace("getNamespace: added prefix " + prefix2 + " for " + schemaURI);
		}
		// select reference, subset or extension model
		if (modelPackage == null)
			modelPackage = isNiemPrefix(prefix) ? subsetPackage : extensionPackage;

		// return classview if it exists
		if (modelPackage == referencePackage) {
			if (ns.referenceClassView != null)
				return ns.referenceClassView;
		} else if (ns.nsClassView != null)
			return ns.nsClassView;

		// create classview
		String prefix3 = prefix2;
		UmlClassView namespaceClassView = null;
		int conflictCounter = 1;

		while (namespaceClassView == null) {
			try {
				namespaceClassView = UmlClassView.create(modelPackage, prefix3);
			} catch (Exception e) {
				UmlCom.trace("getNamespace: multiple namespace URIs for prefix " + prefix3 + " " + schemaURI + " and "
						+ Prefixes.get(prefix2));
				prefix3 = prefix2 + conflictCounter;
				conflictCounter++;
			}
		}
		setURI(namespaceClassView, schemaURI);
		// trace("getNamespace: added class view " + namespaceClassView.name());

		if (prefix != null)
			setPrefix(namespaceClassView, prefix2);

		if (modelPackage == referencePackage)
			ns.referenceClassView = namespaceClassView;
		else {
			ns.nsClassView = namespaceClassView;
			if (modelPackage == extensionPackage) {
				ns.nsClassView = namespaceClassView;
				ns.filepath = prefix2 + XSD_FILE_TYPE;
				namespaceClassView.set_PropertyValue(FILE_PATH_PROPERTY, ns.filepath);
			}
		}
		return namespaceClassView;
	}

	/**
	 * return the NIEM stereotype associated with a column in the NIEM mapping
	 * spreadsheet
	 */
	private static String getNiemProperty(int p) {
		return NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[p][1];
	}

	/** return NIEM version */
	private static String getNiemVersion() {
		String niemVersion = NIEM_VERSION_DEFAULT;

		String schemaURI = Prefixes.get("nc");
		//UmlCom.trace("NIEM URI: " + schemaURI);
		Matcher mat = Pattern.compile(".*niem-core/(.*)/").matcher(schemaURI);
		if (mat.find())
			niemVersion = mat.group(1);
		UmlCom.trace("NIEM version: " + niemVersion);
		return niemVersion;
	}

	/**
	 * return child package with name packageName in parentPackage; if it doesn't
	 * exist and create is true, create it
	 */
	private static UmlPackage getPackage(UmlPackage parentPackage, String packageName, boolean create) {
		for (UmlItem item : parentPackage.children()) {
			if (item.name().equals(packageName))
				if ((item.kind().value() == anItemKind._aPackage)) {
					return (UmlPackage) item;
				}
		}
		if (create) {
			trace("getPackage: Creating " + packageName);
			return UmlPackage.create(parentPackage, packageName);
		}
		return null;
	}

	/** return namespace prefix from XML tag */
	private static String getPrefix(String tagName) {
		if (tagName == null) {
			// trace("getPrefix: error - tagName is null");
			return null;
		}
		int i = tagName.indexOf(NAMESPACE_DELIMITER);
		if (i >= 0) {
			String prefix = tagName.substring(0, i).trim();
			return filterPrefix(prefix);
		} else
			return null;
	}

	/** return namespace prefix for UmlItem item */
	private static String getPrefix(UmlItem item) {
		String prefix = item.propertyValue(PREFIX_PROPERTY);
		if (prefix == null)
			return null;
		return filterPrefix(prefix);
	}

	/** return name with namespace prefix for an attribute with name tagName */
	private static String getPrefixedAttributeName(String prefix, String tagName) {
		return prefix + NAMESPACE_DELIMITER + ATTRIBUTE_PREFIX + tagName.replaceAll(ATTRIBUTE_PREFIX, "");
	}

	/** return name with namespace prefix for type or element with name tagName */
	private static String getPrefixedName(String prefix, String tagName) {
		return prefix + NAMESPACE_DELIMITER + tagName;
	}

	/** return name with namespace prefix for UmlItem item */
	private static String getPrefixedName(UmlItem item) {
		return getPrefix(item.parent()) + NAMESPACE_DELIMITER + item.name();
	}

	/** return project property with name propertyName */
	private static String getProperty(String propertyName) {
		return UmlBasePackage.getProject().propertyValue(propertyName);
	}

	/** return schemaURI for type or element with name tagname */
	private static String getSchemaURI(String tagName) {
		String prefix = getPrefix(tagName);
		if (prefix == null)
			// prefix = LOCAL_PREFIX;
			return null;
		String schemaURI = Prefixes.get(prefix);
		if (schemaURI == null)
			schemaURI = getExtensionSchema(prefix);
		return schemaURI;
	}

	/** return type in model modelPackage with schema schemaURI and name tagname */
	private static UmlClass getType(UmlPackage modelPackage, String schemaURI, String typeName) {

		// if model package not defined, default to subset or extension based on prefix
		if (modelPackage == null)
			modelPackage = isNiemPrefix(getPrefix(typeName)) ? subsetPackage : extensionPackage;

		// return cached type
		String uri = getURI(schemaURI, typeName);
		if (modelPackage == referencePackage)
			return (UmlClass) NiemTypes.get(uri);
		else if (modelPackage == subsetPackage)
			return (UmlClass) SubsetTypes.get(uri);
		else if (modelPackage == extensionPackage)
			return (UmlClass) ExtensionTypes.get(uri);
		return null;
	}

	/** return URI of a item in schemaURI with name itemName */
	private static String getURI(String schemaURI, String itemName) {
		itemName.replaceAll("[^-._:A-Za-z0-9]", "");
		return schemaURI + HASH_DELIMITER + getName(itemName).replaceAll(HASH_DELIMITER, "");
	}

	/** return URI of an item */
	private static String getURI(UmlItem item) {
		return item.propertyValue(URI_PROPERTY);
	}

	/** hide item from documentation */
	private static void hideItem(UmlItem item) {
		item.known = false;
		for (UmlItem child : item.children())
			hideItem(child);
	}

	/** hide reference model from documentation */
	protected static void hideReferenceModel() {
		hideItem(referencePackage);
	}

	/** return code values and descriptions from enumerations in schema */
	private static String importCodeList(NodeList elist) {
		String codeList = "";
		XPathExpression xe = null;
		if (_IMPORT_CODE_DESCRIPTIONS)
			try {
				xe = xPath.compile("xs:annotation[1]/xs:documentation[1]");
			} catch (XPathExpressionException e) {
				UmlCom.trace("getCodeList: exception " + e.toString());
			}

		for (int j = 0; j < elist.getLength(); j++) {
			Element enumElement = (Element) elist.item(j);
			String value = filterEnum(filterASCII(enumElement.getAttribute("value")));
			String codeDescription = null;
			if (_IMPORT_CODE_DESCRIPTIONS)
				try {
					codeDescription = filterEnum(filterASCII(xe.evaluate(enumElement)));
				} catch (Exception e) {
					UmlCom.trace("getCodeList: error - cannot import code descriptions " + e.toString());
				}
			if (codeDescription != null && !codeDescription.equals("")) {
				codeList += value + CODELIST_DEFINITION_DELIMITER + codeDescription + CODELIST_DELIMITER + " ";
			} else
				codeList += value + CODELIST_DELIMITER + " ";
		}
		return codeList;
	}

	/** import NIEM mapping spreadsheet in CSV format */
	@SuppressWarnings("unchecked")
	public static void importCsv(String filename) {

		cacheExternalSchemas();
		// cache UML classes
		Map<String, UmlClass> UMLClasses = new HashMap<String, UmlClass>();
		Map<String, UmlClassInstance> UMLInstances = new HashMap<String, UmlClassInstance>();
		Iterator<UmlItem> it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				if (item.kind() == anItemKind.aClass) {
					UmlClass c = (UmlClass) item;
					if (!UMLClasses.containsKey(c.name()))
						UMLClasses.put(c.name(), c);
				} else if (item.kind() == anItemKind.aClassInstance) {
					UmlClassInstance ci = (UmlClassInstance) item;
					if (!UMLInstances.containsKey(ci.name()))
						UMLInstances.put(ci.name(), ci);
				}
		}
		try {

			CSVReader reader = new CSVReader(new FileReader(filename));
			String[] nextLine;

			// read header
			reader.readNext();

			// read mappings
			while ((nextLine = reader.readNext()) != null) {
				String className = nextLine[0].trim();
				String attributeName = nextLine[1].trim();

				if (!className.equals("")) {
					UmlClass type = UMLClasses.get(className);
					if (type != null) {
						if (attributeName.equals("")) {
							// import NIEM mapping to class
							trace("importCsv: importing NIEM mapping for " + className);
							for (int column = 4; column < NIEM_STEREOTYPE_MAP.length
									&& column < nextLine.length; column++)
								type.set_PropertyValue(getNiemProperty(column), nextLine[column]);
						} else {
							// import NIEM Mapping to attribute
							for (UmlItem item : type.children())
								if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)
										&& (item.name().equals(attributeName)))
									for (int column = 4; column < NIEM_STEREOTYPE_MAP.length
											&& column < nextLine.length; column++)
										item.set_PropertyValue(getNiemProperty(column), nextLine[column]);
						}
					}
				} else if (!attributeName.equals("")) {
					UmlClassInstance element = UMLInstances.get(attributeName);
					if (element != null) {
						// import NIEM mapping to class
						trace("importCsv: importing NIEM mapping for " + attributeName);
						for (int column = 4; column < NIEM_STEREOTYPE_MAP.length && column < nextLine.length; column++)
							element.set_PropertyValue(getNiemProperty(column), nextLine[column]);
					}
				}
			}
			reader.close();
		} catch (FileNotFoundException e) {
			UmlCom.trace("importCsv: error - file not found" + e.toString());
		} catch (IOException e) {
			UmlCom.trace("importCsv: error - IO exception" + e.toString());
		}
	}

	/** import NIEM reference model elements into HashMaps and return namespace */
	private static Namespace importElements(DocumentBuilder db, String filename) {
		// trace("importElements: importing elements from schema " + filename);
		String filename2 = "\n" + filename + "\n";
		Document doc = null;
		Namespace ns = null;
		XPathExpression xe = null;
		try {
			// parse the schema
			doc = db.parse(new File(filename));
			xPath.setNamespaceContext(new NamespaceResolver(doc, true));
			ns = importNamespaces(doc);

			// compile XPath queries
			xe = xPath.compile("xs:annotation[1]/xs:documentation[1]");
		} catch (Exception e) {
			UmlCom.trace(filename2 + "importElements: error " + e.toString());
			filename2 = "";
		}
		// get target and default prefixes
		String targetPrefix = getPrefix(ns.referenceClassView);
		String defaultSchemaURI = getDefaultSchemaURI(filename, doc);
		String defaultPrefix = getPrefix(Namespaces.get(defaultSchemaURI).referenceClassView);

		// import elements
		// trace("importElement: importing elements");
		NodeList elementList = null;
		try {
			elementList = (NodeList) xPath.evaluate("xs:element[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace("importElements: error - cannot import element " + e.toString());
		}

		for (int elementIndex = 0; elementIndex < elementList.getLength(); elementIndex++) {
			Element elementElement = (Element) elementList.item(elementIndex);
			String elementName = elementElement.getAttribute("name");
			if (getPrefix(elementName) == null)
				elementName = getPrefixedName(targetPrefix, elementName);
			String abstractAttribute = elementElement.getAttribute("abstract");
			String baseTypeSchemaURI = null;
			String baseTypeName = null;
			if (!abstractAttribute.equals("true")) {
				baseTypeName = elementElement.getAttribute("type");
				if (baseTypeName.equals(""))
					baseTypeName = null;
				else if (getPrefix(baseTypeName) == null)
					baseTypeName = getPrefixedName(defaultPrefix, baseTypeName);
				baseTypeSchemaURI = doc.lookupNamespaceURI(getPrefix(baseTypeName));
				if (baseTypeSchemaURI == null)
					baseTypeSchemaURI = getSchemaURI(baseTypeName);
				if (baseTypeName != null && baseTypeSchemaURI == null && getPrefix(baseTypeName) == null) {
					baseTypeSchemaURI = XSD_URI;
					baseTypeName = getPrefixedName(XSD_PREFIX, baseTypeName);
				}
			}
			try {
				addElement(referencePackage, ns.schemaURI, elementName, baseTypeSchemaURI, baseTypeName,
						xe.evaluate(elementElement), null);
			} catch (Exception e) {
				UmlCom.trace("importElements: error - cannot import element " + e.toString());
			}
		}

		// import attributes
		// trace("importElement: importing attributes");
		NodeList attributeList = null;
		try {
			attributeList = (NodeList) xPath.evaluate("xs:attribute[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace("importElements: error - cannot import attributes " + e.toString());
		}
		for (int attributeIndex = 0; attributeIndex < attributeList.getLength(); attributeIndex++) {
			Element attribute = (Element) attributeList.item(attributeIndex);
			String attributeName = attribute.getAttribute("name");
			String attributePrefix = getPrefix(attributeName);
			if (attributePrefix == null)
				attributePrefix = targetPrefix;
			attributeName = getPrefixedAttributeName(attributePrefix, getName(attributeName));
			// trace("importElements: adding attribute " + elementName);
			String codeList = "";
			String baseTypeSchemaURI = null;
			String baseTypeName = attribute.getAttribute("type");
			if (baseTypeName.equals(""))
				try {
					Element restriction = (Element) xPath.evaluate(".//xs:simpleType/xs:restriction[1][@base]",
							attribute, XPathConstants.NODE);
					if (restriction != null) {
						baseTypeName = restriction.getAttribute("base");
						NodeList eList = (NodeList) xPath.evaluate("xs:enumeration[@value]", restriction,
								XPathConstants.NODESET);
						codeList = importCodeList(eList);
					}
				} catch (Exception e) {
					UmlCom.trace(filename + "\nimportElements: error importing base types for attribute "
							+ attributeName + " " + e.toString());
				}
			if (baseTypeName == null || baseTypeName.equals(""))
				baseTypeName = null;
			else {
				if (getPrefix(baseTypeName) == null)
					baseTypeName = getPrefixedName(defaultPrefix, baseTypeName);
				baseTypeSchemaURI = doc.lookupNamespaceURI(getPrefix(baseTypeName));
				if (baseTypeSchemaURI == null)
					baseTypeSchemaURI = getSchemaURI(baseTypeName);
				if (baseTypeName != null && baseTypeSchemaURI == null && getPrefix(baseTypeName) == null) {
					baseTypeSchemaURI = XSD_URI;
					baseTypeName = getPrefixedName(XSD_PREFIX, baseTypeName);
				}
			}
			UmlClassInstance element = null;
			try {

				element = addElement(referencePackage, ns.schemaURI, attributeName, baseTypeSchemaURI, baseTypeName,
						xe.evaluate(attribute), null);
			} catch (Exception e) {
				UmlCom.trace(filename2 + "importElements: error - cannot add attribute " + attributeName + " of type "
						+ baseTypeName + " " + e.toString());
				filename2 = "";
			}
			if (element != null) {
				NiemElements.put(getURI(element), element);
				if (!codeList.equals(""))
					element.set_PropertyValue(CODELIST_PROPERTY, codeList);
			}
		}
		return ns;
	}

	/**
	 * import NIEM reference model elements in Types into HashMaps and return
	 * namespace
	 */
	private static Namespace importElementsInTypes(DocumentBuilder db, String filename) {
		// trace("importElementsInTypes: importing elements in types from schema " +
		// filename);
		// String filename2 = "\n" + filename + "\n";
		Document doc = null;
		Namespace ns = null;
		try {
			// parse the schema
			doc = db.parse(new File(filename));
			xPath.setNamespaceContext(new NamespaceResolver(doc, true));
			ns = importNamespaces(doc);
		} catch (Exception e) {
			UmlCom.trace(filename + "\nimportElementsInTypes: error parsing the schema " + e.toString());
		}

		// get target and default prefixes
		String targetPrefix = getPrefix(ns.referenceClassView);
		String defaultSchemaURI = getDefaultSchemaURI(filename, doc);
		String defaultPrefix = getPrefix(Namespaces.get(defaultSchemaURI).referenceClassView);

		// import attributes in attribute groups
		// trace("importElementsInTypes: import attributes in attribute groups");
		Node root = null;
		NodeList attributeGroupList = null;
		try {
			root = doc.getDocumentElement();
			attributeGroupList = (NodeList) xPath.evaluate("xs:attributeGroup[@name]", root, XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace(filename + "\nimportElementsInTypes: error parsing the schema " + e.toString());
		}

		for (int attributeGroupIndex = 0; attributeGroupIndex < attributeGroupList.getLength(); attributeGroupIndex++) {
			Element attributeGroupElement = (Element) attributeGroupList.item(attributeGroupIndex);
			String attributeGroupName = attributeGroupElement.getAttribute("name");
			if (getPrefix(attributeGroupName) == null)
				attributeGroupName = getPrefixedAttributeName(targetPrefix, attributeGroupName);
			UmlClass attributeGroup = getType(referencePackage, ns.schemaURI, attributeGroupName);
			if (attributeGroup == null) {
				UmlCom.trace("importElementsInType: error - attribute group " + attributeGroupName
						+ " not in reference model");
				continue;
			}
			NodeList attributeList = null;
			try {
				attributeList = (NodeList) xPath.evaluate(".//xs:attribute[@ref]", attributeGroupElement,
						XPathConstants.NODESET);
			} catch (Exception e) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error parsing the schema " + e.toString());
			}
			for (int attributeIndex = 0; attributeIndex < attributeList.getLength(); attributeIndex++) {
				Element attributeElement = (Element) attributeList.item(attributeIndex);
				String attributeName = attributeElement.getAttribute("ref");
				String attributePrefix = getPrefix(attributeName);
				if (attributePrefix == null)
					attributePrefix = defaultPrefix;
				attributeName = getPrefixedAttributeName(attributePrefix, getName(attributeName));
				String multiplicity = (attributeElement.getAttribute("use")).equals("optional") ? "0,1" : "1,1";
				String attributeSchemaURI = doc.lookupNamespaceURI(getPrefix(attributeName));
				if (attributeSchemaURI == null)
					attributeSchemaURI = getSchemaURI(attributeName);
				if (attributeSchemaURI == null) {
					UmlCom.trace("addElementInType: error - prefix for attribute " + attributeName + " not in model");
					continue;
				}
				UmlClassInstance element = getElement(referencePackage, attributeSchemaURI, getName(attributeName));
				if (element == null) {
					UmlCom.trace("importElementsInType: error - attribute " + attributeName + " not in model");
					continue;
				}
				addElementInType(attributeGroup, element, multiplicity);
			}
		}

		// import base types for simple types (codes)
		// trace("importElementsInTypes: import base types for simple types (codes)");
		NodeList simpleTypeNodeList = null;
		try {
			simpleTypeNodeList = (NodeList) xPath.evaluate("xs:simpleType[@name]/xs:restriction[1][@base]", root,
					XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace(
					filename + "\nimportElementsInTypes: error importing base types for simple types " + e.toString());
		}
		for (int elementIndex = 0; elementIndex < simpleTypeNodeList.getLength(); elementIndex++) {
			Element restrictionElement = (Element) simpleTypeNodeList.item(elementIndex);
			Element typeElement = (Element) restrictionElement.getParentNode();
			String typeName = typeElement.getAttribute("name");
			if (getPrefix(typeName) == null)
				typeName = getPrefixedName(targetPrefix, typeName);
			String baseTypeName = restrictionElement.getAttribute("base");
			if (getPrefix(baseTypeName) == null)
				baseTypeName = getPrefixedName(defaultPrefix, baseTypeName);
			UmlClass type = getType((UmlPackage) (ns.referenceClassView.parent()), ns.schemaURI, typeName);
			if (type == null)
				continue;
			UmlClass baseType = getType(referencePackage, doc.lookupNamespaceURI(getPrefix(baseTypeName)),
					baseTypeName);
			if (baseType == null)
				continue;
			relateBaseType(type, baseType);
		}

		// import base types and elements for complex types
		// trace("importElementsInTypes: import base types and elements for complex
		// types");
		NodeList complexTypeNodeList = null;
		try {
			complexTypeNodeList = (NodeList) xPath.evaluate("xs:complexType[@name]", root, XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace(filename + "\nimportElementsInTypes: error parsing types" + e.toString());
		}
		for (int elementIndex = 0; elementIndex < complexTypeNodeList.getLength(); elementIndex++) {
			Element typeElement = (Element) complexTypeNodeList.item(elementIndex);
			if (typeElement == null)
				continue;
			String typeName = typeElement.getAttribute("name");
			if (getPrefix(typeName) == null)
				typeName = getPrefixedName(targetPrefix, typeName);
			UmlClass type = getType((UmlPackage) (ns.referenceClassView.parent()), ns.schemaURI, typeName);
			if (type == null)
				continue;

			// import base types for complex types
			// trace("importElementsInTypes: import base types for complex types");
			NodeList baseTypeList = null;
			try {
				baseTypeList = (NodeList) xPath.evaluate(
						"xs:simpleContent[1]/xs:extension[1][@base] | xs:complexContent[1]/xs:extension[1][@base]",
						typeElement, XPathConstants.NODESET);
			} catch (Exception e) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error importing base types for complex types"
						+ e.toString());
			}
			for (int baseTypeIndex = 0; baseTypeIndex < baseTypeList.getLength(); baseTypeIndex++) {
				Element baseTypeElement = (Element) baseTypeList.item(baseTypeIndex);
				String baseTypeName = baseTypeElement.getAttribute("base");
				if (getPrefix(baseTypeName) == null)
					baseTypeName = getPrefixedName(defaultPrefix, baseTypeName);
				UmlClass baseType = getType(referencePackage, doc.lookupNamespaceURI(getPrefix(baseTypeName)),
						baseTypeName);
				if (baseType == null)
					continue;
				relateBaseType(type, baseType);
			}

			// import attribute groups in type
			// trace("importElementsInTypes: import attributes groups in types");
			NodeList attributeGroupInTypeNodeList = null;
			try {
				attributeGroupInTypeNodeList = (NodeList) xPath.evaluate(".//xs:attributeGroup[@ref]", typeElement,
						XPathConstants.NODESET);
			} catch (Exception e) {
				UmlCom.trace(filename + "\nimportElementsInTypes:error importing attributeGroup in complex types"
						+ e.toString());
			}
			for (int attributeGroupIndex = 0; attributeGroupIndex < attributeGroupInTypeNodeList
					.getLength(); attributeGroupIndex++) {
				Element attributeGroupElement = (Element) attributeGroupInTypeNodeList.item(attributeGroupIndex);
				String attributeGroupName = attributeGroupElement.getAttribute("ref");
				if (getPrefix(attributeGroupName) == null)
					attributeGroupName = getPrefixedName(defaultPrefix, attributeGroupName);
				String prefix = getPrefix(attributeGroupName);
				String schemaURI = (prefix == null) ? ns.schemaURI : doc.lookupNamespaceURI(prefix);
				UmlClass attributeGroupType = getType(referencePackage, schemaURI,
						getPrefixedAttributeName(getPrefix(attributeGroupName), getName(attributeGroupName)));
				if (attributeGroupType == null)
					continue;
				relateAttributeGroup(type, attributeGroupType);
			}

			// import attributes in type
			// trace("importElementsInTypes: import attributes in types");
			NodeList attributeInTypeNodeList = null;
			try {
				attributeInTypeNodeList = (NodeList) xPath.evaluate(".//xs:attribute[@ref]", typeElement,
						XPathConstants.NODESET);
			} catch (Exception re) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error importing attributes in type " + re.toString());
			}
			for (int attributeIndex = 0; attributeIndex < attributeInTypeNodeList.getLength(); attributeIndex++) {
				Element attributeElement = (Element) attributeInTypeNodeList.item(attributeIndex);
				String attributeName = attributeElement.getAttribute("ref");
				if (getPrefix(attributeName) == null)
					attributeName = getPrefixedName(defaultPrefix, attributeName);
				String multiplicity = (attributeElement.getAttribute("use").equals("optional")) ? "0,1" : "1,1";
				UmlClassInstance element = getElement(referencePackage,
						doc.lookupNamespaceURI(getPrefix(attributeName)),
						getPrefixedName(getPrefix(attributeName), ATTRIBUTE_PREFIX + getName(attributeName)));
				addElementInType(type, element, multiplicity);
				// trace("importElementsInTypes: imported attribute :" + attributeName + " in
				// group " + typeName);
			}

			// import elements in type
			// trace("importElementsInTypes: import elements in types");
			NodeList elementInTypeNodeList = null;
			try {
				elementInTypeNodeList = (NodeList) xPath.evaluate(".//xs:sequence[1]/xs:element[@ref]", typeElement,
						XPathConstants.NODESET);
			} catch (Exception e) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error importing elements in type " + e.toString());
			}
			String elementName = null;
			try {
				for (int elementInTypeIndex = 0; elementInTypeIndex < elementInTypeNodeList
						.getLength(); elementInTypeIndex++) {
					Element elementElement = (Element) elementInTypeNodeList.item(elementInTypeIndex);
					elementName = elementElement.getAttribute("ref");
					// trace("importElementsInTypes: adding element " + elementName + " to type " +
					// typeName);
					if (getPrefix(elementName) == null)
						elementName = getPrefixedName(defaultPrefix, elementName);
					String minOccurs = elementElement.getAttribute("minOccurs");
					if (minOccurs.equals(""))
						minOccurs = "1";
					String maxOccurs = elementElement.getAttribute("maxOccurs");
					if (maxOccurs.equals(""))
						maxOccurs = "1";
					String multiplicity = minOccurs + "," + maxOccurs;
					String elementSchemaURI = doc.lookupNamespaceURI(getPrefix(elementName));
					if (elementSchemaURI == null)
						elementSchemaURI = getSchemaURI(elementName);
					if (elementSchemaURI == null) {
						UmlCom.trace(
								"importElementsInType: error - prefix for element " + elementName + " not in model");
						continue;
					}
					UmlClassInstance element = getElement(referencePackage, elementSchemaURI, elementName);
					if (element == null) {
						UmlCom.trace("importElementsInType: error - element " + getURI(elementSchemaURI, elementName)
								+ " not in reference model");
						continue;
					}
					addElementInType(type, element, multiplicity);
					// trace("importElementsInTypes: added element " + elementName + " in type " +
					// typeName);

				}
			} catch (Exception re) {
				UmlCom.trace(filename + "\nimportElementsInTypes: error importing element " + elementName + " in type "
						+ typeName + " " + re.toString());
			}
		}
		return ns;
	}

	/** import namespaces and return target namespace */
	private static Namespace importNamespaces(Document doc) {
		NamedNodeMap nslist = doc.getDocumentElement().getAttributes();
		for (int nsIndex = 0; nsIndex < nslist.getLength(); nsIndex++) {
			Node attributeNode = nslist.item(nsIndex);
			String attributeNodeName = attributeNode.getNodeName();
			if (attributeNodeName.startsWith(NAMESPACE_ATTRIBUTE)) {
				String prefix = (attributeNodeName.equals(NAMESPACE_ATTRIBUTE)) ? attributeNode.getNodeValue()
						: attributeNodeName.substring(6);
				getNamespace(referencePackage, prefix, attributeNode.getNodeValue());
			}
		}

		String schemaURI = null;
		Namespace ns = null;
		try {
			// get target namespace
			schemaURI = xPath.evaluate("xs:schema/@targetNamespace", doc);
			// schemaURI = doc.lookupNamespaceURI(null);
			ns = Namespaces.get(schemaURI);
			if (ns == null)
				return Namespaces.get(LOCAL_PREFIX);
			// set namespace description
			ns.referenceClassView
					.set_Description(xPath.evaluate("xs:schema/xs:annotation[1]/xs:documentation[1]", doc));
		} catch (Exception e) {
			UmlCom.trace("importNamespaces: error " + e.toString());
		}
		return ns;
	}

	/**
	 * import NIEM reference model into HashMaps to support validation of NIEM
	 * elements and types
	 */
	public static void importSchemaDir(String dir, Boolean includeEnums) throws IOException {

		// cache reference model
		cacheModel(referencePackage);
		cacheExternalSchemas();

		// Configure DOM
		Path path = FileSystems.getDefault().getPath(dir);
		String importPath = path.toString();

		int passes = (includeEnums) ? 4 : 3;

		// Walk directory to import in passes (0: types, 1: elements, 2:
		// elements in types, 3: enumerations
		for (importPass = 0; importPass < passes; importPass++) {
			switch (NiemTools.importPass) {
			case 0:
				UmlCom.trace("\nImporting types");
				break;
			case 1:
				UmlCom.trace("\nImporting elements");
				break;
			case 2:
				UmlCom.trace("\nImporting elements and attributes in types");
				break;
			}
			Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
				@Override
				public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
					// Configure DOM
					DocumentBuilder db = null;
					DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
					docBuilderFactory.setNamespaceAware(true);
					try {
						db = docBuilderFactory.newDocumentBuilder();
					} catch (ParserConfigurationException e) {
						UmlCom.trace("importSchemaDir: error configuring parser " + e.toString());
					}

					String filename = file.toString();
					String filepath1 = filename.replaceFirst(java.util.regex.Matcher.quoteReplacement(importPath), "");
					String filepath = filepath1.replaceAll(java.util.regex.Matcher.quoteReplacement("\\"), "/");
					if (filename.endsWith(XSD_FILE_TYPE)) {
						UmlCom.trace("Importing " + filepath);
						switch (NiemTools.importPass) {
						case 0:
							Namespace ns = importTypes(db, filename);
							ns.referenceClassView.set_PropertyValue(FILE_PATH_PROPERTY, NIEM_DIR + filepath);
							break;
						case 1:
							importElements(db, filename);
							break;
						case 2:
							importElementsInTypes(db, filename);
							break;
						}
					}
					return FileVisitResult.CONTINUE;
				}
			});
		}

		// Sorting
		UmlCom.trace("Sorting namespaces");
		referencePackage.sort();

		UmlCom.trace("Namespaces: " + Namespaces.size());
		UmlCom.trace("Types: " + NiemTypes.size());
		UmlCom.trace("Elements: " + NiemElements.size());
	}

	/** import NIEM reference model types into HashMaps and return namespace */
	private static Namespace importTypes(DocumentBuilder db, String filename) {
		// trace("importTypes: importing types from schema " + filename);
		String filename2 = "\n" + filename + "\n";
		Namespace ns = null;
		Document doc = null;
		XPathExpression xe = null;
		XPathExpression xe1 = null;
		try {
			// parse the schema
			doc = db.parse(new File(filename));
			xPath.setNamespaceContext(new NamespaceResolver(doc, true));
			ns = importNamespaces(doc);

			// compile XPath queries
			xe = xPath.compile("xs:annotation[1]/xs:documentation[1]");
			xe1 = xPath.compile("xs:restriction[1]/xs:enumeration");
		} catch (Exception re) {
			UmlCom.trace(filename2 + "importTypes: error " + re.toString());
			filename2 = "";
		}
		// get target and default prefixes
		String targetPrefix = getPrefix(ns.referenceClassView);

		// import types
		NodeList typeList = null;
		try {
			typeList = (NodeList) xPath.evaluate("xs:complexType|xs:simpleType[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace(filename2 + "importTypes: error - cannot parse types " + e.toString());
		}

		for (int typeIndex = 0; typeIndex < typeList.getLength(); typeIndex++) {
			Element typeElement = (Element) typeList.item(typeIndex);
			String nodeType = typeElement.getNodeName();
			String typeName = typeElement.getAttribute("name");
			if (getPrefix(typeName) == null)
				typeName = getPrefixedName(targetPrefix, typeName);
			UmlClass type = null;
			try {
				type = addType(referencePackage, ns.schemaURI, typeName, xe.evaluate(typeElement), null);
			} catch (Exception e) {
				UmlCom.trace(filename2 + "importTypes: cannot add type " + typeName + " to schema " + ns.schemaURI + " "
						+ e.toString());
			}
			if (type == null)
				continue;
			if (nodeType == "xs:simpleType") {
				type.set_Stereotype("enum_pattern");
				// import enumerated values for simple types (codes)
				NodeList elist = null;
				try {
					elist = (NodeList) xe1.evaluate(typeElement, XPathConstants.NODESET);
				} catch (Exception e) {
					UmlCom.trace(filename2 + "importTypes: error - cannot import enumerations " + e.toString());
				}
				String codeList = importCodeList(elist);
				if (!codeList.equals(""))
					type.set_PropertyValue(CODELIST_PROPERTY, codeList);
			}
		}

		// import attribute groups
		NodeList attributeGroupList = null;
		try {
			attributeGroupList = (NodeList) xPath.evaluate("xs:attributeGroup[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
		} catch (XPathExpressionException e) {
			UmlCom.trace(filename2 + "importTypes: error - cannot parse attribute groups " + e.toString());
		}
		for (int attributeGroupIndex = 0; attributeGroupIndex < attributeGroupList.getLength(); attributeGroupIndex++) {
			Element attributeGroupElement = (Element) attributeGroupList.item(attributeGroupIndex);
			String attributeGroupName = attributeGroupElement.getAttribute("name");
			String attributeGroupPrefix = getPrefix(attributeGroupName);
			if (attributeGroupPrefix == null)
				attributeGroupPrefix = targetPrefix;
			attributeGroupName = getPrefixedAttributeName(attributeGroupPrefix, getName(attributeGroupName));
			try {
				addType(referencePackage, ns.schemaURI, attributeGroupName, xe.evaluate(attributeGroupElement), null);
			} catch (Exception e) {
				UmlCom.trace(filename2 + "importTypes: error - cannot add attribute group " + attributeGroupName + " "
						+ e.toString());
				filename2 = "";
			}
		}
		return ns;
	}

	/** returns true if the UML item is an attribute or attribute group */
	private static boolean isAttribute(UmlItem item) {
		return getName(item).startsWith(ATTRIBUTE_PREFIX);
	}

	/** return true if type or element has a prefix in an external schema */
	private static Boolean isExternalPrefix(String prefix) {
		if (prefix == null)
			return false;
		return externalPrefixes.contains(prefix);
	}

	/** return true if an element exists in reference model */
	private static Boolean isNiemElement(String elementName) {
		if ((elementName == null) || elementName.equals("") || elementName.equals("??")
				|| isExternalPrefix(getPrefix(elementName)))
			return false;
		return NiemElements.containsKey(getURI(getSchemaURI(elementName), elementName));
	}

	/** return true if an element in type exists in reference model */
	private static Boolean isNiemElementInType(String typeName, String elementName) {
		if (!isNiemType(typeName) || !isNiemElement(elementName))
			return false;
		UmlClassInstance element = getElement(referencePackage, getSchemaURI(elementName), elementName);
		List<UmlClassInstance> elementList = getElementsInType(referencePackage,
				getURI(getSchemaURI(typeName), typeName));
		for (UmlClassInstance element2 : elementList)
			if (element.equals(element2))
				return true;
		UmlCom.trace("isNiemElementInType: error - element " + elementName + " not in type " + typeName);
		return false;
	}

	/** return true if a prefix exists in reference model */
	private static Boolean isNiemPrefix(String prefix) {
		if (prefix == null)
			return false;
		if (isExternalPrefix(prefix))
			return false;
		String schemaURI = Prefixes.get(prefix);
		Namespace ns = Namespaces.get(schemaURI);
		if (ns == null)
			return false;
		return ns.referenceClassView != null;
	}

	/** returns true if type exists in reference model */
	private static Boolean isNiemType(String typeName) {
		if ((typeName == null) || typeName.equals("") || typeName.equals("??") || isExternalPrefix(getPrefix(typeName)))
			return false;
		String schemaURI = Prefixes.get(getPrefix(typeName));
		if (schemaURI == null)
			return false;
		return NiemTypes.containsKey(getURI(schemaURI, typeName));
	}

	/** create a relationship between a type and an attribute group */
	private static void relateAttributeGroup(UmlClass type, UmlClass attributeGroupType) {
		if (type != null && attributeGroupType != null)
			try {
				UmlBaseRelation.create(aRelationKind.aDirectionalAggregation, type, attributeGroupType);
			} catch (Exception re) {
				// trace("createSubsetAndExtension: " + typeName + " already related to
				// attribute group " + baseTypeName);
			}
	}

	/** create a relationship between a type and a base type */
	private static void relateBaseType(UmlClass type, UmlClass baseType) {
		if (type != null && baseType != null)
			try {
				UmlBaseRelation.create(aRelationKind.aGeneralisation, type, baseType);
			} catch (Exception re) {
				// trace("copyType: error - type " + type.name() + " already related to base
				// type " + sourceBaseTypeName);
			}
	}

	/** relate element in type to element */
	private static void relateElementInType(UmlAttribute elementInType, UmlClassInstance element) {
		UmlTypeSpec elementType = new UmlTypeSpec();
		elementType.type = element.type();
		if (elementType.type != null)
			try {
				elementInType.set_Type(elementType);
			} catch (Exception re) {
				UmlCom.trace("relateElementInType: error relating element in type to " + getPrefixedName(element) + " "
						+ re.toString());
			}
	}

	/** add a description to type or element */
	private static void setDescription(UmlItem item, String description) {
		String currentDescription = item.description();
		if ((currentDescription.equals("")) && (description != null) && (!description.equals("")))
			item.set_Description(description);
	}

	/** add NIEM mapping notes to a type or element */
	private static void setNotes(UmlItem item, String notes) {
		if ((item != null) && (notes != null) && (!notes.equals(""))) {
			String currentNotes = item.propertyValue(NOTES_PROPERTY);
			if (currentNotes == null)
				currentNotes = notes;
			else if (!currentNotes.contains(notes))
				currentNotes = currentNotes + "; " + notes;
			if (!currentNotes.equals(""))
				item.set_PropertyValue(NOTES_PROPERTY, currentNotes);
		}
	}

	/** sets the prefix of an UmlItem */
	private static void setPrefix(UmlItem item, String prefix) {
		item.set_PropertyValue(PREFIX_PROPERTY, prefix);
	}

	/** sets a project property */
	private static void setPropertyDefault(String propertyName, String propertyValue) {
		UmlPackage root = UmlBasePackage.getProject();
		if (root.propertyValue(propertyName) == null)
			root.set_PropertyValue(propertyName, propertyValue);
	}

	/** sets the URI of an UmlItem */
	private static void setURI(UmlItem item, String uri) {
		item.set_PropertyValue(URI_PROPERTY, uri);
	}

	/** outputs debugging information */
	private static void trace(String output) {
		if (_TRACE)
			UmlCom.trace(output);
	}

	/** verifies NIEM reference model exists */
	public static boolean verifyNIEM() {
		trace("verifyNIEM: verifying NIEM folders");
		UmlPackage pimPackage = getPackage(UmlBasePackage.getProject(), NIEM_PACKAGE, false);
		if (pimPackage != null) {
			referencePackage = getPackage(pimPackage, NIEM_REFERENCE_PACKAGE, false);
			if (referencePackage != null)
				return true;
		}

		UmlCom.trace("NIEM reference model does not exist.  Import NIEM reference schemas first.");
		return false;
	}

	/** writes a column of the NIEM mapping spreadsheet in HTML format to a file */
	private static void writeItemHtml(FileWriter fw, UmlItem item) throws IOException {
		if (item.known) {
			fw.write("<a href=\"");
			if (!UmlItem.flat && (item.parent() != null) && (item.parent().kind() == anItemKind.aClass)) {
				fw.write("class");
				fw.write(String.valueOf(item.parent().getIdentifier()));
			} else
				fw.write("index");
			fw.write(HTML_FILE_TYPE + "#ref");
			fw.write(String.valueOf(item.kind().value()));
			fw.write('_');
			fw.write(String.valueOf(item.getIdentifier()));
			fw.write("\"><b>");
			fw.write(item.name());
			fw.write("</b></a>");
		} else
			fw.write(item.name());
	}

	/** output a JSON name value pair */
	private static void writeJson(FileWriter fw, String name, String value) {
		try {
			fw.write(" \"" + name + "\" : \"" + value + "\",\n");
		} catch (Exception e) {
			UmlCom.trace("jsonOut: error " + e.toString());
		}
	}

	/** output a final JSON name value pair */
	private static void writeJsonLast(FileWriter fw, String name, String value) {
		try {
			fw.write(" \"" + name + "\" : \"" + value + "\"\n");
		} catch (Exception e) {
			UmlCom.trace("jsonOut: error " + e.toString());
		}
	}

	/** writes a line of the NIEM mapping spreadsheet in HTML format to a file */
	private static void writeLineHtml(FileWriter fw, UmlItem item) {
		try {
			// Export Class, Property and Multiplicity
			// trace("writeLineHtml: " + item.name());
			switch (item.kind().value()) {
			case anItemKind._aClass: {
				fw.write("<tr bgcolor=\"#f0f0f0\"><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item);
				fw.write("</td><td>");
				fw.write("</td><td>");
			}
				break;
			case anItemKind._anAttribute: {
				fw.write("<tr><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item.parent());
				fw.write("</td><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item);
				fw.write("</td><td>");
				UmlAttribute a = (UmlAttribute) item;
				fw.write(a.multiplicity());
			}
				break;
			case anItemKind._aRelation: {
				UmlRelation rel = (UmlRelation) item;
				if ((rel.relationKind() == aRelationKind.aGeneralisation)
						|| (rel.relationKind() == aRelationKind.aRealization))
					return;
				else {
					fw.write("<tr><td style=\"word-wrap: break-word\">");
					writeItemHtml(fw, item.parent());
					fw.write("</td><td style=\"word-wrap: break-word\">");
					writeItemHtml(fw, item);
					fw.write("</td><td>");
					fw.write(rel.multiplicity());
				}
			}
				break;
			default:
				return;
			}
			fw.write("</td><td>");

			// Export Description
			if (item.description() != null)
				fw.write(item.description());
			fw.write("</td>");

			// Export NIEM Mapping
			int columnIndex;
			// String oldValue, container;
			String[] column = new String[NIEM_STEREOTYPE_MAP.length];
			String extensionBGColor = "#ffd700";
			String defaultBGColor = "#ffffff";
			String invalidFGColor = "#ff0000"; // invalid NIEM mappings are red
			String changedFGColor = "#0000ff"; // changes from the previous
			// version are blue
			String defaultFGColor = "#000000";
			String fgcolor, bgcolor;

			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
				for (columnIndex = 4; columnIndex < NIEM_STEREOTYPE_MAP.length; columnIndex++) {
					column[columnIndex] = (String) (item.propertyValue(getNiemProperty(columnIndex)));
					column[columnIndex] = (column[columnIndex] != null) ? column[columnIndex].trim() : "";
				}

				// determine if this is an extension
				/*
				 * Boolean extension = false; String[] xPathElements = column[4].split("/"); for
				 * (String element : xPathElements) { String prefix = getPrefix(element); if
				 * (!prefix.equals("") && !isNiemSchema(prefix) &&
				 * !isExternalPrefix(getPrefix(element.trim()))) { extension = true; continue; }
				 * }
				 */

				// export XPath
				String XPath = column[4].trim();
				String oldXPath = column[9].trim();
				// bgcolor = (extension) ? extensionBGColor : defaultBGColor;
				bgcolor = defaultBGColor;
				fgcolor = (XPath.equals(oldXPath)) ? defaultFGColor : changedFGColor;
				fw.write(getColumnHtml(XPath, bgcolor, fgcolor, true));

				// export Type
				String typeName = column[5].trim();
				String typePrefix = getPrefix(typeName);
				bgcolor = defaultBGColor;
				fgcolor = defaultFGColor;
				if (!typeName.equals("")) {
					if (isNiemPrefix(getPrefix(typeName)) && !isNiemType(typeName))
						fgcolor = invalidFGColor;
					if (!isNiemPrefix(typePrefix) && !isExternalPrefix(typePrefix))
						bgcolor = extensionBGColor;
				}
				fw.write(getColumnHtml(typeName, bgcolor, fgcolor, true));

				// export Property
				String elementLine = column[6];
				fgcolor = defaultFGColor;
				bgcolor = defaultBGColor;
				if (!elementLine.equals("")) {
					String[] elementNames = elementLine.split(",");
					for (String elementName : elementNames) {
						elementName = elementName.trim();
						Matcher mat = Pattern.compile("\\((.*?)\\)").matcher(elementName);
						if (!mat.find()) {
							String prefix = getPrefix(elementName);
							if (isNiemPrefix(typePrefix) && isNiemPrefix(prefix)
									&& !isNiemElementInType(typeName, elementName))
								fgcolor = invalidFGColor;
							prefix = getPrefix(elementLine);
							if (!isNiemPrefix(prefix) && !isExternalPrefix(prefix))
								bgcolor = extensionBGColor;
						}
					}
				}
				fw.write(getColumnHtml(elementLine, bgcolor, fgcolor, true));

				// export BaseType
				String baseType = column[7].trim();
				String basePrefix = getPrefix(baseType);
				bgcolor = defaultBGColor;
				fgcolor = defaultFGColor;
				if (!baseType.equals("") && !baseType.equals(ABSTRACT_TYPE_NAME)) {
					if (!isNiemPrefix(basePrefix) && !isExternalPrefix(basePrefix))
						bgcolor = extensionBGColor;
					if (isNiemPrefix(basePrefix) && !isNiemType(baseType))
						fgcolor = invalidFGColor;
				}
				fw.write(getColumnHtml(baseType, bgcolor, fgcolor, true));

				// export Multiplicity
				bgcolor = defaultBGColor;
				String multiplicity = column[8];
				fgcolor = (multiplicity.equals(column[10])) ? defaultFGColor : changedFGColor;
				String minoccurs, maxoccurs;
				if ((multiplicity.equals("")))
					minoccurs = maxoccurs = "1";
				else if (multiplicity.contains(",")) {
					String[] occurs = multiplicity.split(",");
					minoccurs = occurs[0];
					maxoccurs = occurs[1];
				} else
					minoccurs = maxoccurs = multiplicity;
				try {
					if (Integer.parseInt(minoccurs) < 0)
						throw new NumberFormatException();
					if (!maxoccurs.equals("unbounded") && (Integer.parseInt(maxoccurs) < 1))
						throw new NumberFormatException();
				} catch (NumberFormatException e) {
					fgcolor = invalidFGColor;
				}
				fw.write(getColumnHtml(column[8], bgcolor, fgcolor, false));

				// export Old XPath, Multiplicity, Mapping Notes, code list
				fgcolor = defaultFGColor;
				fw.write(getColumnHtml(column[9], bgcolor, fgcolor, true));
				fw.write(getColumnHtml(column[10], bgcolor, fgcolor, false));
				fw.write(getColumnHtml(column[11], bgcolor, fgcolor, true));
				fw.write(getColumnHtml(column[12], bgcolor, fgcolor, true));
			}
			fw.write("</tr>");
		} catch (Exception e) {
			UmlCom.trace("writeLineHtml: error " + e.toString());
		}
	}

	/** writes an XML name value pair to a file */
	private static void writeXmlAttribute(FileWriter fw, String name, String value) {
		try {
			fw.write(" " + name + "=\"" + value + "\"");
		} catch (Exception e) {
			UmlCom.trace("xmlAttribute: error " + e.toString());
		}
	}

	/** writes an XML namespace attribute to a file */
	private static void writeXmlNs(FileWriter fw, String prefix, String value) {
		try {
			if (prefix.equals(""))
				fw.write(" " + NAMESPACE_ATTRIBUTE + "=\"" + value + "\"");
			else
				fw.write(" " + NAMESPACE_ATTRIBUTE + ":" + prefix + "=\"" + value + "\"");
		} catch (Exception e) {
			UmlCom.trace("xmlNS: error " + e.toString());
		}
	}

	/** initialize NiemTools project */
	public NiemTools() {
		super();

		// set IEPD configuraion defaults
		setPropertyDefault(IEPD_URI_PROPERTY, IEPD_URI_DEFAULT);
		setPropertyDefault(IEPD_NAME_PROPERTY, IEPD_NAME_DEFAULT);
		setPropertyDefault(IEPD_VERSION_PROPERTY, IEPD_VERSION_DEFAULT);
		setPropertyDefault(IEPD_STATUS_PROPERTY, IEPD_STATUS_DEFAULT);
		setPropertyDefault(IEPD_ORGANIZATION_PROPERTY, IEPD_ORGANIZATION_DEFAULT);
		setPropertyDefault(IEPD_CONTACT_PROPERTY, IEPD_CONTACT_DEFAULT);
		setPropertyDefault(IEPD_READ_ME_FILE_PROPERTY, IEPD_READ_ME_FILE_DEFAULT);
		setPropertyDefault(IEPD_CHANGE_LOG_FILE_PROPERTY, IEPD_CHANGE_LOG_FILE_DEFAULT);
		setPropertyDefault(IEPD_EXTERNAL_SCHEMAS_PROPERTY, IEPD_EXTERNAL_SCHEMAS_DEFAULT);
	}
}
