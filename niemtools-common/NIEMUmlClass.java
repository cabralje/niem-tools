
/*
 *   NIEMtools - This is a plug_out that extends the BOUML UML tool with support for the National Information Exchange Model (NIEM) defined at http://niem.gov.
 *   Specifically, it enables a UML Common Information Model (CIM), an abstract class mode, to be mapped into a
 *   UML Platform Specific Model (PSM), the NIEM reference/subset/extension model, and a UML Platform Specific Model (NIEM), NIEM XML Schema.
 *
 *   NOTE: This plug_out requires that the BOUML project include a simple NIEM profile that provides the stereotypes required for mapping.
 *   
 *   Copyright (C) 2017 James E. Cabral Jr., MTG Management Consultants LLC, jcabral@mtgmc.com, http://github.com/cabralje
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
//import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.XMLConstants;
// DOM
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPath;
import javax.xml.xpath.XPathConstants;
import javax.xml.xpath.XPathExpression;
import javax.xml.xpath.XPathFactory;

// DOM
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

// OpenCSV library
import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

class NiemTools {

	// Debugging options
	//private static Boolean _TRACE = true;
	private static final Boolean _TRACE = false;
	//private static Boolean _IMPORT_CODE_DESCRIPTIONS = true;
	private static final Boolean _IMPORT_CODE_DESCRIPTIONS = false;

	// JSON
	private static final String JSON_SCHEMA_URI = "http://json-schema.org/draft-04/schema#";
	private static final String JSON_SCHEMA_FILE_TYPE = ".schema.json";
	// XML
	private static final String XML_URI = XMLConstants.XML_NS_URI;
	private static final String XML_PREFIX = XMLConstants.XML_NS_PREFIX;
	private static final String XSD_PREFIX = "xs";
	private static final String XSD_URI = XMLConstants.W3C_XML_SCHEMA_NS_URI;
	private static final String XSD_FILE_TYPE = ".xsd";
	private static final String XML_FILE_TYPE = ".xml";
	private static final String HTML_FILE_TYPE = ".html";
	private static final String XSI_PREFIX = "xsi";
	private static final String XSI_URI = XMLConstants.W3C_XML_SCHEMA_INSTANCE_NS_URI;
	private static final String NAMESPACE_DELIMITER = ":";
	private static final String NAMESPACE_ATTRIBUTE = XMLConstants.XMLNS_ATTRIBUTE;
	private static final String XML_HEADER = "<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n";
	private static final String XML_ATTRIBUTION = "<!-- Generated by BOUML niemtools plug_out (https://github.com/cabralje/niem-tools) -->\n";
	// XML Catalog
	private static final String XML_CATALOG_URI = "urn:oasis:names:tc:entity:xmlns:xml:catalog";
	private static final String XML_CATALOG_HEADER = "<!DOCTYPE catalog PUBLIC \"-//OASIS//DTD Entity Resolution XML Catalog V1.0//EN\" \"http://www.oasis-open.org/committees/entity/release/1.0/catalog.dtd\">\n";
	// Web services
	private static final String SOAP_PREFIX = "soap";
	private static final String SOAP_URI = "http://schemas.xmlsoap.org/wsdl/soap/";
	private static final String SOAP_HTTP_BINDING_URI = "http://schemas.xmlsoap.org/soap/http";
	private static final String WSDL_SCHEMA_PREFIX = "wsdl";
	private static final String WSDL_SCHEMA_URI = "http://schemas.xmlsoap.org/wsdl/";
	private static final String WSDL_FILE_TYPE = ".wsdl";
	private static final String WSP_PREFIX = "wsp";
	private static final String WSP_URI = "http://schemas.xmlsoap.org/ws/2004/09/policy";
	private static final String WSP_POLICY = "MyPolicy";
	private static final String WSU_PREFIX = "wsu";
	private static final String WSU_URI = "http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-361 wssecurity-utility-1.0.xsd";
	private static final String WSRMP_PREFIX = "wsrmp";
	private static final String WSRMP_URI = "http://docs.oasis-open.org/ws-rx/wsrmp/200702";
	// Genericode
	private static final String GC_PREFIX = "gc";
	private static final String GC_URI = "http://docs.oasis-open.org/codelist/ns/genericode/1.0/";
	private static final String GC_LOCATION = "https://docs.oasis-open.org/codelist/cs-genericode-1.0/xsd/genericode.xsd";
	private static final String GC_FILE_TYPE = ".gc";
	private static final String GC_APPINFO_PREFIX = "gca";
	private static final String GC_APPINFO_URI = "http://example.org/namespace/genericode-appinfo";
	// NIEM code lists
	private static final String CODELIST_URI = "http://reference.niem.gov/niem/specification/code-lists/1.0/";
	private static final String CODELIST_APPINFO_PREFIX = "clsa";
	private static final String CODELIST_APPINFO_URI = "http://reference.niem.gov/niem/specification/code-lists/1.0/code-lists-schema-appinfo/";
	private static final String CODELIST_CODE = "code";
	private static final String CODELIST_DEFINITION = "definition";
	// NIEM naming and design rules
	private static final String NC_PREFIX = "nc";
	private static final String NDR_URI = "http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/";
	private static final String AUGMENTATION_TYPE_NAME = "AugmentationType";
	private static final String AUGMENTATION_POINT_NAME = "AugmentationPoint";
	private static final String OBJECT_TYPE_NAME = "ObjectType";
	private static final String STRUCTURES_PREFIX = "structures";
	// NIEM conformance targets
	private static final String CT_PREFIX = "ct";
	private static final String CT_URI = "http://release.niem.gov/niem/conformanceTargets/3.0/";
	// NIEM terms
	private static final String TERM_PREFIX = "term";
	private static final String TERM_URI = "http://release.niem.gov/niem/localTerminology/3.0/";
	// NIEM model package descriptions
	private static final String MPD_URI = "http://reference.niem.gov/niem/specification/model-package-description/3.0/";
	private static final String MPD_CATALOG_URI = "http://reference.niem.gov/niem/resource/mpd/catalog/3.0/";
	private static final String MPD_CATALOG_LOCATION = "https://tools.niem.gov/IEPD/mpd-catalog-3.0.xsd";
	// private static final String MPD_CATALOG_LOCATION =
	// "../../mpd-toolkit-3.0/mpd-catalog-3.0.xsd";
	private static final String MPD_NC_URI = "http://release.niem.gov/niem/niem-core/3.0/";
	private static final String MPD_STRUCTURES_URI = "http://release.niem.gov/niem/structures/3.0/";
	// NIEM subset schema generation tool (SSGT)
	private static final String WANTLIST_URI = "http://niem.gov/niem/wantlist/2.2";
	// Niem-tools UML modeling
	private static final String MAPPING_SPREADSHEET_TITLE = "NIEM Mapping";
	private static final String ATTRIBUTE_PREFIX = "@";
	private static final String REFERENCE_PREFIX = "^";
	private static final String HASH_DELIMITER = ",";
	private static final String CODELIST_DELIMITER = ";";
	private static final String CODELIST_DEFINITION_DELIMITER = "=";
	private static final String NOTES_PROPERTY = "Notes";
	private static final String NILLABLE_PROPERTY = "isNillable";
	private static final String URI_PROPERTY = "URI";
	private static final String PREFIX_PROPERTY = "prefix";
	private static final String SUBSTITUTION_PROPERTY = "substitutesFor";
	private static final String CODELIST_PROPERTY = "codeList";
	private static final String FILE_PATH_PROPERTY = "path";
	private static final String WSDL_SUFFIX = "WSDL";
	private static final String WSDL_XSD_SUFFIX = "MessageWrappers";
	private static final String LOCAL_PREFIX = "local";
	private static final String ABSTRACT_TYPE_NAME = "abstract";
	private static final String ANY_ELEMENT_NAME = "any";
	// Niem-tools web services
	private static final String WSDL_PREFIX = "tns";
	private static final String WSDL_XSD_PREFIX = "wrapper";
	private static final String RESPONSE_MESSAGE_SUFFIX = "Response";
	private static final String REQUEST_MESSAGE_SUFFIX = "Request";
	// IEPD Properties
	private static final String IEPD_EXTERNAL_SCHEMAS_PROPERTY = "externalSchemas";
	private static final String IEPD_CHANGE_LOG_FILE_PROPERTY = "IEPDChangeLogFile";
	private static final String IEPD_READ_ME_FILE_PROPERTY = "IEPDReadMeFile";
	private static final String IEPD_CONTACT_PROPERTY = "IEPDContact";
	private static final String IEPD_ORGANIZATION_PROPERTY = "IEPDOrganization";
	private static final String IEPD_STATUS_PROPERTY = "IEPDStatus";
	private static final String IEPD_VERSION_PROPERTY = "IEPDVersion";
	private static final String IEPD_NAME_PROPERTY = "IEPDName";
	private static final String IEPD_URI_PROPERTY = "IEPDURI";
	private static final String IEPD_CHANGE_LOG_FILE_DEFAULT = "changelog.txt";
	private static final String IEPD_READ_ME_FILE_DEFAULT = "readme.txt";
	private static final String IEPD_CONTACT_DEFAULT = "Contact";
	private static final String IEPD_ORGANIZATION_DEFAULT = "Organization";
	private static final String IEPD_STATUS_DEFAULT = "Draft";
	private static final String IEPD_VERSION_DEFAULT = "1.0";
	private static final String IEPD_NAME_DEFAULT = "IEPD";
	private static final String IEPD_URI_DEFAULT = "http://local";
	private static final String IEPD_EXTERNAL_SCHEMAS_DEFAULT = "cac=urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2=http://docs.oasis-open.org/ubl/os-UBL-2.1/xsd/common/UBL-CommonAggregateComponents-2.1.xsd,"
			+ "cbc=urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2=http://docs.oasis-open.org/ubl/os-UBL-2.1/xsd/common/UBL-CommonBasicComponents-2.1.xsd,"
			+ "ds=http://www.w3.org/2000/09/xmldsig#=https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd";
	// File locations
	private static final String NIEM_DIR = "niem";
	private static final String WANTLIST_FILE = "wantlist.xml";
	private static final String XML_CATALOG_FILE = "xml-catalog.xml";
	private static final String MPD_CATALOG_FILE = "mpd-catalog.xml";
	private static final String CONFORMANCE_ASSERTION_FILE = "conformance-assertion.pdf";
	// Niem stereotype configuration
	public static final String NIEM_STEREOTYPE_TYPE = "niem-profile:niem";
	private static final String STEREOTYPE_DELIMITER = ":";
	// private static final String NIEM_STEREOTYPE_LABEL = "niem:niem";
	// NIEM mapping spreadsheet column headings, NIEM profile profile stereotype
	private static final String[][] NIEM_STEREOTYPE_MAP = { { "Model Class", "", }, { "Model Attribute", "", },
			{ "Model Multiplicity", "", }, { "Model Definition", "", }, { "NIEM XPath", "XPath" },
			{ "NIEM Type", "Type" },
			{ "NIEM Property, " + REFERENCE_PREFIX + "Reference, (Representation)", "Property" },
			{ "NIEM Base Type", "BaseType" }, { "NIEM Multiplicity", "Multiplicity" }, { "Old XPath", "OldXPath" },
			{ "Old Multiplicity", "OldMultiplicity" }, { "NIEM Mapping Notes", "Notes" },
			{ "Code List Code=Definition;", "CodeList" } };

	private static Set<String> externalPrefixes = new HashSet<String>();
	private static Map<String, String> externalSchemaURL = new HashMap<String, String>();

	private static UmlClass referenceAbstractType = null;

	private static UmlClass subsetAbstractType = null;
	private static UmlClass subsetAugmentationType = null;
	private static UmlClass subsetObjectType = null;
	private static UmlClassInstance referenceAnyElement = null;
	public static int importPass;
	public static String importPath;
	private static Map<String, UmlItem> NiemElements = new HashMap<String, UmlItem>();
	private static Map<String, List<UmlClassInstance>> NiemElementsInType = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, Namespace> Namespaces = new HashMap<String, Namespace>();
	private static Map<String, String> Prefixes = new HashMap<String, String>();
	private static Map<String, UmlClass> NiemTypes = new HashMap<String, UmlClass>();
	private static Map<String, List<UmlClassInstance>> Substitutions = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, UmlItem> SubsetElements = new HashMap<String, UmlItem>();
	private static Map<String, List<UmlClassInstance>> SubsetElementsInType = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, UmlClass> SubsetTypes = new HashMap<String, UmlClass>();

	private static Map<String, UmlItem> ExtensionElements = new HashMap<String, UmlItem>();
	private static Map<String, List<UmlClassInstance>> ExtensionElementsInType = new HashMap<String, List<UmlClassInstance>>();
	private static Map<String, UmlClass> ExtensionTypes = new HashMap<String, UmlClass>();

	private static UmlPackage subsetPackage = null, extensionPackage = null, referencePackage = null;
	private static XPath xPath = XPathFactory.newInstance().newXPath();

	// add element in type to reference model
	private static UmlAttribute addElementInType(Document doc, UmlClassView parentClassView, String schemaURI,
			String typeName, String propertyName, String multiplicity) {
		// abort if external schame
		// if (isExternal(typeName) || isExternal(propertyName))
		// return null;

		UmlClass type = findType((UmlPackage) (parentClassView.parent()), schemaURI, typeName);
		if (type == null) {
			UmlCom.trace("addElementInType: type " + typeName + " not found");
			return null;
		}
		// String prefix = getPrefix(propertyName);
		// UmlClassInstance ci = null;
		// if (prefix.equals(""))
		// ci = findElement((UmlPackage) (parentClassView.parent()), schemaURI,
		// propertyName);
		// else
		UmlClassInstance ci = findElementByPrefix(doc, (UmlPackage) (parentClassView.parent()), propertyName);
		if (ci == null) {
			UmlCom.trace("addElementInType: element " + schemaURI + NAMESPACE_DELIMITER + propertyName + " not found");
			return null;
		}
		return addReferenceElementInType(type, ci, multiplicity);
	}

	// add element to extension
	private static UmlClassInstance addExtensionElement(String elementName, String typeName, String description,
			String notes) {
		// abort if external schame
		// if (isExternal(typeName))
		// return null;

		trace("addExtensionElement: Copying " + elementName + " to subset");
		String prefix = getPrefix(elementName);
		String schemaURI = getURI(elementName);
		// trace("addElement: Namespace found");
		// if element already exists in subset, return
		String elementName2 = getName(elementName);
		UmlClassInstance element;
		if (isNiemElement(elementName))
			element = findElement(subsetPackage, schemaURI, elementName2);
		else
			element = findElement(extensionPackage, schemaURI, elementName2);
		if (element != null) {
			// trace("addElement: Element " + elementName + " already exists in
			// subset/extension");
			String currentNotes = element.propertyValue(NOTES_PROPERTY);
			if (currentNotes == null)
				currentNotes = notes;
			else if (!currentNotes.contains(notes))
				currentNotes = currentNotes + "; " + notes;
			if (!currentNotes.equals(""))
				element.set_PropertyValue(NOTES_PROPERTY, currentNotes);
			return element;
		}

		// if namespace doesn't exist, create it
		UmlClassView nsClassView;
		if (isNiemElement(elementName))
			nsClassView = addNamespace(subsetPackage, prefix, schemaURI);
		else
			nsClassView = addNamespace(extensionPackage, prefix, schemaURI);
		if (nsClassView == null) {
			UmlCom.trace("addExtensionElement: Subset/extension classview not found for " + schemaURI);
			return null;
		}

		// find base type
		String typePrefix = getPrefix(typeName);
		String typeSchemaURI = getURI(typeName);
		String typeName2 = getName(typeName);
		UmlClass baseType;
		if (isNiemType(typeName))
			baseType = findType(subsetPackage, typeSchemaURI, typeName2);
		else
			baseType = findType(extensionPackage, typeSchemaURI, typeName2);
		if (baseType == null) {
			if (!isExternalPrefix(typePrefix))
				UmlCom.trace("addElement: Base type not found in extension/subset for " + typePrefix
						+ NAMESPACE_DELIMITER + typeName2);
			baseType = subsetAbstractType;
			// return null;
		}

		// create element
		trace("addExtensionElement: Copying element " + elementName2 + " in subset");
		element = UmlClassInstance.create(nsClassView, filterUMLName(elementName2), baseType);
		element.set_Description(description);
		setURI(element, schemaURI + HASH_DELIMITER + filterHash(elementName2));
		if (!notes.equals(""))
			element.set_PropertyValue(NOTES_PROPERTY, notes);

		return element;
	}

	// add element in type to extension
	private static UmlAttribute addExtensionElementInType(String typeName, UmlClassInstance classInstance,
			String multiplicity) {
		// abort if external schame
		// if (isExternal(typeName))
		// return null;

		if (classInstance == null) {
			UmlCom.trace("addElementInType: element not found in type " + typeName);
			return null;
		}
		String schemaURI = getURI(typeName);
		// String schemaURI = Prefixes.get(prefix);
		// if (schemaURI == null)
		// schemaURI = extensionSchema(prefix);

		// trace("addElementInType: Namespace found");
		// if type already exists in subset, return
		String typeName2 = getName(typeName);
		UmlClass type = findType(extensionPackage, schemaURI, typeName2);
		if (type == null) {
			UmlCom.trace("addExtensionElementInType: type " + typeName + " not found");
			return null;
		}
		return addReferenceElementInType(type, classInstance, multiplicity);
	}

	// add type to extension
	private static UmlClass addExtensionType(String typeName, String description, String notes) {
		// abort if external schema
		// if (isExternal(typeName))
		// return null;

		trace("addExtensionType: adding " + typeName + " to extension");
		// get schemaURI
		String prefix = getPrefix(typeName);
		String schemaURI = getURI(typeName);

		// String schemaURI = Prefixes.get(prefix);
		// if (schemaURI == null)
		// schemaURI = extensionSchema(prefix);

		// trace("addType: Namespace found");
		// if type already exists in subset, return
		String typeName2 = getName(typeName);
		UmlClass typeClass = findType(extensionPackage, schemaURI, typeName2);
		if (typeClass != null) {
			String currentDescription = typeClass.description();
			if ((currentDescription.equals("")) && (description != null))
				typeClass.set_Description(description);
			String currentNotes = typeClass.propertyValue(NOTES_PROPERTY);
			if (currentNotes == null)
				currentNotes = notes;
			else if (!currentNotes.contains(notes))
				currentNotes = currentNotes + "; " + notes;
			if (!currentNotes.equals(""))
				typeClass.set_PropertyValue(NOTES_PROPERTY, currentNotes);
			return typeClass;
		}

		// if namespace doesn't exist, create it
		UmlClassView nsClassView;
		if (isNiemType(typeName))
			nsClassView = addNamespace(subsetPackage, prefix, schemaURI);
		else
			nsClassView = addNamespace(extensionPackage, prefix, schemaURI);
		if (nsClassView == null) {
			UmlCom.trace("addExtensionType: Subset/extension classview not found for " + schemaURI);
			return null;
		}
		// create type
		trace("addExtensionType: Copying type " + typeName + " to subset");
		try {
			typeClass = UmlClass.create(nsClassView, filterUMLName(typeName2));
		} catch (RuntimeException re) {
			trace("addExtensionType: type already exists in extension " + typeName);
		}
		if (typeClass != null) {
			typeClass.set_Description(description);
			setURI(typeClass, schemaURI + HASH_DELIMITER + filterHash(typeName2));
			if (!notes.equals(""))
				typeClass.set_PropertyValue(NOTES_PROPERTY, notes);
		}
		return typeClass;
	}

	// import NIEM and non-NIEM namespaces
	private static UmlClassView addNamespace(UmlPackage parentPackage, String prefix, String schemaURI) {
		Namespace ns = Namespaces.get(schemaURI);
		if (ns == null) {
			// create namespace
			trace("addNamespace: adding namespace " + schemaURI);
			ns = new Namespace(schemaURI);
			Namespaces.put(schemaURI, ns);
		}
		// remove special characters in prefix names
		// String prefix2 = prefix;
		// String prefix2 = filterNameToken(prefix);
		// String prefix2 = prefix.replaceAll("[^a-zA-Z0-9-_]+", "");
		// if (!Prefixes.containsKey(prefix2)) {
		// trace("Adding prefix " + prefix2);
		// Prefixes.put(prefix2, schemaURI);
		// }
		String prefix2 = filterPrefix(prefix);
		if (!Prefixes.containsKey(prefix2)) {
			trace("addNamespace: Adding prefix " + prefix2);
			Prefixes.put(prefix2, schemaURI);
		}

		if (parentPackage == referencePackage) {
			if (ns.referenceClassView != null)
				return ns.referenceClassView;
		} else if (ns.nsClassView != null) {
			// trace("addNamespace: Classview for subset/extension already exists for schema
			// " + prefix);
			return ns.nsClassView;
		}
		trace("addNamespace: Creating classview for " + schemaURI);
		String prefix3 = filterUMLName(prefix);
		String prefix4 = prefix3;
		UmlClassView namespaceClassView = null;
		int conflictCounter = 1;
		// for (UmlItem i : parentPackage.children())
		// if (i.name().equals(prefix3))
		// prefix3);
		while (namespaceClassView == null) {
			try {
				namespaceClassView = UmlClassView.create(parentPackage, prefix4);
			} catch (Exception e) {
				UmlCom.trace("addNamespace: Multiple namespace URIs for prefix " + prefix4 + " " + schemaURI + " and "
						+ Prefixes.get(prefix4));
				prefix4 = prefix3 + conflictCounter;
				conflictCounter++;
				// namespaceClassView = UmlClassView.create(parentPackage,
				// filterUMLName(prefix) + "-" + ThreadLocalRandom.current().nextInt());
			}
		}
		setURI(namespaceClassView, schemaURI);
		setPrefix(namespaceClassView, prefix2);
		if (parentPackage == referencePackage)
			ns.referenceClassView = namespaceClassView;
		else
			ns.nsClassView = namespaceClassView;
		setURI(namespaceClassView, schemaURI);

		if (parentPackage == extensionPackage) {
			ns.filepath = prefix + XSD_FILE_TYPE;
			namespaceClassView.set_PropertyValue(FILE_PATH_PROPERTY, prefix + XSD_FILE_TYPE);
		}

		return namespaceClassView;
	}

	// add element to reference model
	private static UmlClassInstance addReferenceElement(Document doc, UmlClassView parentClassView, String schemaURI,
			String elementName, String typeName, String description) {
		UmlClassInstance classInstance = null;
		try {
			// String elementName2 = elementName;
			// String elementName2 = filterUMLName(elementName);
			// String elementName2 = elementName.replace("-", "");
			classInstance = findElement((UmlPackage) (parentClassView.parent()), schemaURI, elementName);
			if (classInstance == null) {
				UmlClass baseTypeClass;
				if (typeName == null) // abstract
				{
					UmlPackage rootPackage = (UmlPackage) (parentClassView.parent());
					if (rootPackage == referencePackage)
						baseTypeClass = referenceAbstractType;
					else
						baseTypeClass = subsetAbstractType;
				} else {
					// String basePrefix = getPrefix(baseName);
					// if (basePrefix == null)
					// base = findType((UmlPackage) (parentClassView.parent()), schemaURI,
					// getName(baseName));
					// else
					String typeName2 = typeName;
					// String typeName2 = filterUMLName(typeName);
					baseTypeClass = findTypeByPrefix(doc, (UmlPackage) (parentClassView.parent()), typeName2);
					if (baseTypeClass == null) {
						UmlCom.trace("addElement: cannot find base type " + typeName2);
						return null;
					}
				}
				// String elementName2 = filterUMLName(elementName);
				classInstance = UmlClassInstance.create(parentClassView, filterUMLName(elementName), baseTypeClass);
				setURI(classInstance, schemaURI + HASH_DELIMITER + filterHash(elementName));
				// classInstance.setURI(_PropertyValue(uriProperty, elementName3);
				classInstance.set_Description(description);
			}
		} catch (RuntimeException re) {
			UmlCom.trace("addReferenceElement: cannot add element " + elementName + " " + re.toString());
		}

		return classInstance;
	}

	// add element in type to reference model or extension
	private static UmlAttribute addReferenceElementInType(UmlClass typeClass, UmlClassInstance classInstance,
			String multiplicity) {
		if (typeClass == null) {
			UmlCom.trace("addReferenceElementInType: type not found");
			return null;
		}
		if (classInstance == null) {
			UmlCom.trace("addReferenceElementInType: element not found");
			return null;
		}
		String elementName = getPrefix(classInstance) + NAMESPACE_DELIMITER + classInstance.pretty_name();
		// String elementName2 = elementName;
		// String elementName2 = filterUMLName(elementName);
		// String elementName2 = elementName.replace("-", "");
		UmlAttribute attribute = null;
		for (UmlItem item : typeClass.children()) {
			if (item.kind() == anItemKind.anAttribute && item.name().equals(elementName)) {
				attribute = (UmlAttribute) item;
				String previousMultiplicity = attribute.multiplicity();
				if (!previousMultiplicity.equals(multiplicity))
					UmlCom.trace("addElementInType:  " + getPrefix(typeClass) + NAMESPACE_DELIMITER
							+ typeClass.pretty_name() + "/" + getPrefix(classInstance) + ":"
							+ classInstance.pretty_name() + " has conflicting multiplicities " + previousMultiplicity
							+ " and " + multiplicity);
				return attribute;
			}
		}
		if (attribute == null)
			try {
				attribute = UmlAttribute.create(typeClass, filterUMLName(elementName));
			} catch (Exception re) {
				trace("addReferenceElementInType: element " + classInstance.name() + " already exists in type "
						+ typeClass.name() + re.toString());
			}
		if (attribute != null) {
			attribute.set_Description(classInstance.description());
			setURI(attribute, getURI(classInstance));
			UmlTypeSpec classType2 = new UmlTypeSpec();
			classType2.type = classInstance.type();
			if (classType2.type != null)
				attribute.set_Type(classType2);
			attribute.set_Multiplicity(multiplicity);
		}
		return attribute;
	}

	// add type to reference model or subset
	private static UmlClass addReferenceType(UmlClassView parentClassView, String schemaURI, String typeName,
			String description, String notes) {
		// String typeName2 = typeName;
		// String typeName2 = filterUMLName(typeName);
		// String typeName2 = typeName.replace("-", "");
		// String tagName2 = tagName;
		trace("addReferenceType: " + typeName);
		UmlClass typeClass = findType((UmlPackage) (parentClassView.parent()), schemaURI, typeName);
		if (typeClass == null) {
			// if (tagName2.equals(abstractTypeName))
			// trace("findType: abstract");
			try {
				typeClass = UmlClass.create(parentClassView, filterUMLName(typeName));
			} catch (Exception e) {
				UmlCom.trace("addType: type not found " + typeName + " " + e.toString());
			}
			setURI(typeClass, schemaURI + HASH_DELIMITER + filterHash(typeName));
			if (!notes.equals(""))
				typeClass.set_PropertyValue(NOTES_PROPERTY, notes);
			typeClass.set_Description(description);
		}
		return typeClass;
	}

	// cache NIEM reference, subset or extension models
	private static void cacheModel(UmlPackage rootPackage) {
		if (rootPackage == null)
			return;

		// Cache namespaces, types and elements
		String schemaURI;
		Map<String, UmlItem> Elements = null;
		Map<String, List<UmlClassInstance>> ElementsInType = null;
		Map<String, UmlClass> Types = null;

		if (rootPackage == referencePackage) {
			Elements = NiemElements;
			ElementsInType = NiemElementsInType;
			Types = NiemTypes;
		} else if (rootPackage == subsetPackage) {
			Elements = SubsetElements;
			ElementsInType = SubsetElementsInType;
			Types = SubsetTypes;
		} else if (rootPackage == extensionPackage) {
			Elements = ExtensionElements;
			ElementsInType = ExtensionElementsInType;
			Types = ExtensionTypes;
		} else
			return;

		for (UmlItem classView : rootPackage.children()) {
			if (classView.kind() != anItemKind.aClassView)
				continue;

			schemaURI = getURI(classView);
			String prefix = classView.propertyValue(PREFIX_PROPERTY);
			if (!Prefixes.containsKey(prefix)) {
				// trace("cacheModel: Adding prefix " + prefix);
				Prefixes.put(prefix, schemaURI);
			}
			Namespace ns = Namespaces.get(schemaURI);
			if (ns == null) {
				// create namespace
				ns = new Namespace(schemaURI);
				Namespaces.put(schemaURI, ns);
			}
			if (rootPackage == referencePackage)
				ns.referenceClassView = (UmlClassView) classView;
			else
				ns.nsClassView = (UmlClassView) classView;

			if (rootPackage == referencePackage || rootPackage == extensionPackage)
				ns.filepath = classView.propertyValue(FILE_PATH_PROPERTY);

			for (UmlItem thisClass : classView.children()) {
				schemaURI = getURI(thisClass);
				if (schemaURI != null)
					switch (thisClass.kind().value()) {
					case anItemKind._aClass:
						Types.put(schemaURI, (UmlClass) thisClass);
						break;
					case anItemKind._aClassInstance:
						UmlClassInstance ci = (UmlClassInstance) thisClass;
						Elements.put(schemaURI, ci);
						String headElement = ci.propertyValue(SUBSTITUTION_PROPERTY);
						if (headElement != null) {
							List<UmlClassInstance> enlist = (List<UmlClassInstance>) (Substitutions.get(headElement));
							if (enlist == null) {
								enlist = new ArrayList<UmlClassInstance>();
								Substitutions.put(headElement, enlist);
							}
							if (!enlist.contains(ci))
								enlist.add(ci);
						}
						break;
					default:
						break;
					}
			}
		}

		// Cache elements in types
		for (UmlClass thisClass : Types.values()) {
			String className = getURI(thisClass);
			List<UmlClassInstance> list = (List<UmlClassInstance>) (ElementsInType.get(className));
			if (list == null) {
				list = new ArrayList<UmlClassInstance>();
				ElementsInType.put(className, list);
			}
			for (UmlItem attribute : thisClass.children())
				if (attribute.kind() == anItemKind.anAttribute) {
					// trace("cacheModel: Caching " + getURI(attribute));
					UmlClassInstance ci = (UmlClassInstance) Elements.get(getURI(attribute));
					list.add(ci);
				}
		}

		if (rootPackage == referencePackage) {
			NiemElements = Elements;
			NiemElementsInType = ElementsInType;
			NiemTypes = Types;
			referenceAbstractType = NiemTypes
					.get(filterHash(LOCAL_PREFIX) + HASH_DELIMITER + filterHash(ABSTRACT_TYPE_NAME));
			referenceAnyElement = (UmlClassInstance) NiemElements
					.get(XSD_URI + HASH_DELIMITER + filterHash(ANY_ELEMENT_NAME));
			// referenceAbstractType = findType(referencePackage, localSchemaURI +
			// localPrefix, abstractTypeName);
			// if (referenceAbstractType == null)
			trace("cacheModel: reference abstract type not found");
		} else if (rootPackage == subsetPackage) {
			SubsetElements = Elements;
			SubsetElementsInType = ElementsInType;
			SubsetTypes = Types;
			subsetAbstractType = SubsetTypes
					.get(filterHash(LOCAL_PREFIX) + HASH_DELIMITER + filterHash(ABSTRACT_TYPE_NAME));
			subsetAugmentationType = SubsetTypes
					.get(filterHash(STRUCTURES_PREFIX) + HASH_DELIMITER + filterHash(AUGMENTATION_TYPE_NAME));
			subsetObjectType = SubsetTypes
					.get(filterHash(STRUCTURES_PREFIX) + HASH_DELIMITER + filterHash(OBJECT_TYPE_NAME));
			// subsetAbstractType = findType(subsetPackage, localSchemaURI + localPrefix,
			// abstractTypeName);
			// if (subsetAbstractType == null)
			trace("cacheModel: subset abstract type not found");
		} else if (rootPackage == extensionPackage) {
			ExtensionElements = Elements;
			ExtensionElementsInType = ElementsInType;
			ExtensionTypes = Types;
		}
	}

	private static String columnHtml(String value, String bgcolor, String fgcolor, Boolean wordwrap) {
		String style = wordwrap ? "word-wrap: break-word" : "";
		return "<td  style=\"" + style + "\" bgcolor=\"" + bgcolor + "\"><font color = \"" + fgcolor + "\">" + value
				+ "</font></td>";
	}

	// copy element from NIEM reference model to subset
	private static UmlClassInstance copyElement(String elementName) {
		trace("copyElement: Copying " + elementName + " to subset");
		// get schemaURI
		String prefix = getPrefix(elementName);
		String schemaURI = getURI(elementName);
		// String schemaURI = Prefixes.get(prefix);
		if (schemaURI == null) {
			UmlCom.trace("copyElement: Namespace not found for prefix " + prefix);
			return null;
		}
		// trace("copyElement: Namespace found");
		// if element already exists in subset, return
		String elementName2 = getName(elementName);
		UmlClassInstance element = findElement(subsetPackage, schemaURI, elementName2);
		if (element != null) {
			// trace("copyElement: Element " + element + " already exists in subset");
			return element;
		}

		// if type doesn't exist in reference model, return
		UmlClassInstance sourceElement = findElement(referencePackage, schemaURI, elementName2);
		if (sourceElement == null) {
			UmlCom.trace("copyElement: Element " + schemaURI + NAMESPACE_DELIMITER + elementName2
					+ " not found in reference");
			return null;
		}
		// trace("copyElement: Element found in reference model");

		// if namespace doesn't exist, create it
		UmlClassView nsClassView = addNamespace(subsetPackage, prefix, schemaURI);
		if (nsClassView == null) {
			UmlCom.trace("copyElement: Subset classview not found for " + schemaURI);
			return null;
		}

		// find base type
		UmlClass sourceBaseType = sourceElement.type();
		String baseTypeName = sourceBaseType.pretty_name();
		String baseSchemaURI = getURI(sourceBaseType.parent());
		UmlClass baseType = findType(subsetPackage, baseSchemaURI, baseTypeName);
		if (baseType == null)
			if (baseType == null) {
				Namespace ns = Namespaces.get(schemaURI);
				if (ns != null) {
					UmlClassView cv = ns.referenceClassView;
					if (cv != null) {
						String basePrefix = getPrefix(sourceBaseType);
						baseType = copyType(baseSchemaURI, basePrefix, baseTypeName);
					}
					if (baseType != null)
						SubsetTypes.put(getURI(baseType), baseType);
				}
				if (baseType == null) {
					UmlCom.trace("copyElement: Base type not found in subset for " + baseSchemaURI + NAMESPACE_DELIMITER
							+ baseTypeName);
					return null;
				}
			}
		// create element
		trace("copyElement: Copying element " + elementName2 + " to subset");
		element = UmlClassInstance.create(nsClassView, filterUMLName(elementName2), baseType);
		element.set_Description(sourceElement.description());
		setURI(element, getURI(sourceElement));

		return element;
	}

	// copy element in type from NIEM reference model to subset
	private static UmlAttribute copyElementInType(String typeName, UmlClassInstance classInstance,
			String multiplicity) {
		// String prefix = getPrefix(typeName);
		// String schemaURI = Prefixes.get(prefix);
		String schemaURI = getURI(typeName);
		if (schemaURI == null)
			return null;

		// trace("copyElementInType: Namespace found");
		// if type already exists in subset, return
		String typeName2 = getName(typeName);
		UmlClass type = findType(subsetPackage, schemaURI, typeName2);
		if (type == null) {
			UmlCom.trace("copyElementInType: type " + typeName + " not found");
			return null;
		}
		return copyElementInType(type, classInstance, multiplicity);
	}

	// copy element in type from NIEM reference model to subset
	private static UmlAttribute copyElementInType(UmlClass typeClass, UmlClassInstance classInstance,
			String multiplicity) {
		/*
		 * if (type == null) { UmlCom.trace("copyElementInType: type is null"); return
		 * null; } if (element == null) {
		 * UmlCom.trace("copElementInType: element is null"); return null; }
		 */
		trace("copyElementInType: Adding " + classInstance.pretty_name() + " to type " + typeClass.pretty_name());
		UmlAttribute attribute = null;
		for (UmlItem item : typeClass.children()) {
			if (item.kind() == anItemKind.anAttribute && item.name().equals(classInstance.pretty_name())) {
				attribute = (UmlAttribute) item;
				String previousMultiplicity = attribute.multiplicity();
				if (!previousMultiplicity.equals(multiplicity))
					UmlCom.trace("copyElementInType:  " + getPrefix(typeClass) + NAMESPACE_DELIMITER
							+ typeClass.pretty_name() + "/" + getPrefix(classInstance) + ":"
							+ classInstance.pretty_name() + " has conflicting multiplicities " + previousMultiplicity
							+ " and " + multiplicity);
				return attribute;
			}
		}
		if (attribute == null)
			try {
				attribute = UmlAttribute.create(typeClass, filterUMLName(classInstance.pretty_name()));
			} catch (RuntimeException re) {
				trace("copyElementInType: attribute already exists " + classInstance + " " + re.toString());
			}
		if (attribute != null) {
			attribute.set_Description(classInstance.description());
			setURI(attribute, getURI(classInstance));
			UmlTypeSpec classType2 = new UmlTypeSpec();
			classType2.type = classInstance.type();
			if (classType2.type != null)
				attribute.set_Type(classType2);
			attribute.set_Multiplicity(multiplicity);
		}
		return attribute;
	}

	// copy type from reference model to subset
	private static UmlClass copyType(String schemaURI, String prefix, String typeName) {
		UmlClass typeClass = findType(subsetPackage, schemaURI, typeName);
		if (typeClass != null) {
			// trace("copyType: Type " + prefix + ":" + typeName + " already exists in
			// subset");
			return typeClass;
		}

		// if type doesn't exist in reference model, return
		UmlClass sourceClass = findType(referencePackage, schemaURI, typeName);
		if (sourceClass == null) {
			UmlCom.trace("copyType: Type " + schemaURI + NAMESPACE_DELIMITER + typeName + " not found in reference");
			return null;
		}
		trace("copyType: type " + prefix + ":" + typeName + " found in reference model");
		// if namespace doesn't exist, create it
		UmlClassView nsClassView = addNamespace(subsetPackage, prefix, schemaURI);
		if (nsClassView == null) {
			UmlCom.trace("copyType: subset classview not found for " + schemaURI);
			return null;
		}
		trace("copyType: subset classview created " + nsClassView.pretty_name() + " " + getURI(nsClassView));
		// create type
		trace("copyType: copying type " + typeName + " to subset schema " + nsClassView.pretty_name());
		try {
			typeClass = UmlClass.create(nsClassView, filterUMLName(typeName));
		} catch (Exception e) {
			UmlCom.trace("copyType: type not found " + typeName + " " + e.toString());
		}
		if (typeClass == null) {
			UmlCom.trace("copyType: type not found " + typeName + " ");
			return null;
		}

		SubsetTypes.put(getURI(typeClass), typeClass);
		typeClass.set_Description(sourceClass.description());
		setURI(typeClass, getURI(sourceClass));
		String codeList = sourceClass.propertyValue(CODELIST_PROPERTY);
		if (codeList != null)
			typeClass.set_PropertyValue(CODELIST_PROPERTY, codeList);

		// copy base type
		for (UmlItem item : sourceClass.children()) {
			if (item.kind() == anItemKind.aRelation) {
				UmlRelation r = (UmlRelation) item;
				if (r.relationKind() == aRelationKind.aGeneralisation) {
					UmlClass sourceBaseType = r.roleType();
					String sourceBaseSchemaURI = getURI(sourceBaseType.parent());
					String sourceBasePrefix = getPrefix(sourceBaseType);
					// String sourceBasePrefix = sourceBaseType.parent().name();
					// String sourceBaseSchemaURI = Prefixes.get(sourceBasePrefix);
					String sourceBaseTagName = sourceBaseType.name();
					trace("copyType: copying base type " + sourceBasePrefix + NAMESPACE_DELIMITER + sourceBaseTagName
							+ " to subset");
					UmlClass baseType = copyType(sourceBaseSchemaURI, sourceBasePrefix, sourceBaseTagName);
					if (baseType == null) {
						UmlCom.trace("copyType: base type not found " + sourceBaseTagName);
						continue;
					}
					SubsetTypes.put(getURI(baseType), baseType);
					try {
						UmlBaseRelation.create(aRelationKind.aGeneralisation, typeClass, baseType);
					} catch (Exception re) {
						trace("copyType: " + typeClass + " already related to base type " + sourceBaseTagName + " "
								+ re.toString());
					}
				} else if (r.relationKind() == aRelationKind.aDirectionalAggregation) {
					UmlClass sourceBaseType = r.roleType();
					String sourceBaseSchemaURI = getURI(sourceBaseType.parent());
					String sourceBasePrefix = getPrefix(sourceBaseType);
					// String sourceBasePrefix = sourceBaseType.parent().name();
					// String sourceBaseSchemaURI = Prefixes.get(sourceBasePrefix);
					String sourceBaseTagName = sourceBaseType.name();
					trace("copyType: copying attribute group " + sourceBasePrefix + NAMESPACE_DELIMITER
							+ sourceBaseTagName + " to subset");
					UmlClass baseType = copyType(sourceBaseSchemaURI, sourceBasePrefix, sourceBaseTagName);
					if (baseType == null) {
						UmlCom.trace("copyType: attribute group not found " + sourceBaseTagName);
						continue;
					}
					SubsetTypes.put(getURI(baseType), baseType);
					try {
						UmlBaseRelation.create(aRelationKind.aDirectionalAggregation, typeClass, baseType);
					} catch (Exception re) {
						trace("copyType: " + typeClass + " already related to attribute group " + sourceBaseTagName
								+ " " + re.toString());
					}
				}
			}
		}
		return typeClass;
	}

	// copy type from NIEM reference model to subset
	private static UmlClass copyTypeByPrefix(String typeName) {
		trace("copyType: Copying " + typeName + " to subset");
		// get schemaURI
		String prefix = getPrefix(typeName);
		// String schemaURI = Prefixes.get(prefix);
		String schemaURI = getURI(typeName);
		if (schemaURI == null) {
			UmlCom.trace("copyType: Namespace not found for prefix " + prefix);
			return null;
		}
		// trace("copyType: Namespace found");
		// if type already exists in subset, return
		String typeName2 = getName(typeName);
		return copyType(schemaURI, prefix, typeName2);
	}

	// create Platform Independent Model (NIEM)
	public static void createNIEM(UmlPackage root) {
		UmlPackage pimPackage = null;

		trace("createNIEM: Creating NIEM folders");
		// Find or create NIEM package
		for (UmlItem ch : root.children()) {
			if (ch.pretty_name().equals("NIEM"))
				if ((ch.kind().value() == anItemKind._aPackage)) {
					pimPackage = (UmlPackage) ch;
					break;
				}
		}
		if (pimPackage == null) {
			pimPackage = UmlPackage.create(root, "NIEM");
			trace("createNIEM: Creating NIEM");
		}

		// Find or create package "NIEMSubset"
		for (UmlItem ch : pimPackage.children()) {
			if (ch.pretty_name().equals("NIEMSubset"))
				if ((ch.kind().value() == anItemKind._aPackage)) {
					subsetPackage = (UmlPackage) ch;
					break;
				}
		}
		if (subsetPackage == null) {
			trace("createNIEM: Creating NIEMSubset");
			subsetPackage = UmlPackage.create(pimPackage, "NIEMSubset");
		}
		// Find or create package "NIEMExtension"
		for (UmlItem ch : pimPackage.children()) {
			if (ch.pretty_name().equals("NIEMExtension"))
				if ((ch.kind().value() == anItemKind._aPackage)) {
					extensionPackage = (UmlPackage) ch;
					break;
				}
		}
		if (extensionPackage == null) {
			trace("createNIEML: Creating NIEMExtension");
			extensionPackage = UmlPackage.create(pimPackage, "NIEMExtension");
		}

		// Find or create package "NIEMReference"
		for (UmlItem ch : pimPackage.children()) {
			if (ch.pretty_name().equals("NIEMReference"))
				if ((ch.kind().value() == anItemKind._aPackage)) {
					referencePackage = (UmlPackage) ch;
					break;
				}
		}
		if (referencePackage == null)
			referencePackage = UmlPackage.create(pimPackage, "NIEMReference");
		referencePackage.set_Stereotype("framework");
	}

	// create NIEM subset and extension
	public static void createSubsetAndExtension() {

		// String[] nextLine = new String[map.length];

		trace("createSubsetAndExtension: Creating subset");
		// cache NIEM namespaces, elements and types
		trace("createSubsetAndExtension: Cache reference model");
		cacheModel(referencePackage);
		trace("createSubsetAndExtension: Cache subset model");
		cacheModel(subsetPackage);
		trace("createSubsetAndExtension: Cache extension model");
		cacheModel(extensionPackage);

		// add abstract types
		if (subsetAbstractType == null) {
			String localUri = LOCAL_PREFIX;
			UmlClassView classView = addNamespace(subsetPackage, LOCAL_PREFIX, localUri);
			subsetAbstractType = addReferenceType(classView, getURI(classView), ABSTRACT_TYPE_NAME, "abstract type",
					"");
			if (subsetAbstractType != null)
				SubsetTypes.put(getURI(subsetAbstractType), subsetAbstractType);
			// subsetAbstractType = copyType("local:abstract");
		}

		// Copy subset base types
		trace("createSubsetAndExtension: Copy subset base types");
		if (subsetObjectType == null) {
			subsetObjectType = copyTypeByPrefix(STRUCTURES_PREFIX + NAMESPACE_DELIMITER + OBJECT_TYPE_NAME);
			if (subsetObjectType != null)
				SubsetTypes.put(getURI(subsetObjectType), subsetObjectType);
		}
		if (subsetAugmentationType == null) {
			subsetAugmentationType = copyTypeByPrefix(STRUCTURES_PREFIX + NAMESPACE_DELIMITER + AUGMENTATION_TYPE_NAME);
			if (subsetAugmentationType != null)
				SubsetTypes.put(getURI(subsetAugmentationType), subsetAugmentationType);
		}
		// Copy base types to subset
		UmlClass type;
		for (int i = 0; i < UmlItem.all.size(); i++) {
			UmlItem c = (UmlItem) UmlItem.all.elementAt(i);
			if (c.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
				String baseTypeName = c.propertyValue(niemProperty(7));
				// if (!baseTypeName.equals("") && !baseTypeName.equals("??") &&
				// !isExternal(baseTypeName))
				if (!baseTypeName.equals("") && !baseTypeName.equals("??")) {
					if (isNiemType(baseTypeName)) {
						trace("createSubsetAndExtension: adding base type " + baseTypeName + " to subset");
						type = copyTypeByPrefix(baseTypeName);
						if (type != null)
							SubsetTypes.put(getURI(type), type);
					}
				}
			}
		}

		// Copy subset types and create extension types
		trace("createSubsetAndExtension: Copy subset types and create extension types");
		for (int i = 0; i < UmlItem.all.size(); i++) {
			UmlItem c = (UmlItem) UmlItem.all.elementAt(i);
			if (c.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
				String typeName = c.propertyValue(niemProperty(5)).trim();
				String elementName = c.propertyValue(niemProperty(6)).trim();
				String notes = c.propertyValue(niemProperty(11)).trim();
				String description = null;
				if (elementName.equals(""))
					description = c.description().trim();
				if (typeName.endsWith("AugmentationType"))
					description = "An augmentation type";

				// if (!typeName.equals("") && !typeName.equals("??") && !isExternal(typeName))
				// {
				if (!typeName.equals("") && !typeName.equals("??")) {
					if (isNiemType(typeName)) {
						trace("createSubsetAndExtension: adding type " + typeName + " to subset");
						type = copyTypeByPrefix(typeName);
						if (type != null)
							SubsetTypes.put(getURI(type), type);
					} else {
						trace("createSubsetAndExtension: adding type " + typeName + " to extension");
						// String prefix = getPrefix(typeName);
						String schemaURI = getURI(typeName);
						// String schemaURI = Prefixes.get(prefix);
						Namespace ns = findNamespace(schemaURI);
						if (ns != null && ns.referenceClassView != null) {
							UmlCom.trace(
									"createSubsetAndExtension: type " + typeName + " not found in reference model");
							continue;
						}
						type = addExtensionType(typeName, description, notes);
						if (type != null) {
							String uri = getURI(type);
							trace("createSubsetAndExtension: added " + uri + " to extension");
							ExtensionTypes.put(uri, type);
						}
					}
				}
			}
		}

		// Copy subset elements and create extension elements
		trace("createSubsetAndExtension: Copy subset elements and create extension elements");
		for (int i = 0; i < UmlItem.all.size(); i++) {
			UmlItem item = (UmlItem) UmlItem.all.elementAt(i);
			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
				String typeName = item.propertyValue(niemProperty(5)).trim();
				String elementList = item.propertyValue(niemProperty(6)).trim();
				String baseTypeName = item.propertyValue(niemProperty(7)).trim();
				String multiplicity = item.propertyValue(niemProperty(8)).trim();
				String description = item.description().trim();
				String mappingNotes = item.propertyValue(niemProperty(11)).trim();
				String codeList = item.propertyValue(niemProperty(12)).trim();

				if (elementList.contains("Augmentation"))
					description = "An augmentation";

				// if (!elementName.equals("") && !elementName.equals("??") &&
				// !isExternal(elementName)) {
				if (!elementList.equals("") && !elementList.equals("??")) {
					// String elementName2 = elementName.replace(" ", "").replace("(",
					// "").replace(")", "");
					String[] elementNames = elementList.split(",");
					String headElement = null;
					Boolean substitution = elementList.contains("(");
					for (String elementName : elementNames) {
						if (elementName == null)
							continue;
						String elementName1 = elementName.trim();
						// String elementName2 = elementName1;
						if (substitution && headElement == null)
							headElement = elementName1;
						boolean representation = false;
						if (elementName1.startsWith("(") && elementName1.endsWith(")")) {
							representation = true;
							elementName1 = elementName1.substring(1, elementName1.length() - 1);
						}
						Boolean isNillable = elementName1.startsWith(REFERENCE_PREFIX);
						if (isNillable)
							elementName1 = elementName1.substring(1);
						if (isNiemElement(elementName1)) {
							trace("createSubsetAndExtension: adding element " + elementName1 + " in subset");
							UmlClassInstance element = copyElement(elementName1);
							if (element == null) {
								UmlCom.trace("createSubsetAndExtension: could not create element " + elementName1);
								continue;
							}
							SubsetElements.put(getURI(element), element);
							trace("createSubsetAndExtension: added " + getURI(element) + " to subset");
							if (isNillable)
								element.set_PropertyValue(NILLABLE_PROPERTY, "true");
							if (substitution && representation && headElement != null)
								element.set_PropertyValue(SUBSTITUTION_PROPERTY, headElement);
							if (!codeList.equals("") && (!substitution || representation))
								element.set_PropertyValue(CODELIST_PROPERTY, codeList);
							if (!representation && !typeName.equals("")
									&& isNiemElementInType(typeName, elementName1)) {
								trace("createSubsetAndExtension: adding element " + elementName1 + " in type "
										+ typeName + " in subset");
								String className = getURI(element.parent());
								List<UmlClassInstance> enlist = (List<UmlClassInstance>) (SubsetElementsInType
										.get(className));
								if (enlist == null) {
									enlist = new ArrayList<UmlClassInstance>();
									SubsetElementsInType.put(className, enlist);
								}
								copyElementInType(typeName, element, multiplicity);
							}
						} else {
							trace("createSubsetAndExtension: adding element " + elementName + " in extension");
							String prefix = getPrefix(elementName1);
							String schemaURI = Prefixes.get(prefix);
							String baseTagName = baseTypeName.trim();
							if (substitution && !representation)
								baseTagName = ABSTRACT_TYPE_NAME;
							Namespace ns = findNamespace(schemaURI);
							if (ns != null && ns.referenceClassView != null) {
								UmlCom.trace("createSubseAndExtensiont: element " + elementName1
										+ " not found in reference model");
								continue;
							}
							if (baseTagName.equals("")) {
								UmlCom.trace(
										"createSubsetAndExtension: base type not found for element " + elementName1);
								continue;
							}
							UmlClassInstance classInstance = addExtensionElement(elementName1, baseTagName, description,
									mappingNotes);
							if (classInstance == null) {
								UmlCom.trace("createSubsetAndExtension: could not create element " + elementName1);
								continue;
							}
							ExtensionElements.put(getURI(classInstance), classInstance);
							trace("createSubsetAndExtension: added " + getURI(classInstance) + " to extension");
							if (isNillable)
								classInstance.set_PropertyValue(NILLABLE_PROPERTY, "true");
							if (substitution && representation && headElement != null)
								classInstance.set_PropertyValue(SUBSTITUTION_PROPERTY, headElement);
							if (!codeList.equals("") && (!substitution || representation))
								classInstance.set_PropertyValue(CODELIST_PROPERTY, codeList);
						}
					}
				}
			}
		}

		// Create extension base types
		trace("createSubsetAndExtension: copy subset base types and create extension base types");
		UmlClass attributeGroupType = findType(subsetPackage, Prefixes.get("structures"),
				"@SimpleObjectAttributeGroup");

		for (int i = 0; i < UmlItem.all.size(); i++) {
			UmlItem c = (UmlItem) UmlItem.all.elementAt(i);
			if (c.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
				String typeName = c.propertyValue(niemProperty(5)).trim();
				String elementName = c.propertyValue(niemProperty(6)).trim();
				String baseTypeName = c.propertyValue(niemProperty(7)).trim();

				if (!typeName.equals("") && !typeName.equals("??") && !baseTypeName.equals("")
						&& elementName.equals("")) {
					String tagName = getName(typeName);
					String prefix = getPrefix(typeName);
					String schemaURI = Prefixes.get(prefix);
					String baseTagName = getName(baseTypeName);
					String basePrefix = getPrefix(baseTypeName);
					String baseSchemaURI = Prefixes.get(basePrefix);
					UmlClass baseType;
					// if (isNiemType(typeName) || isExternal(typeName))
					if (isNiemType(typeName))
						continue;
					type = findType(extensionPackage, schemaURI, tagName);
					if (type == null) {
						UmlCom.trace("createSubsetAndExtension: type not found " + typeName);
						continue;
					}
					if (isNiemType(baseTypeName))
						baseType = findType(subsetPackage, baseSchemaURI, baseTagName);
					else
						baseType = findType(extensionPackage, baseSchemaURI, baseTagName);
					if (baseType == null) {
						UmlCom.trace("createSubsetAndExtension: base type not found " + baseTypeName);
						continue;
					}
					try {
						UmlBaseRelation.create(aRelationKind.aGeneralisation, type, baseType);
					} catch (Exception re) {
						trace("createSubsetAndExtension: " + typeName + " already related to base type " + baseTypeName
								+ " " + re.toString());
					}
					// Add attribute group if based on a simple type
					if (basePrefix.equals(XSD_PREFIX)) {
						try {
							UmlBaseRelation.create(aRelationKind.aDirectionalAggregation, type, attributeGroupType);
						} catch (Exception re) {
							trace("createSubsetAndExtension: " + typeName + " already related to attribute group "
									+ re.toString());
						}
					}
				}

				// Add generalizations for extension augmentations
				if (typeName.endsWith(AUGMENTATION_TYPE_NAME)) {
					String tagName = getName(typeName);
					String prefix = getPrefix(typeName);
					String schemaURI = Prefixes.get(prefix);
					// if (isNiemType(typeName) || isExternal(typeName))
					if (isNiemType(typeName))
						continue;
					type = findType(extensionPackage, schemaURI, tagName);
					if (type == null) {
						UmlCom.trace("createSubsetAndExtension: type not found " + typeName);
						continue;
					}
					try {
						UmlBaseRelation.create(aRelationKind.aGeneralisation, type, subsetAugmentationType);
					} catch (Exception re) {
						trace("createSubsetAndExtension: " + typeName + " already related to base type " + baseTypeName
								+ " " + re.toString());
					}
				}
			}
		}

		// Add extension elements in type
		trace("createSubsetAndExtension: Add extension elements in type");
		for (int i = 0; i < UmlItem.all.size(); i++) {
			UmlItem c = (UmlItem) UmlItem.all.elementAt(i);
			if (c.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
				String typeName = c.propertyValue(niemProperty(5)).trim();
				String elementName = c.propertyValue(niemProperty(6)).trim();
				String multiplicity = c.propertyValue(niemProperty(8)).trim();

				if (!typeName.equals("") && !isNiemType(typeName)) {
					if (!elementName.equals("") && !elementName.equals("??")) {
						String[] elements = elementName.split(",");
						for (String e : elements) {
							String elementName1 = e.trim();
							if (elementName1.startsWith("(") && elementName1.endsWith(")"))
								continue;
							Boolean isNillable = elementName1.startsWith(REFERENCE_PREFIX);
							if (isNillable)
								elementName1 = elementName1.substring(1);
							trace("createSubsetAndExtension: adding element " + elementName1 + " in type " + typeName
									+ " in subset");
							UmlClassInstance element;
							if (isNiemElement(elementName1))
								element = findElementByName(subsetPackage, elementName1);
							else
								element = findElementByName(extensionPackage, elementName1);
							if (element != null) {
								String className = getURI(element.parent());
								List<UmlClassInstance> enlist = (List<UmlClassInstance>) (ExtensionElementsInType
										.get(className));
								if (enlist == null) {
									enlist = new ArrayList<UmlClassInstance>();
									ExtensionElementsInType.put(className, enlist);
								}
								enlist.add(element);
								addExtensionElementInType(typeName, element, multiplicity);
							}
						}
					}
				}
			}
		}

		// Sorting
		trace("createSubsetAndExtension: sorting namespaces");
		subsetPackage.sort();
		extensionPackage.sort();
	}

	// reset NIEM mappings
	public static void deleteMapping() {
		@SuppressWarnings("unchecked")
		Iterator<UmlItem> it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE) && item.kind() != anItemKind.aClassInstance)
				for (int p = 4; p < NIEM_STEREOTYPE_MAP.length; p++)
					item.set_PropertyValue(niemProperty(p), "");
		}
	}

	/*
	 * // delete PIM model public static void deleteSubset(UmlPackage root) {
	 * UmlPackage pimPackage = null;
	 * 
	 * trace("deleteSubset: deleting Subset");
	 * 
	 * // Find PIM package for (UmlItem ch : root.children()) { if
	 * (ch.pretty_name().equals("NIEM")) if ((ch.kind().value() ==
	 * anItemKind._aPackage)) { pimPackage = (UmlPackage) ch; break; } } if
	 * (pimPackage == null) { UmlCom.trace("deleteSubset: NIEM not found"); return;
	 * }
	 * 
	 * // Delete children of package "NIEMSubset" for (UmlItem ch :
	 * pimPackage.children()) { if (ch.pretty_name().equals("NIEMSubset")) if
	 * ((ch.kind().value() == anItemKind._aPackage)) { subsetPackage = (UmlPackage)
	 * ch; trace("deleteSubset: deleting NIEMSubset"); // subsetPackage.deleteIt();
	 * break; } } for (UmlItem item : subsetPackage.children()) item.deleteIt();
	 * 
	 * // Delete package "NIEMExtension" for (UmlItem ch : pimPackage.children()) {
	 * if (ch.pretty_name().equals("NIEMExtension")) if ((ch.kind().value() ==
	 * anItemKind._aPackage)) { extensionPackage = (UmlPackage) ch;
	 * trace("deleteSubset: deleting NIEMExtension"); //
	 * extensionPackage.deleteIt(); break; } } for (UmlItem item :
	 * extensionPackage.children()) item.deleteIt(); }
	 */
	// generate Genericode code list
	private static void exportCodeList(String dir, String elementName, String codeListURI, String codeList,
			String version, String date) {
		try {
			FileWriter fw;

			// export code list
			fw = new FileWriter(dir + "/" + elementName + GC_FILE_TYPE);
			fw.write(XML_HEADER + XML_ATTRIBUTION + "<gc:CodeList ");
			xmlNS(fw, CT_PREFIX, CT_URI);
			xmlNS(fw, GC_PREFIX, GC_URI);
			xmlNS(fw, GC_APPINFO_PREFIX, GC_APPINFO_URI);
			xmlNS(fw, XSI_PREFIX, XSI_URI);
			xmlAttribute(fw, XSI_PREFIX + ":schemaLocation", GC_URI + " " + GC_LOCATION);
			fw.write(">" + "<Annotation>" + "<AppInfo>" + "<gca:ConformanceTargets ct:conformanceTargets=\""
					+ CODELIST_URI + "#GenericodeCodeListDocument\"/>" + "</AppInfo>" + "</Annotation>"
					+ "<Identification>" + "<ShortName>" + elementName + "</ShortName>" + "<Version>" + version
					+ "</Version>" + "<CanonicalUri>" + codeListURI + "</CanonicalUri>" + "<CanonicalVersionUri>"
					+ codeListURI + "/" + date + "</CanonicalVersionUri>" + "</Identification>" + "<ColumnSet>"
					+ "<Column Id=\"" + CODELIST_CODE + "\" Use=\"required\">" + "<ShortName>" + CODELIST_CODE
					+ "</ShortName>" + "<CanonicalUri>" + CODELIST_URI + "column/" + CODELIST_CODE + "</CanonicalUri>"
					+ "<Data Type=\"normalizedString\" Lang=\"en\"/>" + "</Column>" + "<Column Id=\""
					+ CODELIST_DEFINITION + "\" Use=\"optional\">" + "<ShortName>" + CODELIST_DEFINITION
					+ "</ShortName>" + "<CanonicalUri>" + CODELIST_URI + "column/" + CODELIST_DEFINITION
					+ "</CanonicalUri>" + "<Data Type=\"normalizedString\" Lang=\"en\"/>" + "</Column>"
					+ "<Key Id=\"codeKey\">" + "<ShortName>CodeKey</ShortName>" + "<ColumnRef Ref=\"" + CODELIST_CODE
					+ "\"/>" + "</Key>" + "</ColumnSet>" + "<SimpleCodeList>");
			if (codeList.contains(CODELIST_DELIMITER)) {
				String[] codes = codeList.split(CODELIST_DELIMITER);
				for (String code : codes) {
					String[] pairs = code.split(CODELIST_DEFINITION_DELIMITER);
					fw.write("<Row><Value ColumnRef=\"" + CODELIST_CODE + "\"><SimpleValue>" + pairs[0].trim()
							+ "</SimpleValue></Value>");
					if (pairs.length > 1)
						fw.write("<Value ColumnRef=\"" + CODELIST_DEFINITION + "\"><SimpleValue>" + pairs[1].trim()
								+ "</SimpleValue></Value>");
					fw.write("</Row>");
				}
			}
			fw.write("</SimpleCodeList></gc:CodeList>");
			fw.close();

		} catch (IOException e) {
			UmlCom.trace("exportCodeList: IO exception: " + e.toString());
		} catch (RuntimeException e) {
			UmlCom.trace("exportCodeList: Runtime Exception: " + e.toString());
		}

	}

	// generate NIEM mapping spreadsheet in CSV format
	// roundtripping is supported with importCsv()
	public static void exportCsv(String dir, String filename) {

		setExternalSchemas();

		UmlItem.directory = dir;

		trace("exportCsv: reating CSV file" + dir + "/" + filename);

		try {
			FileWriter fw = new FileWriter(dir + "/" + filename);
			CSVWriter writer = new CSVWriter(fw);

			trace("exportCsv: CSV file created " + dir + "/" + filename);

			// Write header
			String[] nextLine = new String[NIEM_STEREOTYPE_MAP.length];
			trace("exportCsv: header");
			for (int i = 0; i < NIEM_STEREOTYPE_MAP.length; i++) {
				nextLine[i] = NIEM_STEREOTYPE_MAP[i][0];
				trace("exportCsv: " + nextLine[i]);
			}
			writer.writeNext(nextLine);

			// Export NIEM Mappings for Classes
			trace("exportCsv: rows");
			for (int i = 0; i < UmlClass.classes.size(); i++) {
				UmlItem c = (UmlItem) UmlClass.classes.elementAt(i);

				if (c.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
					nextLine = itemCsv(c);
					trace("exportCsv: 0:" + nextLine[0] + " 1:" + nextLine[1] + "2:" + nextLine[2] + " 3:"
							+ nextLine[3]);
					writer.writeNext(nextLine);

					// Export NIEM Mapping for Attributes and Relations
					for (UmlItem ch : c.children())
						if (ch.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
							nextLine = itemCsv(ch);
							if (nextLine != null) {
								trace("exportCsv: 0:" + nextLine[0] + " 1:" + nextLine[1] + " 2:" + nextLine[2] + " 3:"
										+ nextLine[3]);
								writer.writeNext(nextLine);
							}
						}
				}
			}
			writer.close();

		} catch (Exception e) {
			UmlCom.trace("exportCsv: exception " + e.toString());
		}
	}

	// generate NIEM mapping spreadsheet in HTML format
	public static void exportHtml(String dir, String filename) {

		setExternalSchemas();
		// cache NIEM namespaces, elements and types
		cacheModel(referencePackage);
		try {
			// Write rest of header
			FileWriter fw = new FileWriter(dir + "/" + filename + HTML_FILE_TYPE);
			fw.write("<html>");
			fw.write("<head><title>" + MAPPING_SPREADSHEET_TITLE
					+ "</title><link rel=\"stylesheet\" href=\"style.css\" type=\"text/css\" /></head>"
					+ "<body><div class = \"title\">" + MAPPING_SPREADSHEET_TITLE + "</div>"
					+ "<table style=\"table-layout: fixed; width: 100%\"><tr bgcolor=\"#f0f0f0\">");
			for (int i = 0; i < NIEM_STEREOTYPE_MAP.length; i++)
				fw.write("<td style=\"word-wrap: break-word\">" + NIEM_STEREOTYPE_MAP[i][0] + "</td>");
			fw.write("</tr>\n");

			// Show NIEM Mappings for Classes
			for (int i = 0; i < UmlClass.classes.size(); i++) {
				UmlItem c = (UmlItem) UmlClass.classes.elementAt(i);
				if (c.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
					writeLineHtml(fw, c);

					// Show NIEM Mapping for Attributes and Relations
					for (UmlItem ch : c.children())
						if (ch.stereotype().equals(NIEM_STEREOTYPE_TYPE))
							writeLineHtml(fw, ch);
				}
			}
			fw.write("</table>\n");
			fw.write("</body></html>");
			fw.close();
		} catch (Exception e) {
			UmlCom.trace("exportHtml: exception " + e.toString());
		}
	}

	/*
	 * // delete PIM model public static void deleteNIEM(UmlPackage root) {
	 * UmlPackage pimPackage = null;
	 * 
	 * trace("deleteNIEM: deleting PIM"); deleteSubset(root);
	 * 
	 * // Delete reference model for (UmlItem ch : root.children()) { if
	 * (ch.pretty_name().equals("NIEM")) if ((ch.kind().value() ==
	 * anItemKind._aPackage)) { pimPackage = (UmlPackage) ch; //
	 * pimPackage.deleteIt(); break; } } // Find PIM package for (UmlItem ch :
	 * root.children()) { if (ch.pretty_name().equals("NIEM")) if
	 * ((ch.kind().value() == anItemKind._aPackage)) { pimPackage = (UmlPackage) ch;
	 * break; } } if (pimPackage == null) {
	 * UmlCom.trace("deleteNIEM: NIEM not found"); return; }
	 * 
	 * // Delete children of package "NIEMSubset" for (UmlItem ch :
	 * pimPackage.children()) { if (ch.pretty_name().equals("NIEMReference")) if
	 * ((ch.kind().value() == anItemKind._aPackage)) { referencePackage =
	 * (UmlPackage) ch; trace("createSubsetAndExtension: deleting NIEMExtension");
	 * // subsetPackage.deleteIt(); break; } } for (UmlItem item :
	 * referencePackage.children()) item.deleteIt(); }
	 */

	// generate IEPD including extension and exchange schema
	public static void exportIEPD(String xmlDir, String jsonDir) {

		setExternalSchemas();
		cacheModel(referencePackage);
		cacheModel(subsetPackage);
		cacheModel(extensionPackage);

		DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date();
		String today = dateFormat.format(date);

		exportSchema(subsetPackage, null, jsonDir + "/" + NIEM_DIR);
		exportSchema(extensionPackage, xmlDir, jsonDir);

		Boolean exportXML = (xmlDir != null);
		Boolean exportJSON = (jsonDir != null);

		try {
			Set<String> CodeListNamespaces = new HashSet<String>();

			// export code lists for extension elements
			for (UmlItem item : extensionPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					classView.sort();
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClassInstance) {
							UmlClassInstance classInstance = (UmlClassInstance) item2;
							String elementName = classInstance.name();
							String codeList = classInstance.propertyValue(CODELIST_PROPERTY);
							if (codeList != null) {
								String codeListURI = extensionSchema(elementName);
								exportCodeList(xmlDir, elementName, codeListURI, codeList,
										getProperty(IEPD_VERSION_PROPERTY), today);
								CodeListNamespaces.add(elementName);
							}
						}
				}

			// export code lists for subset elements
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					classView.sort();
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClassInstance) {
							UmlClassInstance classInstance = (UmlClassInstance) item2;
							String elementName = classInstance.name();
							String codeList = classInstance.propertyValue(CODELIST_PROPERTY);
							if (codeList != null) {
								String codeListURI = extensionSchema(elementName);
								exportCodeList(xmlDir, elementName, codeListURI, codeList,
										getProperty(IEPD_VERSION_PROPERTY), today);
								CodeListNamespaces.add(elementName);
							}
						}
				}

			if (exportXML) {
				// export catalog file
				exportXMLCatalog(xmlDir, CodeListNamespaces);
			}

			// cache list of ports, operations and messages
			trace("exportIEPD: cache ports, operations and messages");
			Map<String, UmlClass> ports = new TreeMap<String, UmlClass>();
			Map<String, UmlOperation> operations = new TreeMap<String, UmlOperation>();
			Set<String> messages = new TreeSet<String>();
			Map<String, String> outputMessages = new TreeMap<String, String>();
			Map<String, ArrayList<String>> inputMessages = new TreeMap<String, ArrayList<String>>();
			for (int i = 0; i < UmlClass.classes.size(); i++) {
				UmlItem item = (UmlItem) UmlClass.classes.elementAt(i);
				if (item.stereotype().equals("interface")) {
					UmlClass thisClass = (UmlClass) item;
					String portName = thisClass.name();
					ports.put(portName, thisClass);
					trace("exportIEPD: port: " + thisClass.name());
					for (UmlItem item2 : thisClass.children()) {
						if (item2.kind() == anItemKind.anOperation) {
							UmlOperation operation = (UmlOperation) item2;
							String operationName = operation.name();
							trace("exportIEPDa: operation: " + operationName);
							operations.put(operationName, operation);
							UmlClass thisClass2 = null, thisClass3 = null;
							UmlParameter[] params = operation.params();
							if (params != null)
								for (UmlParameter param : params) {
									try {
										thisClass3 = param.type.type;
										// String mult = param.multiplicity;
									} catch (Exception e) {
										UmlCom.trace("exportIEPD: could not find input message for " + operationName);
									}
									if (thisClass3 != null) {
										if (thisClass3.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
											String inputMessage = thisClass3.propertyValue(niemProperty(4));
											if (inputMessage != null && !inputMessage.equals("")) {
												trace("exportIEPD: input Message: " + inputMessage + " from operation "
														+ operationName);
												messages.add(inputMessage);
												if (param.multiplicity != null)
													inputMessage = inputMessage + "," + param.multiplicity;
												else
													inputMessage = inputMessage + ",1";
												ArrayList<String> inputs = inputMessages.get(operationName);
												if (inputs == null)
													inputs = new ArrayList<String>();
												if (!inputs.contains(inputMessage))
													inputs.add(inputMessage);
												inputMessages.put(operationName, inputs);
											}
										}
									}
								}
							try {
								thisClass2 = operation.returnType().type;
							} catch (Exception e) {
								UmlCom.trace("exportIEPD: could not find output message for " + operationName + " "
										+ e.toString());
							}
							if (thisClass2 != null) {
								if (thisClass2.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
									String outputMessage = thisClass2.propertyValue(niemProperty(4));
									if (outputMessage != null && !outputMessage.equals("")) {
										trace("exportIEPD: output Message: " + outputMessage + " from operation "
												+ operationName);
										messages.add(outputMessage);
										outputMessages.put(operationName, outputMessage);
									}
								}
							}
						}
					}
				}
			}

			if (exportXML) {
				exportMPDCatalog(xmlDir, CodeListNamespaces, messages);
				exportWSDL(xmlDir, ports, operations, messages, outputMessages, inputMessages);
			}

			if (exportJSON) {
				// TODO export OpenAPI file
			}

		} catch (IOException e) {
			UmlCom.trace("exportIEPD: IO exception: " + e.toString());
		}
	}

	// export WSDL definitions file
	private static void exportWSDL(String xmlDir, Map<String, UmlClass> ports, Map<String, UmlOperation> operations,
			Set<String> messages, Map<String, String> outputMessages, Map<String, ArrayList<String>> inputMessages)
			throws IOException {

		String WSDLURI = getProperty(IEPD_URI_PROPERTY) + WSDL_SUFFIX;
		String WSDLXSDURI = getProperty(IEPD_URI_PROPERTY) + WSDL_XSD_SUFFIX;

		UmlCom.trace("Generating document/literal wrapper schema");
		FileWriter xml = new FileWriter(xmlDir + "/" + WSDL_XSD_SUFFIX + XSD_FILE_TYPE);
		xml.write("<xs:schema targetNamespace=\"" + WSDLXSDURI + "\"");
		xmlNS(xml, WSDL_XSD_PREFIX, WSDLXSDURI);

		// build list of referenced namespaces
		Set<String> RefNamespaces = new TreeSet<String>();
		RefNamespaces.add(XSD_PREFIX);
		// RefNamespaces.add(structuresPrefix);
		for (String message : messages)
			RefNamespaces.add(getPrefix(message));
		for (String nsPrefix : RefNamespaces)
			xml.write(" " + NAMESPACE_ATTRIBUTE + ":" + nsPrefix + "=\"" + Prefixes.get(nsPrefix) + "\"");
		xml.write(" elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\">");
		for (String nsPrefix : RefNamespaces) {
			String nsSchemaURI = Prefixes.get(nsPrefix);
			if (isExternalPrefix(nsPrefix)) {
				if (nsSchemaURI != null)
					xml.write("<xs:import namespace=\"" + nsSchemaURI + "\" schemaLocation=\""
							+ externalSchemaURL.get(nsSchemaURI) + "\"/>");
			} else if (!nsPrefix.equals(XSD_PREFIX)) {
				Namespace ns = Namespaces.get(nsSchemaURI);
				if (ns != null)
					xml.write("<xs:import namespace=\"" + Prefixes.get(nsPrefix) + "\" schemaLocation=\"" + ns.filepath
							+ "\"/>");
			}
		}

		xml.write("<!-- document/literal wrappers -->");
		for (UmlOperation operation : operations.values()) {
			String operationName = operation.name();
			trace("exportWSDL: generating document/literal wrapper for " + operationName);
			ArrayList<String> inputs = inputMessages.get(operationName);
			if (inputs != null) {
				String inputType = operationName + "RequestType";
				xml.write("<xs:complexType name=\"" + inputType + "\">" + "<xs:sequence>");
				for (String inputMessage : inputs) {
					String inputMessage2 = inputMessage;
					String mult = "1";
					if (inputMessage.contains(",")) {
						String inputMessageParts[] = inputMessage.split(",");
						inputMessage2 = inputMessageParts[0];
						if (inputMessageParts.length > 1) {
							mult = inputMessageParts[1];
						}
					}
					String minoccurs = "1";
					String maxoccurs = "1";
					if (!(mult.equals(""))) {
						if (mult.contains("..")) {
							String[] occurs = mult.split("\\.\\.");
							minoccurs = occurs[0];
							maxoccurs = occurs[1];
						} else
							minoccurs = maxoccurs = mult;
					}
					if (maxoccurs.equals("*"))
						maxoccurs = "unbounded";

					if (isExternalPrefix(getPrefix(inputMessage2)))
						xml.write("<!--xs:element ref=\"" + inputMessage2 + "\" minOccurs=\"" + minoccurs
								+ "\" maxOccurs=\"" + maxoccurs + "\"/-->\n");
					else
						xml.write("<xs:element ref=\"" + inputMessage2 + "\" minOccurs=\"" + minoccurs
								+ "\" maxOccurs=\"" + maxoccurs + "\"/>\n");

				}
				xml.write("</xs:sequence>" + "</xs:complexType>" + "<xs:element name=\"" + operationName
						+ "Request\" type=\"" + WSDL_XSD_PREFIX + ":" + inputType + "\"/>");
			}
			String outputMessage = outputMessages.get(operationName);
			if (outputMessage != null) {
				String outputType = operationName + "ResponseType";
				xml.write("<xs:complexType name=\"" + outputType + "\">" + "<xs:sequence>");
				if (isExternalPrefix(getPrefix(outputMessage)))
					xml.write("<!--xs:element ref=\"" + outputMessage + "\"/-->");
				else
					xml.write("<xs:element ref=\"" + outputMessage + "\"/>");
				xml.write("</xs:sequence>" + "</xs:complexType>" + "<xs:element name=\"" + operationName
						+ "Response\" type=\"" + WSDL_XSD_PREFIX + ":" + outputType + "\"/>");
			}
		}
		xml.write("</xs:schema>");
		xml.close();

		UmlCom.trace("Generating WSDLs");
		for (UmlClass port : ports.values()) {
			String portName = port.name();
			xml = new FileWriter(xmlDir + "/" + portName + WSDL_FILE_TYPE);
			// UmlCom.trace("WSDL: " + portName + ".wsdl");
			xml.write("<definitions targetNamespace=\"" + WSDLURI + "/" + portName + "\"");
			xmlNS(xml, WSDL_PREFIX, WSDLURI + "/" + portName);
			xmlNS(xml, WSDL_XSD_PREFIX, WSDLXSDURI);
			xmlNS(xml, "xsd", XSD_URI);
			xmlNS(xml, SOAP_PREFIX, SOAP_URI);
			xmlNS(xml, WSDL_SCHEMA_PREFIX, WSDL_SCHEMA_URI);
			xmlNS(xml, "", WSDL_SCHEMA_URI);
			xmlNS(xml, WSP_PREFIX, WSP_URI);
			xmlNS(xml, WSRMP_PREFIX, WSRMP_URI);
			xmlNS(xml, WSU_PREFIX, WSU_URI);
			xml.write(">");
			xml.write("<wsp:UsingPolicy wsdl:required=\"true\"/>" + "<wsp:Policy wsu:Id=\"" + WSP_POLICY + "\">"
					+ "<wsrmp:RMAssertion/>" + "</wsp:Policy>" + "<wsdl:types>" + "<xsd:schema>"
					+ "<xsd:import namespace=\"" + WSDLXSDURI + "\" schemaLocation=\"" + WSDL_XSD_SUFFIX + XSD_FILE_TYPE
					+ "\"/>" + "</xsd:schema>" + "</wsdl:types>");

			xml.write("<!-- messages -->");
			// for (UmlOperation operation : operations.values())
			// {
			// String operationName = operation.name();
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					UmlOperation operation = (UmlOperation) item;
					String operationName = operation.name();
					xml.write("<message name=\"" + operationName + REQUEST_MESSAGE_SUFFIX + "\">"
							+ "<part name=\"body\" element=\"" + WSDL_XSD_PREFIX + ":" + operationName
							+ REQUEST_MESSAGE_SUFFIX + "\"/>" + "</message>" + "<message name=\"" + operationName
							+ RESPONSE_MESSAGE_SUFFIX + "\">" + "<part name=\"body\" element=\"" + WSDL_XSD_PREFIX + ":"
							+ operationName + RESPONSE_MESSAGE_SUFFIX + "\"/>" + "</message>");
				}
			}

			xml.write("<!-- ports -->");
			// for (UmlClass port : ports.values())
			// {
			// String portName = port.name();
			xml.write("<portType name=\"" + portName + "\">");
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					UmlOperation operation = (UmlOperation) item;
					String operationName = operation.name();
					xml.write("<operation name=\"" + operationName + "\">" + "<input message=\"" + WSDL_PREFIX + ":"
							+ operationName + REQUEST_MESSAGE_SUFFIX + "\"/>" + "<output message=\"" + WSDL_PREFIX + ":"
							+ operationName + RESPONSE_MESSAGE_SUFFIX + "\"/>" + "</operation>");
				}
			}
			xml.write("</portType>");
			// }

			xml.write("<!-- bindings -->");
			// for (UmlClass port : ports.values())
			// {
			// String portName = port.name();
			xml.write("<binding name=\"" + portName + "Soap\" type=\"" + WSDL_PREFIX + ":" + portName + "\">"
					+ "<wsp:PolicyReference URI=\"#" + WSP_POLICY + "\"/>"
					+ "<soap:binding style=\"document\" transport=\"" + SOAP_HTTP_BINDING_URI + "\"/>");
			for (UmlItem item : port.children()) {
				if (item.kind() == anItemKind.anOperation) {
					UmlOperation oper = (UmlOperation) item;
					String operationName = oper.name();
					xml.write("<operation name=\"" + operationName + "\">" + "<soap:operation soapAction=\"" + WSDLURI
							+ "/" + portName + "/" + operationName + "\"/>" + "<input>"
							+ "	<soap:body use=\"literal\"/>" + "</input>" + "<output>"
							+ "	<soap:body use=\"literal\"/>" + "</output>" + "</operation>");
				}
			}
			xml.write("</binding>");
			// }
			xml.write(
					"<!-- services not defined here...defined in an implementation-specific WSDL that imports this one -->"
							+ "</definitions>");
			xml.close();
		}
	}

	// export MPD catalog
	private static void exportMPDCatalog(String xmlDir, Set<String> CodeListNamespaces, Set<String> messages)
			throws IOException {
		DateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
		Date date = new Date();
		String today = dateFormat.format(date);

		UmlCom.trace("Generating MPD catalog");
		FileWriter xml = new FileWriter(xmlDir + "/" + MPD_CATALOG_FILE);
		xml.write(XML_HEADER);
		xml.write("<c:Catalog");
		for (Entry<String, String> entry : Prefixes.entrySet()) {
			String prefix = entry.getKey();
			if (prefix.equals(NC_PREFIX))
				xmlNS(xml, filterPrefix(prefix), MPD_NC_URI);
			else if (prefix.equals(STRUCTURES_PREFIX))
				xmlNS(xml, filterPrefix(prefix), MPD_STRUCTURES_URI);
			else
				xmlNS(xml, filterPrefix(prefix), Prefixes.get(prefix));
		}
		xmlNS(xml, "c", MPD_CATALOG_URI);
		xmlAttribute(xml, XSI_PREFIX + ":schemaLocation", MPD_CATALOG_URI + " " + MPD_CATALOG_LOCATION);
		xml.write(">");
		xml.write("<c:MPD c:mpdURI=\"" + extensionSchema("") + "\"");
		xmlAttribute(xml, "c:mpdClassURIList", MPD_URI + "#MPD " + MPD_URI + "#IEPD");
		xml.write(" c:mpdName=\"" + getProperty(IEPD_NAME_PROPERTY) + "\" c:mpdVersionID=\""
				+ getProperty(IEPD_VERSION_PROPERTY) + "\">");
		xml.write("<c:MPDInformation>" + "<c:AuthoritativeSource>" + "<nc:EntityOrganization>" + "<nc:OrganizationName>"
				+ getProperty(IEPD_ORGANIZATION_PROPERTY) + "</nc:OrganizationName>"
				+ "<nc:OrganizationPrimaryContactInformation>" + "<nc:ContactWebsiteURI>"
				+ getProperty(IEPD_CONTACT_PROPERTY) + "</nc:ContactWebsiteURI>"
				+ "</nc:OrganizationPrimaryContactInformation>" + "</nc:EntityOrganization>"
				+ "</c:AuthoritativeSource>" + "<c:CreationDate>" + today + "</c:CreationDate>" + "<c:StatusText>"
				+ getProperty(IEPD_STATUS_PROPERTY) + "</c:StatusText>" + "</c:MPDInformation>");
		for (String message : messages) {
			String elementName = getName(message);
			UmlClassInstance classInstance = null;
			if (isNiemElement(message))
				classInstance = findElementByName(subsetPackage, message);
			else
				classInstance = findElementByName(extensionPackage, message);
			xml.write("<c:IEPConformanceTarget structures:id=\"" + elementName + "\">");
			if (classInstance == null)
				UmlCom.trace("exportMPDCatalog: could not find root element " + message);
			else
				xml.write("<nc:DescriptionText>" + classInstance.description() + "</nc:DescriptionText>");
			xml.write("<c:HasDocumentElement c:qualifiedNameList=\"" + message + "\"/>" + "<c:XMLSchemaValid>"
					+ "<c:XMLCatalog c:pathURI=\"" + XML_CATALOG_FILE + "\"/>" + "</c:XMLSchemaValid>"
					+ "<c:IEPSampleXMLDocument c:pathURI=\"" + elementName + XML_FILE_TYPE + "\"/>"
					+ "</c:IEPConformanceTarget>");
		}
		xml.write("<c:ReadMe c:pathURI=\"" + getProperty(IEPD_READ_ME_FILE_PROPERTY) + "\"/>"
				+ "<c:MPDChangeLog c:pathURI=\"" + getProperty(IEPD_CHANGE_LOG_FILE_PROPERTY) + "\"/>"
				+ "<c:Wantlist c:pathURI=\"" + NIEM_DIR + "/" + WANTLIST_FILE + "\"/>"
				+ "<c:ConformanceAssertion c:pathURI=\"" + CONFORMANCE_ASSERTION_FILE + " \"/>");

		for (Entry<String, String> entry : Prefixes.entrySet()) {
			String prefix = entry.getKey();
			String schemaURI = Prefixes.get(prefix);
			if (schemaURI != null) {
				Namespace ns = Namespaces.get(schemaURI);
				if (ns != null) {
					if ((ns.referenceClassView == null) && (ns.filepath != null))
						xml.write("<c:ExtensionSchemaDocument c:pathURI=\"" + ns.filepath + "\"/>");
				}
			}
		}
		for (String codeList : CodeListNamespaces)
			xml.write("<c:BusinessRulesArtifact c:pathURI=\"" + codeList + GC_FILE_TYPE + "\"/>\n");
		xml.write("<c:ReadMe c:pathURI=\"" + getProperty(IEPD_READ_ME_FILE_PROPERTY) + "\"/>");
		xml.write("<c:MPDChangeLog c:pathURI=\"" + getProperty(IEPD_CHANGE_LOG_FILE_PROPERTY) + "\"/>");
		xml.write("</c:MPD></c:Catalog>");
		xml.close();
		trace("exportMPDCatalog: done generating MPD catalog");
	}

	// generate extension and exchange schema
	private static void exportSchema(UmlPackage schemaPackage, String xmlDir, String jsonDir) {

		Boolean exportXML = (xmlDir != null);
		Boolean exportJSON = (jsonDir != null);
		// UmlCom.trace("exportSchema: xmldir:" + xmlDir + " exportXML: " + exportXML);

		try {
			FileWriter xml = null, json = null;
			// Set<String> CodeListNamespaces = new HashSet<String>();

			// export each schema
			for (UmlItem item : schemaPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					classView.sort();
					String prefix = classView.propertyValue(PREFIX_PROPERTY);
					if (prefix == null) {
						UmlCom.trace(
								"exportSchema: prefix for " + classView.propertyValue(PREFIX_PROPERTY) + " is null");
						continue;
					}
					if (isExternalPrefix(prefix))
						continue;
					String schemaURI = getURI(classView);
					trace("exportSchema: exporting schema " + prefix);

					// build list of referenced namespaces
					Set<String> RefNamespaces = new TreeSet<String>();
					RefNamespaces.add(XSD_PREFIX);
					// RefNamespaces.add(structuresPrefix);
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClass) {
							try {
								UmlClass thisClass = (UmlClass) item2;
								for (UmlItem item3 : thisClass.children())
									if (item3.kind() == anItemKind.aRelation) {
										UmlRelation relation = (UmlRelation) item3;
										if (relation.relationKind() == aRelationKind.aGeneralisation) {
											UmlClass baseType = relation.roleType();
											// RefNamespaces.add(baseType.parent().name());
											RefNamespaces.add(getPrefix(baseType));
											break;
										}
									}
								UmlClass typeClass = thisClass, baseType = null;
								while (typeClass != null) {
									for (UmlItem item4 : typeClass.children()) {
										if (item4.kind() == anItemKind.anAttribute) {
											UmlAttribute attribute = (UmlAttribute) item4;
											String elementUri = getURI(attribute);
											UmlClassInstance classInstance;
											if (SubsetElements.containsKey(elementUri))
												classInstance = (UmlClassInstance) SubsetElements.get(elementUri);
											else
												classInstance = (UmlClassInstance) ExtensionElements.get(elementUri);
											// RefNamespaces.add(ci.parent().name());
											RefNamespaces.add(getPrefix(classInstance));
										}
										if (item4.kind() == anItemKind.aRelation) {
											UmlRelation relation = (UmlRelation) item4;
											if (relation.relationKind() == aRelationKind.aGeneralisation)
												baseType = relation.roleType();
										}
									}
									typeClass = baseType;
									baseType = null;
								}
							} catch (Exception e) {
								UmlCom.trace(
										"exportSchema: error building list of referenced namespaces " + e.toString());
							}
						}
					try {
						for (UmlItem item2 : classView.children())
							if (item2.kind() == anItemKind.aClassInstance) {
								UmlClassInstance classInstance = (UmlClassInstance) item2;
								UmlClass baseType = classInstance.type();
								// RefNamespaces.add(baseType.parent().name());
								RefNamespaces.add(getPrefix(baseType));
								String headElement = classInstance.propertyValue(SUBSTITUTION_PROPERTY);
								if (headElement != null)
									RefNamespaces.add(getPrefix(headElement));
							}
					} catch (Exception e1) {
						UmlCom.trace("exportSchema: error adding element namepaces " + e1.toString());
					}

					if (exportXML) {
						// Open XSD file for each extension schema and write header
						String nsSchemaURI = Prefixes.get(prefix);
						Namespace ns = Namespaces.get(nsSchemaURI);
						if (ns.filepath == null)
							continue;
						String filename = xmlDir + "/" + ns.filepath;
						File file = new File(filename);
						file.getParentFile().mkdirs();
						// xml = new FileWriter(xmlDir + "/" + prefix + ".xsd");
						xml = new FileWriter(filename);
						trace("exportSchema: schema " + prefix + XSD_FILE_TYPE);
						// xml.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
						xml.write(XML_HEADER + XML_ATTRIBUTION + "<" + "xs:schema targetNamespace=\"" + schemaURI
								+ "\"\n");

						// export XML namespace definitions
						xmlNS(xml, "", getURI(classView));
						xmlNS(xml, XSI_PREFIX, XSI_URI);
						for (String nsPrefix : RefNamespaces)
							xmlNS(xml, nsPrefix, Prefixes.get(nsPrefix));

						// export schemaLocation
						// xml.write(" xsi:schemaLocation = \"");
						// for (String nsPrefix : RefNamespaces)
						// xml.write(Prefixes.get(nsPrefix) + " " + nsPrefix + ".xsd" + " ");
						// xml.write("\"");

						xmlNS(xml, CODELIST_APPINFO_PREFIX, CODELIST_APPINFO_URI);
						xmlNS(xml, CT_PREFIX, CT_URI);
						xmlNS(xml, TERM_PREFIX, TERM_URI);
						xmlAttribute(xml, "ct:conformanceTargets",
								NDR_URI + "#ExtensionSchemaDocument " + CODELIST_URI + "#SchemaDocument");
						xmlAttribute(xml, "elementFormDefault", "qualified");
						xmlAttribute(xml, "attributeFormDefault", "unqualified");
						xmlAttribute(xml, "version", getProperty(IEPD_VERSION_PROPERTY));

						// close top level element
						xml.write(">\n");
						xml.write("<xs:annotation>\n" + "<xs:documentation> Schema for namespace "
								+ Prefixes.get(prefix) + "</xs:documentation>\n" + "</xs:annotation>");

						// export import namespaces
						if (file != null) {
							Path path1 = Paths.get(file.getParent());
							if (path1 == null)
								UmlCom.trace("exportSchema: path is null");
							for (String nsPrefix : RefNamespaces) {
								String nsSchemaURI2 = Prefixes.get(nsPrefix);
								if (isExternalPrefix(nsPrefix) && exportXML)
									xml.write("<xs:import namespace=\"" + nsSchemaURI2 + "\" schemaLocation=\""
											+ externalSchemaURL.get(nsSchemaURI2) + "\"/>");
								else {
									Namespace ns2 = Namespaces.get(nsSchemaURI2);
									// if (ns2.filepath == null)
									// continue;
									Path p2 = Paths.get(xmlDir + "/" + ns2.filepath);
									Path p3 = path1.relativize(p2);
									if (!nsSchemaURI2.equals(schemaURI) && !nsSchemaURI2.equals(LOCAL_PREFIX)
											&& !nsSchemaURI2.equals(XSD_URI) && ns2 != null && exportXML)
										xml.write("<xs:import namespace=\"" + nsSchemaURI2 + "\" schemaLocation=\""
												+ p3.toString() + "\"/>");
								}
							}
						}
					}
					try {
						if (exportJSON) {
							// Open JSON schema file for each extension schema and write header
							json = new FileWriter(jsonDir + "/" + prefix + JSON_SCHEMA_FILE_TYPE);
							trace("exportSchema: schema " + prefix + JSON_SCHEMA_FILE_TYPE);
							json.write("{");
							jsonOut(json, "$id", schemaURI);
							jsonOut(json, "$schema", JSON_SCHEMA_URI);
							jsonOut(json, "type", "object");
							json.write("\"additionalProperties\" : false,\n");

							// export JSON-LD namespace definitions
							json.write("\"@context\" : {\n");
							for (String nsPrefix : RefNamespaces)
								jsonOut(json, nsPrefix, Prefixes.get(nsPrefix) + "#");
							jsonOut(json, CODELIST_APPINFO_PREFIX, CODELIST_APPINFO_URI + "#");
							jsonOut(json, CT_PREFIX, CT_URI + "#");
							jsonOutLast(json, TERM_PREFIX, TERM_URI + "#");
							json.write("},");
						}
					} catch (Exception e1) {
						UmlCom.trace("exportSchema: error exporting JSON header " + e1.toString());
					}

					// export types
					Set<String> types = new HashSet<String>();
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClass) {
							try {
								UmlClass thisClass = (UmlClass) item2;
								String type = null;
								String typeName = thisClass.name();

								String description = thisClass.description();
								String baseTypeName = null;
								String basePrefix = null;
								String baseTypeCodeList = null;
								String mappingNotes = thisClass.propertyValue(NOTES_PROPERTY);
								if (exportXML && mappingNotes != null && !mappingNotes.equals(""))
									xml.write("<!--" + mappingNotes + "-->");
								String codelist = thisClass.propertyValue(CODELIST_PROPERTY);
								if (codelist != null && codelist.equals(""))
									codelist = null;
								String augmentationPoint = null, augmentationPointMin = null,
										augmentationPointMax = null;
								trace("exportSchema: exporting " + typeName);
								for (UmlItem item3 : thisClass.children())
									if (item3.kind() == anItemKind.aRelation) {
										UmlRelation relation = (UmlRelation) item3;
										if (relation.relationKind() == aRelationKind.aGeneralisation) {
											UmlClass baseType = relation.roleType();
											basePrefix = getPrefix(baseType);
											if (basePrefix == null)
												continue;
											baseTypeName = basePrefix + NAMESPACE_DELIMITER + baseType.name();
											trace("exportSchema: base type name " + baseTypeName);
											// baseTypeName = baseType.parent().name() + namespaceDelimiter +
											// baseType.name();
											baseTypeCodeList = baseType.propertyValue(CODELIST_PROPERTY);
											if (baseTypeCodeList != null && baseTypeCodeList.equals(""))
												baseTypeCodeList = null;
											break;
										}
									}
								// if (typeName.endsWith("AugmentationType"))
								// baseTypeName = "structures:AugmentationType";
								// if (baseTypeName.equals("")) // abstract
								// UmlCom.trace("exportSchema: type " + prefix + namespaceDelimiter + typeName
								// + " has no base type");

								if (baseTypeName == null) // abstract
									trace("exportSchema: exporting abstract type " + typeName);
								if (exportXML) {
									xml.write("<xs:complexType name=\"" + typeName + "\" abstract=\"true\">\n"
											+ "<xs:annotation>\n" + "<xs:documentation>" + description
											+ "</xs:documentation>\n" + "</xs:annotation>\n" + "<xs:/complexType>");
									continue;
								}

								Boolean complexContent = false;
								if (codelist != null) { // code list simple type
									trace("exportSchema: exporting code list simple type " + typeName);
									if (exportXML) {
										xml.write("<xs:simpleType name=\"" + typeName + "\">\n" + "<xs:annotation>\n"
												+ "<xs:documentation>" + description + "</xs:documentation>\n"
												+ "</xs:annotation>\n" + "<xs:restriction base=\"" + baseTypeName
												+ "\">\n");
									}
									if (exportJSON)
										type = "\"" + prefix + ":" + typeName + "\": {\n" + "\"description\": \""
												+ filterQuotes(description) + "\",\n" + "\"$ref\": \""
												+ getJSONType(baseTypeName, prefix) + "\",\n";
									String[] codes = codelist.split(CODELIST_DELIMITER);
									Set<String> enums = new HashSet<String>();
									for (String code : codes) {
										if (!code.equals("")) {
											String[] codeParams = code.split(CODELIST_DEFINITION_DELIMITER);
											String code2 = codeParams[0].trim().replace("&", "&amp;");
											String codeDescription = "";
											if (codeParams.length > 1 && !codeParams[1].equals(""))
												codeDescription = codeParams[1].trim().replace("&", "&amp;");
											if (!code2.equals("")) {
												enums.add("\"" + code2 + "\"");
												if (exportXML) {
													xml.write("<xs:enumeration value=\"" + code2 + "\">\n");
													if (!codeDescription.equals(""))
														xml.write("<xs:annotation>\n" + "<xs:documentation>"
																+ codeDescription + "</xs:documentation>\n"
																+ "</xs:annotation>\n");
													xml.write("</xs:enumeration>\n");
												}
											}
										}
									}
									if (exportXML)
										xml.write("</xs:restriction>");
									// + "</xs:simpleType>");
									if (exportJSON) {
										type += "\"enums\": [" + String.join(",", enums) + "]\n" + "}\n";
										types.add(type);
									}

								} else if (baseTypeCodeList != null) { // codelist complex type
									trace("exportSchema: exporting code list complex type " + typeName);
									// || ((basePrefix != null) && basePrefix.equals(XSD_PREFIX))) {
									if (exportXML) {
										xml.write("<xs:complexType name=\"" + typeName + "\">\n" + "<xs:annotation>\n"
												+ "<xs:documentation>" + description + "</xs:documentation>\n"
												+ "</xs:annotation>\n" + "<xs:simpleContent>\n"
												+ "<xs:extension base=\"" + baseTypeName + "\">\n");
										// xml.write("<xs:attributeGroup
										// ref=\"structures:SimpleObjectAttributeGroup\"/>\n");
										xml.write("</xs:extension>\n");
										// xml.write("</xs:simpleContent>\n"
										// xml.write"</xs:complexType>\n");
									}
									if (exportJSON) {
										type = "\"" + prefix + ":" + typeName + "\": {\n" + "\"description\": \""
												+ filterQuotes(description) + "\",\n" + "\"$ref\": \""
												+ getJSONType(baseTypeName, prefix) + "\"\n" + "}\n";
										types.add(type);
									}

								} else {
									trace("exportSchema: exporting complex type " + typeName); // complexContent
									complexContent = true;
									if (exportXML) {
										xml.write("<xs:complexType name=\"" + typeName + "\">\n" + "<xs:annotation>\n"
												+ "<xs:documentation>" + description + "</xs:documentation>\n"
												+ "</xs:annotation>\n" + "<xs:complexContent>\n"
												+ "<xs:extension base=\"" + baseTypeName + "\">\n");
										xml.write("<xs:sequence>\n");
									}
								}

								thisClass.sortChildren();
								Set<String> required = new HashSet<String>();
								Set<String> properties = new HashSet<String>();
								Boolean anyJSON = false;
								UmlClass thisClass2 = thisClass, baseType = null;
								while (thisClass2 != null) {
									try {
										// && !getPrefix(thisClass2).equals(STRUCTURES_PREFIX)) {
										for (UmlItem item4 : thisClass2.children()) {
											if (item4.kind() == anItemKind.anAttribute) {
												UmlAttribute attribute = (UmlAttribute) item4;
												String elementUri = getURI(attribute);
												UmlClassInstance classInstance;
												if (SubsetElements.containsKey(elementUri))
													classInstance = (UmlClassInstance) SubsetElements.get(elementUri);
												else
													classInstance = (UmlClassInstance) ExtensionElements
															.get(elementUri);
												String elementName = getPrefix(classInstance) + NAMESPACE_DELIMITER
														+ classInstance.name();
												String multiplicity = attribute.multiplicity();
												String minoccurs, maxoccurs;
												if ((multiplicity.equals("")))
													minoccurs = maxoccurs = "1";
												else if (multiplicity.contains(",")) {
													String[] occurs = multiplicity.split(",");
													minoccurs = occurs[0];
													maxoccurs = occurs[1];
												} else
													minoccurs = maxoccurs = multiplicity;
												try {
													if (Integer.parseInt(minoccurs) < 0)
														throw new NumberFormatException();
													if (!maxoccurs.equals("unbounded")
															&& (Integer.parseInt(maxoccurs) < 1))
														throw new NumberFormatException();
												} catch (NumberFormatException e) {
													UmlCom.trace("exportSchema: Invalid multiplicity " + multiplicity
															+ " for " + prefix + NAMESPACE_DELIMITER + typeName + "/"
															+ elementName);
												}
												String elementMappingNotes = attribute.propertyValue(NOTES_PROPERTY);
												if (elementMappingNotes != null && !elementMappingNotes.equals(""))
													if (thisClass2 == thisClass && exportXML && complexContent)
														xml.write("<!--" + elementMappingNotes + "-->");
												trace("exportSchema: exporting element in type " + elementName);
												if (elementName.equals("xs:any")) {
													if (thisClass2 == thisClass && exportXML && complexContent)
														xml.write("<xs:any/>");
													if (exportJSON && complexContent) {
														anyJSON = true;
													}
												}
												// else if (isExternal(elementName))
												// xml.write("<!--xs:element ref=\"" + elementName + "\" minOccurs=\"" +
												// minoccurs + "\" maxOccurs=\"" + maxoccurs + "\"/-->\n");
												else if (thisClass2 == thisClass
														&& elementName.endsWith(AUGMENTATION_POINT_NAME)) {
													augmentationPoint = elementName;
													augmentationPointMin = minoccurs;
													augmentationPointMax = maxoccurs;
												} else {
													if (thisClass2 == thisClass && exportXML && complexContent)
														xml.write("<xs:element ref=\"" + elementName + "\" minOccurs=\""
																+ minoccurs + "\" maxOccurs=\"" + maxoccurs + "\"/>\n");
													if (exportJSON) {
														UmlClass ciBaseType = classInstance.type();
														if (elementName.startsWith(ATTRIBUTE_PREFIX))
															elementName.substring(1);
														if ((ciBaseType != subsetAbstractType)
																&& (ciBaseType != referenceAbstractType)) {
															properties.add(getJSONProperty(elementName, minoccurs,
																	maxoccurs, prefix));
															if (Integer.parseInt(minoccurs) > 0)
																required.add("\"" + elementName + "\"");
														}
														if (Substitutions.containsKey(elementName)) {
															List<UmlClassInstance> enlist = (List<UmlClassInstance>) (Substitutions
																	.get(elementName));
															for (UmlClassInstance classInstance2 : enlist)
																properties.add(getJSONProperty(
																		getPrefix(classInstance2) + ":"
																				+ classInstance2.name(),
																		minoccurs, maxoccurs, prefix));
														}
													}
												}
											}
											if (item4.kind() == anItemKind.aRelation) {
												UmlRelation relation = (UmlRelation) item4;
												if (relation.relationKind() == aRelationKind.aGeneralisation)
													baseType = relation.roleType();
											}
										}
										thisClass2 = baseType;
										baseType = null;
									} catch (Exception e) {
										UmlCom.trace("exportSchema: error exporting element in type" + e.toString());
									}
								}
								// xml.write("<xs:element ref=\"" + elementName + "\" minOccurs=\"" + minoccurs
								// + "\" maxOccurs=\"" + maxoccurs + "\"/>");
								if (augmentationPoint != null) {
									if (exportXML && complexContent)
										xml.write("<xs:element ref=\"" + augmentationPoint + "\" minOccurs=\""
												+ augmentationPointMin + "\" maxOccurs=\"" + augmentationPointMax
												+ "\"/>\n");
								}
								if (exportXML && complexContent)
									xml.write("</xs:sequence>\n");

								// export attributes and attribute groups
								for (UmlItem item4 : thisClass.children()) {
									if (item4.kind() == anItemKind.anAttribute) {
										try {
											UmlAttribute attribute = (UmlAttribute) item4;
											String elementUri = getURI(attribute);
											UmlClassInstance classInstance;
											if (SubsetElements.containsKey(elementUri))
												classInstance = (UmlClassInstance) SubsetElements.get(elementUri);
											else
												classInstance = (UmlClassInstance) ExtensionElements.get(elementUri);
											String elementName = getPrefix(classInstance) + NAMESPACE_DELIMITER
													+ classInstance.name();
											String multiplicity = attribute.multiplicity();
											String minoccurs;
											if ((multiplicity.equals("")))
												minoccurs = "1";
											else if (multiplicity.contains(",")) {
												String[] occurs = multiplicity.split(",");
												minoccurs = occurs[0];
											} else
												minoccurs = multiplicity;
											if (elementName.startsWith(ATTRIBUTE_PREFIX)) { // attribute
												if (exportXML) {
													String use = minoccurs.equals("0") ? "optional" : "required";
													xml.write("<xs:attribute ref=\"" + elementName + "\" use = \"" + use
															+ "\"/>");
												}
											}
										} catch (Exception e) {
											UmlCom.trace(
													"exportSchema: error exporting attribute in type" + e.toString());

										}
									} else if (item4.kind() == anItemKind.aRelation) {
										UmlRelation relation = (UmlRelation) item4;
										if (relation.relationKind() == aRelationKind.aDirectionalAggregation) {
											try {
												// attributeGroup
												UmlClass sourceBaseType = relation.roleType();
												String sourceBasePrefix = getPrefix(sourceBaseType);
												String sourceBaseTypeName = sourceBaseType.name();
												if (exportXML) {
													xml.write("<xs:attributeGroup ref=\"" + sourceBasePrefix
															+ NAMESPACE_DELIMITER + sourceBaseTypeName + "\"/>");
												}
												if (exportJSON) {
													for (UmlItem item5 : sourceBaseType.children()) {
														if (item5.kind() == anItemKind.anAttribute) {
															UmlAttribute attribute = (UmlAttribute) item5;
															String elementUri = getURI(attribute);
															UmlClassInstance classInstance;
															if (SubsetElements.containsKey(elementUri))
																classInstance = (UmlClassInstance) SubsetElements
																		.get(elementUri);
															else
																classInstance = (UmlClassInstance) ExtensionElements
																		.get(elementUri);
															String elementName = getPrefix(classInstance)
																	+ NAMESPACE_DELIMITER + classInstance.name();
															UmlClass ciBaseType = classInstance.type();
															if (elementName.startsWith(ATTRIBUTE_PREFIX))
																elementName.substring(1);
															String multiplicity = attribute.multiplicity();
															String minoccurs;
															if ((multiplicity.equals("")))
																minoccurs = "1";
															else if (multiplicity.contains(",")) {
																String[] occurs = multiplicity.split(",");
																minoccurs = occurs[0];
															} else
																minoccurs = multiplicity;
															if ((ciBaseType != subsetAbstractType)
																	&& (ciBaseType != referenceAbstractType)) {
																properties.add(getJSONProperty(elementName, minoccurs,
																		"1", prefix));
																if (Integer.parseInt(minoccurs) > 0)
																	required.add("\"" + elementName + "\"");
															}
														}
													}
												}
											} catch (Exception e) {
												UmlCom.trace("exportSchema: error exporting attribute group in type"
														+ e.toString());
											}
										}
									}
								}

								try {
									if (exportXML) {
										if (codelist != null)
											xml.write("</xs:simpleType>\n");
										else if (baseTypeCodeList != null)
											xml.write("</xs:simpleContent>\n</xs:complexType>\n");
										else if (complexContent)
											xml.write("</extension>\n</xs:complexContent>\n</xs:complexType>\n");
									}

									if (exportJSON) {
										type = "\"" + prefix + ":" + typeName + "\": {\n";
										if (description != null)
											type += "\"description\": \"" + filterQuotes(description) + "\",\n";
										type += "\"type\": \"object\",\n" + "\"additionalProperties\" :" + anyJSON
												+ ",\n";
										if (properties != null)
											type += "\"properties\": {\n" + String.join(",", properties) + "\n"
													+ "},\n";
										if (required != null)
											type += "\"required\" : [\n" + String.join(",", required) + "\n" + "]\n";
										type += "}\n";
										types.add(type);
									}
								} catch (Exception e) {
									UmlCom.trace("exportSchema: error closing type" + e.toString());

								}
							} catch (NullPointerException e) {
								UmlCom.trace("exportSchema: error exporting types " + e.toString());
							} catch (Exception e) {
								UmlCom.trace("exportSchema: error exporting types " + e.toString());
							}
						}

					// export elements
					Set<String> elements = new HashSet<String>();
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClassInstance) {
							try {
								UmlClassInstance classInstance = (UmlClassInstance) item2;
								String elementName = classInstance.name();
								String description = classInstance.description();
								UmlClass baseType = classInstance.type();
								String baseTypeName = getPrefix(baseType) + NAMESPACE_DELIMITER + baseType.name();
								String mappingNotes = classInstance.propertyValue(NOTES_PROPERTY);
								String headElement = classInstance.propertyValue(SUBSTITUTION_PROPERTY);
								String codeList = classInstance.propertyValue(CODELIST_PROPERTY);
								String isNillable = classInstance.propertyValue(NILLABLE_PROPERTY);
								if (isNillable == null)
									isNillable = "false";
								if (mappingNotes != null && !mappingNotes.equals(""))
									if (exportXML)
										xml.write("<!--" + mappingNotes + "-->");
								if ((baseType == subsetAbstractType) || (baseType == referenceAbstractType)) {
									if (exportXML)
										xml.write("<xs:element name=\"" + elementName + "\" abstract=\"true\">\n");
								} else if (elementName.startsWith(ATTRIBUTE_PREFIX)) {
									// Do nothing
								} else if (headElement != null) {
									if (exportXML)
										xml.write("<xs:element name=\"" + elementName + "\" type=\"" + baseTypeName
												+ "\" substitutionGroup=\"" + headElement + "\" nillable=\""
												+ isNillable + "\">\n");
									if (exportJSON)
										elements.add("\"" + prefix + ":" + elementName + "\": {\n"
												+ "\"description\": \"" + filterQuotes(description) + "\",\n"
												+ "\"$ref\": \"" + getJSONType(baseTypeName, prefix) + "\"\n" + "}");
								} else {
									if (exportXML)
										xml.write("<xs:element name=\"" + elementName + "\" type=\"" + baseTypeName
												+ "\" nillable=\"" + isNillable + "\">\n");
									if (exportJSON) {
										elements.add("\"" + prefix + ":" + elementName + "\": {\n"
												+ "\"description\": \"" + filterQuotes(description) + "\",\n"
												+ "\"$ref\": \"" + getJSONType(baseTypeName, prefix) + "\"\n" + "}");
									}
								}
								if (exportXML)
									xml.write("<xs:annotation>\n" + "<xs:documentation>" + description
											+ "</xs:documentation>\n");
								if (codeList != null) {
									String codeListURI = extensionSchema(elementName);
									if (exportXML)
										xml.write("<xs:appinfo>" + "<clsa:SimpleCodeListBinding codeListURI=\""
												+ codeListURI + "\"/>" + " </xs:appinfo>");
								}
								if (exportXML)
									xml.write("</xs:annotation>\n" + "</xs:element>\n");
							} catch (Exception e) {
								UmlCom.trace("exportSchema: error exporting elements " + e.toString());
							}
						}
					if (exportXML) {
						xml.write("</xs:schema>\n");
						xml.close();
					}
					if (exportJSON) {
						// types.addAll(elements);
						json.write("\"definitions\": {\n" + String.join(",", types) + "\n" + "},\n"
								+ "\"properties\" : {" + String.join(",", elements) + "}\n" + "}");
						json.close();
					}
				}
		} catch (IOException e) {
			UmlCom.trace("exportSchema: IO exception: " + e.toString());
		} catch (RuntimeException e) {
			UmlCom.trace("exportSchema: RuntimeException: " + e.toString());
		}
	}

	// generate NIEM wantlist for import into Subset Schema Generator Tool (SSGT)
	public static void exportWantlist(String dir, String filename) {

		// createSubset();
		setExternalSchemas();

		UmlItem.directory = dir;
		try {
			// Export schema
			trace("exportWantlist: create header");
			FileWriter fw = new FileWriter(dir + "/" + filename);
			fw.write(XML_HEADER);
			fw.write(XML_ATTRIBUTION);
			fw.write("<w:WantList w:release=\"" + getNiemVersion()
					+ "\" w:product=\"NIEM\" w:nillableDefault=\"true\" ");
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					String prefix = item.name();
					String schemaURI = Prefixes.get(prefix);
					if (!prefix.equals(LOCAL_PREFIX))
						xmlNS(fw, prefix, schemaURI);
				}
			xmlNS(fw, "w", WANTLIST_URI);

			// export elements
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					String prefix = classView.propertyValue(PREFIX_PROPERTY);
					if (prefix.equals(LOCAL_PREFIX))
						continue;
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClassInstance) {
							UmlClassInstance classInstance = (UmlClassInstance) item2;
							String elementName = classInstance.name();
							if (prefix.equals(XSD_PREFIX) && elementName.equals(ANY_ELEMENT_NAME))
								continue;
							trace("exportWantlist: export element " + elementName);
							String isNillable = classInstance.propertyValue(NILLABLE_PROPERTY);
							if (isNillable == null)
								isNillable = "false";
							fw.write("<w:Element w:name=\"" + prefix + NAMESPACE_DELIMITER + elementName
									+ "\" w:isReference=\"false\" w:nillable=\"" + isNillable + "\"/>\n");
						}
				}

			// export types
			for (UmlItem item : subsetPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					String prefix = classView.propertyValue(PREFIX_PROPERTY);
					if (prefix.equals(LOCAL_PREFIX))
						continue;
					// String schemaURI = Prefixes.get(prefix);
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClass) {
							UmlClass thisClass = (UmlClass) item2;
							String typeName = thisClass.name();
							trace("exportWantlist: export type " + typeName);
							if (prefix.equals(STRUCTURES_PREFIX) && typeName.equals(AUGMENTATION_TYPE_NAME))
								continue;
							fw.write("<w:Type w:name=\"" + prefix + NAMESPACE_DELIMITER + typeName
									+ "\" w:isRequested=\"true\">\n");

							for (UmlItem item3 : thisClass.children())
								if (item3.kind() == anItemKind.anAttribute) {
									UmlAttribute attribute = (UmlAttribute) item3;
									String uri = getURI(attribute);
									UmlClassInstance classInstance = (UmlClassInstance) SubsetElements.get(uri);
									String elementPrefix = getPrefix(classInstance);
									String elementName = attribute.name();
									trace("exportWantlist: adding attribute " + elementName);
									String multiplicity = attribute.multiplicity();
									trace("exportWantlist: with multiplicity " + multiplicity);
									String minoccurs, maxoccurs;
									if ((multiplicity.equals("")))
										minoccurs = maxoccurs = "1";
									else if (multiplicity.contains(",")) {
										String[] occurs = multiplicity.split(",");
										minoccurs = occurs[0];
										maxoccurs = occurs[1];
									} else
										minoccurs = maxoccurs = multiplicity;
									try {
										if (Integer.parseInt(minoccurs) < 0)
											throw new NumberFormatException();
										if (!maxoccurs.equals("unbounded") && (Integer.parseInt(maxoccurs) < 1))
											throw new NumberFormatException();
									} catch (NumberFormatException e) {
										UmlCom.trace("exportWantlist: Invalid multiplicity " + multiplicity + " for "
												+ prefix + NAMESPACE_DELIMITER + typeName + "/" + elementPrefix
												+ NAMESPACE_DELIMITER + elementName);
									}
									// if (((!minoccurs.equals("0") && !minoccurs.equals("1"))) ||
									// ((!maxoccurs.equals("1") && !maxoccurs.equals("unbounded"))))
									// UmlCom.trace("createSubset: unusual multiplicity " + multiplicity + " for
									// element " + elementName);;

									trace("exportWantlist: export element " + elementName + " in type " + typeName);
									fw.write("\t<w:ElementInType w:name=\"" + elementPrefix + NAMESPACE_DELIMITER
											+ elementName + "\" w:isReference=\"false\" w:minOccurs=\"" + minoccurs
											+ "\" w:maxOccurs=\"" + maxoccurs + "\"/>\n");
								}

							// export enumerations
							String codeList = thisClass.propertyValue(CODELIST_PROPERTY);
							if (codeList != null) {
								trace("exportWantlist: Exporting numerations for " + thisClass.pretty_name());
								String[] codes = codeList.split(CODELIST_DELIMITER);
								for (String co : codes) {
									co = co.trim();
									if (!co.equals(""))
										fw.write("<w:Facet w:facet=\"enumeration\" w:value=\""
												+ co.replace("\"", "&quot;") + "\"/>");
								}
							}
							fw.write("</w:Type>");
						}
				}

			fw.write("</w:WantList>");
			fw.close();

		} catch (IOException e) {
			UmlCom.trace("exportWantlist: IO exception: " + e.toString());
		}
	}

	// export XML catalog file
	private static void exportXMLCatalog(String xmlDir, Set<String> CodeListNamespaces) throws IOException {
		FileWriter xml;
		UmlCom.trace("Generating XML catalog");
		xml = new FileWriter(xmlDir + "/" + XML_CATALOG_FILE);
		xml.write(XML_HEADER + XML_ATTRIBUTION + XML_CATALOG_HEADER + "<catalog prefer=\"public\" "
				+ NAMESPACE_ATTRIBUTE + "=\"" + XML_CATALOG_URI + "\">\n");
		for (Entry<String, String> entry : Prefixes.entrySet()) {
			String prefix = entry.getKey();
			String schemaURI = Prefixes.get(prefix);
			Namespace ns = Namespaces.get(schemaURI);
			if (isExternalPrefix(prefix))
				xml.write("<uri name=\"" + schemaURI + "\" uri=\"" + externalSchemaURL.get(schemaURI) + "\"/>\n");
			else if (ns.referenceClassView == null)
				xml.write("<uri name=\"" + schemaURI + "\" uri=\"" + ns.filepath + "\"/>\n");
		}
		for (String codeList : CodeListNamespaces)
			xml.write("<uri name=\"" + extensionSchema(codeList) + "\" uri=\"" + codeList + GC_FILE_TYPE + "\"/>\n");
		xml.write("<nextCatalog  catalog=\"" + NIEM_DIR + "/" + XML_CATALOG_FILE + "\" />\n</catalog>\n");
		xml.close();
	}

	// return extension schema URI
	private static String extensionSchema(String prefix) {
		return getProperty(IEPD_URI_PROPERTY) + prefix;
	}

	// only ASCII
	private static String filterASCII(String string) {
		return string.replaceAll("[^\\p{ASCII}]", "");
	}

	// filter enumerations
	private static String filterEnum(String string) {
		return string.replaceAll(CODELIST_DELIMITER + CODELIST_DEFINITION_DELIMITER, "");
	}

	// filter allowable hash values
	private static String filterHash(String string) {
		return string.replaceAll(HASH_DELIMITER, "");
	}

	// XML filters

	/*
	 * // replace whitespace public static String filterNormalizedString(String
	 * string) { return string.replaceAll("\\s", " "); }
	 */

	// only alphanumeric, colons, hyphens, underscores and periods
	private static String filterNameToken(String string) {
		return string.replaceAll("[^-._:A-Za-z0-9]", "");
	}

	// only alphanumeric, hyphens, underscores and periods
	private static String filterPrefix(String string) {
		return string.replaceAll("[^-._A-Za-z0-9]", "");
	}

	// filter enumerations
	private static String filterQuotes(String string) {
		return string.replaceAll("\"", "&quot;");
	}

	// remove whitespace
	private static String filterToken(String string) {
		return string.replaceAll("\\s", "");
	}

	// filter allowable UML names
	private static String filterUMLName(String string) {
		return string.replaceAll("[^A-Za-z0-9_@#$`~,.<?;:'\"\\\\]", "");
	}

	// get element by schemaURI and tagname
	private static UmlClassInstance findElement(UmlPackage parentPackage, String schemaURI, String elementName) {
		try {

			// String elementName2 = filterUMLName(elementName);
			// String elementName2 = elementName.replace("-", "");
			String uri = schemaURI + HASH_DELIMITER + filterHash(elementName);
			if (parentPackage == referencePackage)
				return (UmlClassInstance) NiemElements.get(uri);
			else if (parentPackage == subsetPackage)
				return (UmlClassInstance) SubsetElements.get(uri);
			else if (parentPackage == extensionPackage)
				return (UmlClassInstance) ExtensionElements.get(uri);
		} catch (RuntimeException re) {
			trace("findElement: cannot find element " + elementName + " in URI " + schemaURI + " " + re.toString());
		}
		return null;
	}

	// get element by tagname
	private static UmlClassInstance findElementByName(UmlPackage parentPackage, String elementName) {
		// String prefix = getPrefix(elementName);
		String schemaURI = getURI(elementName);
		// String schemaURI = Prefixes.get(prefix);
		String tagName = getName(elementName);
		return findElement(parentPackage, schemaURI, tagName);
	}

	// get element by prefix and tagname
	private static UmlClassInstance findElementByPrefix(Document doc, UmlPackage parentPackage, String elementName) {
		String prefix = getPrefix(elementName);
		/*
		 * String schemaURI; if (prefix.equals("")) //schemaURI =
		 * XMLConstants.W3C_XML_SCHEMA_NS_URI; schemaURI =
		 * docs.lookupNamespaceURI(null); else
		 */
		String schemaURI = doc.lookupNamespaceURI(prefix);
		if ((prefix != null) && (schemaURI == null))
			schemaURI = Prefixes.get(prefix);
		String elementName2 = getName(elementName);

		UmlClassInstance classInstance = findElement(parentPackage, schemaURI, elementName2);
		if (classInstance == null) {
			UmlCom.trace("findElementsByPrefix: cannot find element " + elementName2 + " in schema " + schemaURI);
		}
		return classInstance;
	}

	// get namespace by schemaURI
	private static Namespace findNamespace(String schemaURI) {
		return Namespaces.get(schemaURI);
	}

	// get type by schemaURI and tagname
	private static UmlClass findType(UmlPackage parentPackage, String schemaURI, String typeName) {

		// trace("findType: NiemTypes: " + NiemTypes.toString());
		if (typeName.equals(ABSTRACT_TYPE_NAME)) {
			if (parentPackage == referencePackage)
				return referenceAbstractType;
			else
				return subsetAbstractType;
		}
		// String typeName2 = typeName;
		// String typeName2 = filterUMLName(typeName);
		// String typeName2 = typeName.replace("-", "");
		String uri = schemaURI + HASH_DELIMITER + filterHash(typeName);
		// trace("findType: " + uri);
		if (parentPackage == referencePackage)
			return (UmlClass) NiemTypes.get(uri);
		else if (parentPackage == subsetPackage)
			return (UmlClass) SubsetTypes.get(uri);
		else if (parentPackage == extensionPackage) {
			return (UmlClass) ExtensionTypes.get(uri);
		}
		return null;
	}

	// get type by prefix and tagname
	private static UmlClass findTypeByPrefix(Document doc, UmlPackage parentPackage, String typeName) {
		String typeName2 = getName(typeName);
		// String typeName2 = filterUMLName(getName(typeName));
		String schemaURI = null;
		try {
			if (typeName.equals(ABSTRACT_TYPE_NAME))
				if (parentPackage == referencePackage)
					return referenceAbstractType;
				else
					return subsetAbstractType;
			String prefix = getPrefix(typeName);
			if ((prefix != null) && prefix.equals(LOCAL_PREFIX))
				schemaURI = LOCAL_PREFIX;
			else
				schemaURI = doc.lookupNamespaceURI(prefix);
		} catch (RuntimeException re) {
			UmlCom.trace("findTypeByPrefix: cannot find type " + typeName + " " + re.toString());
		}
		return findType(parentPackage, schemaURI, typeName2);
	}

	// JSON Pointer to an element
	private static String getJSONElement(String elementName, String localPrefix) {
		if (elementName == null)
			return "";
		String prefix = getPrefix(elementName);
		if (prefix == null)
			return "";
		if (isExternalPrefix(prefix))
			return "";
		else if (prefix.equals(localPrefix))
			return "#/properties/" + elementName;
		else if (isNiemPrefix(prefix) && !isNiemPrefix(localPrefix))
			return NIEM_DIR + "/" + prefix + JSON_SCHEMA_FILE_TYPE + "#/properties/" + elementName;
		else if (!isNiemPrefix(prefix) && isNiemPrefix(localPrefix))
			return "../" + prefix + JSON_SCHEMA_FILE_TYPE + "#/properties/" + elementName;
		else
			return "" + prefix + JSON_SCHEMA_FILE_TYPE + "#/properties/" + elementName;
	}

	// JSON property description of an element
	private static String getJSONProperty(String elementName, String minoccurs, String maxoccurs, String localPrefix) {
		String property = "";
		property += "\"" + elementName + "\": {\n";
		if (maxoccurs.equals("1"))
			property += "\"$ref\": \"" + getJSONElement(elementName, localPrefix) + "\"\n";
		else {
			property += "\"oneOf\": [";
			if (minoccurs.equals("0") || minoccurs.equals("1")) {
				property += "{\n" + "\"$ref\": \"" + getJSONElement(elementName, localPrefix) + "\"\n" + "},\n";
			}
			property += "{\n" + "\"items\": {\n" + "\"$ref\": \"" + getJSONElement(elementName, localPrefix) + "\"\n"
					+ "},\n" + "\n\"minItems\": " + minoccurs + ",\n";
			if (!maxoccurs.equals("unbounded"))
				property += "\n\"maxItems\": " + maxoccurs + ",\n";
			property += "\"type\": \"array\"\n" + "}\n" + "]\n";
		}
		property += "}";

		return property;
	}

	// JSON Pointer to a type
	private static String getJSONType(String typeName, String localPrefix) {
		if (typeName == null)
			return "";
		String prefix = getPrefix(typeName);
		if (prefix == null)
			return "";
		if (isExternalPrefix(prefix))
			return "";
		else if (prefix.equals(localPrefix))
			return "#/definitions/" + typeName;
		if (isNiemPrefix(prefix) && !isNiemPrefix(localPrefix))
			return NIEM_DIR + "/" + prefix + JSON_SCHEMA_FILE_TYPE + "#/definitions/" + typeName;
		else if (!isNiemPrefix(prefix) && isNiemPrefix(localPrefix))
			return "../" + prefix + JSON_SCHEMA_FILE_TYPE + "#/definitions/" + typeName;
		else
			return "" + prefix + JSON_SCHEMA_FILE_TYPE + "#/definitions/" + typeName;
	}

	// extract tagname from XML tag
	private static String getName(String tagName) {
		if (tagName == null)
			return "";
		int i = tagName.indexOf(NAMESPACE_DELIMITER);
		return (i >= 0) ? tagName.substring(i + 1) : tagName;
	}

	// return NIEM version
	private static String getNiemVersion() {
		String niemVersion = "4.0";
		/*
		 * String schemaURI = Prefixes.get("nc"); //Matcher mat =
		 * Pattern.compile(".*?niem-core/.*?").matcher(schemaURI); Matcher mat =
		 * Pattern.compile(".*niem-core/(.*?)/").matcher(schemaURI);
		 * //UmlCom.trace("NIEM URI: " + schemaURI); if (mat.find()) niemVersion =
		 * mat.group(1);
		 */
		UmlCom.trace("NIEM version: " + niemVersion);
		return niemVersion;
	}

	// extract namespace prefix from XML tag
	private static String getPrefix(String tagName) {
		if (tagName == null)
			return null;
		int i = tagName.indexOf(NAMESPACE_DELIMITER);
		return (i >= 0) ? tagName.substring(0, i).trim() : null;
	}

	private static String getPrefix(UmlItem item) {
		return item.parent().propertyValue(PREFIX_PROPERTY);
	}

	public static String getProperty(String propertyName) {
		return UmlBasePackage.getProject().propertyValue(propertyName);
	}

	private static String getURI(String tagName) {
		String prefix = getPrefix(tagName);
		if (prefix == null)
			prefix = LOCAL_PREFIX;
		String schemaURI = Prefixes.get(prefix);
		if (schemaURI == null)
			schemaURI = extensionSchema(prefix);
		return schemaURI;
	}

	private static String getURI(UmlItem item) {
		return item.propertyValue(URI_PROPERTY);
	}

	// hide item from documentation
	private static void hideItem(UmlItem item) {
		item.known = false;
		for (UmlItem child : item.children())
			hideItem(child);
	}

	// hide reference model from documentation
	protected static void hideReferenceModel() {
		hideItem(referencePackage);
	}

	// import NIEM mapping spreadsheet in CSV format
	public static void importCsv(String filename) {

		setExternalSchemas();
		// Cache UML classes
		Map<String, UmlClass> UMLClasses = new HashMap<String, UmlClass>();
		Map<String, UmlClassInstance> UMLInstances = new HashMap<String, UmlClassInstance>();
		for (int i = 0; i < UmlItem.all.size(); i++) {
			UmlItem item = (UmlItem) UmlItem.all.elementAt(i);
			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				if (item.kind() == anItemKind.aClass) {
					UmlClass c = (UmlClass) item;
					if (!UMLClasses.containsKey(c.pretty_name()))
						UMLClasses.put(c.pretty_name(), c);
				} else if (item.kind() == anItemKind.aClassInstance) {
					UmlClassInstance ci = (UmlClassInstance) item;
					if (!UMLInstances.containsKey(ci.pretty_name()))
						UMLInstances.put(ci.pretty_name(), ci);
				}
		}
		try {

			CSVReader reader = new CSVReader(new FileReader(filename));
			String[] nextLine;

			// Read header
			reader.readNext();

			// NIEM Read Mappings
			while ((nextLine = reader.readNext()) != null) {
				String className = nextLine[0].trim();
				String attributeName = nextLine[1].trim();

				if (!className.equals("")) {
					UmlClass c = UMLClasses.get(className);
					if (c != null) {
						if (attributeName.equals("")) {
							// Import NIEM Mapping to Class
							trace("importCsv: importing NIEM mapping for " + className);
							for (int p = 4; p < NIEM_STEREOTYPE_MAP.length && p < nextLine.length; p++)
								c.set_PropertyValue(niemProperty(p), nextLine[p]);
						} else {
							// Import NIEM Mapping to Attribute
							for (UmlItem item : c.children())
								if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)
										&& (item.pretty_name().equals(attributeName)))
									for (int p = 4; p < NIEM_STEREOTYPE_MAP.length && p < nextLine.length; p++)
										item.set_PropertyValue(niemProperty(p), nextLine[p]);
						}
					}
				} else if (!attributeName.equals("")) {
					UmlClassInstance ci = UMLInstances.get(attributeName);
					if (ci != null) {
						// Import NIEM Mapping to Class
						trace("importCsv: importing NIEM mapping for " + attributeName);
						for (int p = 4; p < NIEM_STEREOTYPE_MAP.length && p < nextLine.length; p++)
							ci.set_PropertyValue(niemProperty(p), nextLine[p]);
					}
				}
			}
			reader.close();
		} catch (FileNotFoundException e) {
			UmlCom.trace("importCsv: File not found" + e.toString());
		} catch (IOException e) {
			UmlCom.trace("importCsv: IO exception" + e.toString());
		}
	}

	// import NIEM reference model elements into HashMaps
	private static Namespace importElements(DocumentBuilder db, String filename) {
		trace("importElements: importing elements from schema " + filename);
		String filename2 = "\n" + filename + "\n";
		Namespace ns = null;
		try {
			// parse the schema
			Document doc = db.parse(new File(filename));
			xPath.setNamespaceContext(new NamespaceResolver(doc, true));
			ns = importNamespaces(doc);

			// compile XPath queries
			XPathExpression xe = xPath.compile("xs:annotation[1]/xs:documentation[1]");

			// import elements
			NodeList elementList = (NodeList) xPath.evaluate("xs:element[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
			for (int i = 0; i < elementList.getLength(); i++) {
				Element elementElement = (Element) elementList.item(i);
				String elementName = filterNameToken(elementElement.getAttribute("name"));
				String elementTypeName = filterToken(elementElement.getAttribute("type"));
				String abstractAttribute = elementElement.getAttribute("abstract");
				if (elementTypeName.equals("") || (abstractAttribute.equals("true")))
					elementTypeName = null;
				// if (elementTypeName.equals(""))
				// elementTypeName = localPrefix + namespaceDelimiter + abstractTypeName;
				try {
					UmlClassInstance classInstance = addReferenceElement(doc, ns.referenceClassView, ns.schemaURI,
							elementName, elementTypeName, xe.evaluate(elementElement));
					if (classInstance != null) {
						NiemElements.put(getURI(classInstance), classInstance);
					} else
						UmlCom.trace(
								"importElements: cannot create element " + elementName + " of type " + elementTypeName);
				} catch (Exception re) {
					UmlCom.trace(filename2 + "importElements: cannot create element " + elementName + " of type "
							+ elementTypeName + " " + re.toString());
					filename2 = "";
				}
			}

			// import attributes
			NodeList attributeList = (NodeList) xPath.evaluate("xs:attribute[@name]", doc.getDocumentElement(),
					XPathConstants.NODESET);
			for (int i = 0; i < attributeList.getLength(); i++) {
				Element element = (Element) attributeList.item(i);
				String elementName = ATTRIBUTE_PREFIX + filterNameToken(element.getAttribute("name"));
				trace("importElements: creating attribute " + elementName);
				String elementTypeName = filterToken(element.getAttribute("type"));
				if (elementTypeName.equals(""))
					elementTypeName = null;
				// elementTypeName = localPrefix + namespaceDelimiter + abstractTypeName;
				try {
					UmlClassInstance classInstance = addReferenceElement(doc, ns.referenceClassView, ns.schemaURI,
							elementName, elementTypeName, xe.evaluate(element));
					// if elementTypeName has no namespace and attribute creation fails, try
					// appending the xmlprefix to elementTypeName
					if ((classInstance == null) && getPrefix(elementTypeName) == null)
						classInstance = addReferenceElement(doc, ns.referenceClassView, ns.schemaURI, elementName,
								XSD_PREFIX + NAMESPACE_DELIMITER + elementTypeName, xe.evaluate(element));
					if (classInstance != null)
						NiemElements.put(getURI(classInstance), classInstance);
					else
						UmlCom.trace(filename2 + "importElements: cannot create attribute " + elementName + " of type "
								+ elementTypeName);
				} catch (Exception re) {
					UmlCom.trace(filename2 + "importElements: cannot create attribute " + elementName + " of type "
							+ elementTypeName + " " + re.toString());
					filename2 = "";
				}
			}
		} catch (Exception e) {
			UmlCom.trace(filename2 + "importElements: exception " + e.toString());
			filename2 = "";
		}

		return ns;
	}

	// import NIEM reference model elements in Types into HashMaps
	private static Namespace importElementsInTypes(DocumentBuilder db, String filename) {
		trace("importElementsInTypes: importing elements in types from schema " + filename);
		String filename2 = "\n" + filename + "\n";
		Document doc = null;
		Namespace ns = null;
		try {
			// parse the schema
			doc = db.parse(new File(filename));
			xPath.setNamespaceContext(new NamespaceResolver(doc, true));
			ns = importNamespaces(doc);
		} catch (Exception e) {
			UmlCom.trace(filename + "\nimportElementsInTypes: error parsing the schema " + e.toString());
		}

		// import attributes in attribute groups
		Node root = null;
		NodeList attributeGroupList = null;
		try {
			root = doc.getDocumentElement();
			attributeGroupList = (NodeList) xPath.evaluate("xs:attributeGroup[@name]", root, XPathConstants.NODESET);
			for (int i = 0; i < attributeGroupList.getLength(); i++) {
				Element attributeGroupElement = (Element) attributeGroupList.item(i);
				String attributeGroupName = filterNameToken(attributeGroupElement.getAttribute("name"));
				String attributeGroupName2 = ATTRIBUTE_PREFIX + getName(attributeGroupName);
				// String prefix = getPrefix(attributeGroupName);
				String schemaURI = getURI(attributeGroupName);
				// String schemaURI = Prefixes.get(getPrefix(attributeGroupName));
				UmlClass attributeGroup = findType((UmlPackage) (ns.referenceClassView.parent()), ns.schemaURI,
						attributeGroupName2);
				if (attributeGroup == null) {
					UmlCom.trace(filename2 + "importElementsInType: attribute group not found: " + attributeGroupName2);
					filename2 = "";
					continue;
				}

				String uri = schemaURI + HASH_DELIMITER + filterHash(attributeGroupName);
				List<UmlClassInstance> elementInTypeList = (List<UmlClassInstance>) (NiemElementsInType.get(uri));
				if (elementInTypeList == null) {
					elementInTypeList = new ArrayList<UmlClassInstance>();
					NiemElementsInType.put(uri, elementInTypeList);
				}
				try {
					NodeList attributeList = (NodeList) xPath.evaluate("descendant::xs:attribute[@ref]",
							attributeGroupElement, XPathConstants.NODESET);
					if (attributeList != null)
						for (int j = 0; j < attributeList.getLength(); j++) {
							Element attributeElement = (Element) attributeList.item(j);
							String attributeName = filterToken(attributeElement.getAttribute("ref"));
							String attributeName2 = getPrefix(attributeName) + NAMESPACE_DELIMITER + ATTRIBUTE_PREFIX
									+ getName(attributeName);
							trace("importElementsInTypes: importing attribute :" + attributeName2 + " in group "
									+ attributeGroupName);
							String minOccurs = "1";
							String maxOccurs = "1";
							if (filterNameToken(attributeElement.getAttribute("use")).equals("optional"))
								minOccurs = "0";
							String multiplicity = minOccurs + "," + maxOccurs;
							UmlAttribute attribute = null;
							try {
								attribute = addElementInType(doc, ns.referenceClassView, ns.schemaURI,
										attributeGroupName2, attributeName2, multiplicity);
							} catch (Exception re) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot create attrbute "
										+ attributeName2 + " in group " + attributeGroupName2 + " " + re.toString());
								filename2 = "";
							}
							if (attribute == null) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot create attribute "
										+ attributeName2 + " in group " + attributeGroupName2);
								continue;
							}
							UmlClassInstance classInstance = null;
							try {
								classInstance = findElementByPrefix(doc, (UmlPackage) (ns.referenceClassView.parent()),
										attributeName2);
							} catch (Exception re) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot find attribute "
										+ attributeName2 + " " + re.toString());
								filename2 = "";
							}
							if (classInstance == null) {
								UmlCom.trace(
										filename2 + "importElementsInTypes: cannot find attribute " + attributeName2);
								filename2 = "";
								continue;
							}
							try {
								UmlTypeSpec classInstanceType = new UmlTypeSpec();
								classInstanceType.type = classInstance.type();
								if (classInstanceType.type != null)
									attribute.set_Type(classInstanceType);
							} catch (Exception re) {
								UmlCom.trace(filename + "\nimportElementsInTypes: error setting description and type "
										+ re.toString());
							}
							elementInTypeList.add(classInstance);
						}
				} catch (Exception re) {
					UmlCom.trace(
							filename + "\nimportElementsInTypes: error importing attributes in type " + re.toString());
				}

			}
		} catch (Exception e) {
			UmlCom.trace(filename + "\nimportElementsInTypes: error parsing the schema " + e.toString());
		}

		// import base types for simple types (codes)
		NodeList typeList = null;
		try {
			typeList = (NodeList) xPath.evaluate("xs:simpleType[@name]/xs:restriction[1][@base]", root,
					XPathConstants.NODESET);
			for (int i = 0; i < typeList.getLength(); i++) {
				Element restrictionElement = (Element) typeList.item(i);
				Element typeElement = (Element) restrictionElement.getParentNode();
				String elementName = filterNameToken(typeElement.getAttribute("name"));
				String baseTypeName = filterToken(restrictionElement.getAttribute("base"));

				UmlClass thisClass = findType((UmlPackage) (ns.referenceClassView.parent()), ns.schemaURI, elementName);
				if (thisClass == null) {
					UmlCom.trace(filename2 + "importElementsInType: type not found: " + elementName);
					filename2 = "";
					continue;
				}
				UmlClass baseType = findTypeByPrefix(doc, (UmlPackage) (ns.referenceClassView.parent()), baseTypeName);
				if (baseType == null) {
					UmlCom.trace(filename2 + "importElementsInType: base type not found: " + baseTypeName);
					filename2 = "";
					continue;
				}
				try {
					UmlBaseRelation.create(aRelationKind.aGeneralisation, thisClass, baseType);
				} catch (Exception re) {
					trace(filename2 = "importElementsInType: " + elementName + " already related to base type"
							+ baseTypeName + " " + re.toString());
					filename2 = "";
				}
			}
		} catch (Exception e) {
			UmlCom.trace(
					filename + "\nimportElementsInTypes: error importing base types for simple types " + e.toString());
		}

		// import base types and elements for complex types
		Element typeElement = null;
		UmlClass typeClass = null;
		String complexTypeName = null;
		try {
			typeList = (NodeList) xPath.evaluate("xs:complexType[@name]", root, XPathConstants.NODESET);
		} catch (Exception e) {
			UmlCom.trace(filename + "\nimportElementsInTypes: error parsing types" + e.toString());
		}
		if (typeList != null)
			for (int i = 0; i < typeList.getLength(); i++) {
				try {
					typeElement = (Element) typeList.item(i);
					if (typeElement == null)
						continue;
					complexTypeName = filterNameToken(typeElement.getAttribute("name"));

					typeClass = findType((UmlPackage) (ns.referenceClassView.parent()), ns.schemaURI, complexTypeName);
					if (typeClass == null) {
						UmlCom.trace(filename2 + "importElementsInType: type not found: " + complexTypeName);
						filename2 = "";
						continue;
					}
				} catch (Exception re) {
					UmlCom.trace(
							filename + "\nimportElementsInTypes: error importing elements in types " + re.toString());
				}

				// import base types for complex types
				NodeList baseTypeList = null;
				try {
					baseTypeList = (NodeList) xPath.evaluate(
							"xs:simpleContent[1]/xs:extension[1][@base] | xs:complexContent[1]/xs:extension[1][@base]",
							typeElement, XPathConstants.NODESET);
					if (baseTypeList != null)
						for (int j = 0; j < baseTypeList.getLength(); j++) {
							Element baseTypeElement = (Element) baseTypeList.item(j);
							String baseTypeName = filterToken(baseTypeElement.getAttribute("base"));
							UmlClass baseType = findTypeByPrefix(doc, (UmlPackage) (ns.referenceClassView.parent()),
									baseTypeName);
							if (baseType == null) {
								UmlCom.trace(filename2 + "importElementsInType: base type not found: " + baseTypeName);
								filename2 = "";
								continue;
							}
							try {
								UmlBaseRelation.create(aRelationKind.aGeneralisation, typeClass, baseType);
							} catch (Exception re) {
								trace(filename2 + "importElementsInType: " + complexTypeName
										+ " already related to base type" + baseTypeName + " " + re.toString());
								filename2 = "";
							}
						}
				} catch (Exception e) {
					UmlCom.trace(filename + "\nimportElementsInTypes: error importing base types for complex types"
							+ e.toString());
				}

				// import attribute groups in type
				attributeGroupList = null;
				try {
					attributeGroupList = (NodeList) xPath.evaluate("descendant::xs:attributeGroup[@ref]", typeElement,
							XPathConstants.NODESET);
					if (attributeGroupList != null)
						for (int j = 0; j < attributeGroupList.getLength(); j++) {
							Element attributeGroupElement = (Element) attributeGroupList.item(j);
							String attributeGroupName = filterToken(attributeGroupElement.getAttribute("ref"));
							String prefix = getPrefix(attributeGroupName);
							String attributeGroupName2 = prefix + NAMESPACE_DELIMITER + ATTRIBUTE_PREFIX
									+ getName(attributeGroupName);
							UmlClass attributeGroupClass = null;
							// if (prefix.equals(""))
							if (prefix == null)
								attributeGroupClass = findType((UmlPackage) (ns.referenceClassView.parent()),
										ns.schemaURI, ATTRIBUTE_PREFIX + getName(attributeGroupName));
							else
								attributeGroupClass = findTypeByPrefix(doc,
										(UmlPackage) (ns.referenceClassView.parent()), attributeGroupName2);
							if (attributeGroupClass == null) {
								UmlCom.trace(filename2 + "importElementsInType: attribute group not found: "
										+ attributeGroupName);
								filename2 = "";
								continue;
							}
							try {
								UmlBaseRelation.create(aRelationKind.aDirectionalAggregation, typeClass,
										attributeGroupClass);
							} catch (Exception re) {
								UmlCom.trace(filename2 + "importElementsInType: cannot relate " + complexTypeName
										+ " to " + attributeGroupName + " " + re.toString());
								filename2 = "";
							}
						}
				} catch (Exception e) {
					UmlCom.trace(filename + "\nimportElementsInTypes:error importing attributeGroup in complex types"
							+ e.toString());
				}

				// import attributes in type
				String uri = ns.schemaURI + HASH_DELIMITER + filterHash(complexTypeName);
				List<UmlClassInstance> elementInTypeList = (List<UmlClassInstance>) (NiemElementsInType.get(uri));
				if (elementInTypeList == null) {
					elementInTypeList = new ArrayList<UmlClassInstance>();
					NiemElementsInType.put(uri, elementInTypeList);
				}
				try {
					NodeList attributeList = (NodeList) xPath.evaluate("descendant::xs:attribute[@ref]", typeElement,
							XPathConstants.NODESET);
					if (attributeList != null)
						for (int j = 0; j < attributeList.getLength(); j++) {
							Element attributeElement = (Element) attributeList.item(j);
							String attributeName = filterToken(attributeElement.getAttribute("ref"));
							String attributeName2 = getPrefix(attributeName) + NAMESPACE_DELIMITER + ATTRIBUTE_PREFIX
									+ getName(attributeName);
							trace("importElementsInTypes: importing attribute :" + attributeName2 + " in group "
									+ complexTypeName);
							String minOccurs = "1";
							String maxOccurs = "1";
							if (filterNameToken(attributeElement.getAttribute("use")).equals("optional"))
								minOccurs = "0";
							String multiplicity = minOccurs + "," + maxOccurs;
							UmlAttribute attribute = null;
							try {
								attribute = addElementInType(doc, ns.referenceClassView, ns.schemaURI, complexTypeName,
										attributeName2, multiplicity);
							} catch (Exception re) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot create attrbute "
										+ attributeName2 + " in type " + complexTypeName + " " + re.toString());
								filename2 = "";
							}
							if (attribute == null) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot create attribute "
										+ attributeName2 + " in type " + complexTypeName);
								continue;
							}
							UmlClassInstance classInstance = null;
							try {
								classInstance = findElementByPrefix(doc, (UmlPackage) (ns.referenceClassView.parent()),
										attributeName2);
							} catch (Exception re) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot find attribute "
										+ attributeName2 + " " + re.toString());
								filename2 = "";
							}
							if (classInstance == null) {
								UmlCom.trace(
										filename2 + "importElementsInTypes: cannot find attribute " + attributeName2);
								filename2 = "";
								continue;
							}
							try {
								UmlTypeSpec classInstanceType = new UmlTypeSpec();
								classInstanceType.type = classInstance.type();
								if (classInstanceType.type != null)
									attribute.set_Type(classInstanceType);
							} catch (Exception re) {
								UmlCom.trace(filename + "\nimportElementsInTypes: error setting description and type "
										+ re.toString());
							}
							elementInTypeList.add(classInstance);
						}
				} catch (Exception re) {
					UmlCom.trace(
							filename + "\nimportElementsInTypes: error importing attributes in type " + re.toString());
				}

				// import elements in type
				try {
					NodeList elementList = (NodeList) xPath.evaluate("descendant::xs:sequence[1]/xs:element[@ref]",
							typeElement, XPathConstants.NODESET);
					if (elementList != null)
						for (int k = 0; k < elementList.getLength(); k++) {
							Element elementElement = (Element) elementList.item(k);
							String elementName = filterToken(elementElement.getAttribute("ref"));
							String minOccurs = elementElement.getAttribute("minOccurs");
							if (minOccurs.equals(""))
								minOccurs = "1";
							String maxOccurs = elementElement.getAttribute("maxOccurs");
							if (maxOccurs.equals(""))
								maxOccurs = "1";
							String multiplicity = minOccurs + "," + maxOccurs;
							UmlAttribute element = null;
							try {
								element = addElementInType(doc, ns.referenceClassView, ns.schemaURI, complexTypeName,
										elementName, multiplicity);
							} catch (Exception re) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot create element " + elementName
										+ " in type " + complexTypeName + " " + re.toString());
								filename2 = "";
							}
							if (element == null) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot create element " + elementName
										+ " in type " + complexTypeName);
								continue;
							}
							UmlClassInstance classInstance = null;
							try {
								String prefix = getPrefix(elementName);
								// if (prefix.equals(""))
								if (prefix == null)
									classInstance = findElement((UmlPackage) (ns.referenceClassView.parent()),
											ns.schemaURI, elementName);
								else
									classInstance = findElementByPrefix(doc,
											(UmlPackage) (ns.referenceClassView.parent()), elementName);
							} catch (Exception re) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot find element " + elementName
										+ " " + re.toString());
								filename2 = "";
							}
							if (classInstance == null) {
								UmlCom.trace(filename2 + "importElementsInTypes: cannot find element " + elementName);
								filename2 = "";
								continue;
							}
							try {
								UmlTypeSpec classInstanceType = new UmlTypeSpec();
								classInstanceType.type = classInstance.type();
								if (classInstanceType.type != null)
									element.set_Type(classInstanceType);
							} catch (Exception re) {
								UmlCom.trace(filename + "\nimportElementsInTypes: error setting description and type "
										+ re.toString());
							}
							elementInTypeList.add(classInstance);
						}
				} catch (Exception re) {
					UmlCom.trace(
							filename + "\nimportElementsInTypes: error importing elements in type " + re.toString());
				}
			}
		return ns;
	}

	// import namespaces and return target namespace
	private static Namespace importNamespaces(Document doc) {
		// reset prefixes
		// Prefixes.clear();

		NamedNodeMap nslist = doc.getDocumentElement().getAttributes();
		for (int i = 0; i < nslist.getLength(); i++) {
			Node attributeNode = nslist.item(i);
			String attributeName = attributeNode.getNodeName();
			if (attributeName.startsWith(NAMESPACE_ATTRIBUTE)) {
				String prefix = (attributeName.equals(NAMESPACE_ATTRIBUTE)) ? attributeNode.getNodeValue()
						: attributeName.substring(6);
				prefix = filterNameToken(prefix);
				addNamespace(referencePackage, prefix, attributeNode.getNodeValue());
			}
		}

		// get target namespace
		Namespace ns = null;
		try {
			String schemaURI = xPath.evaluate("xs:schema/@targetNamespace", doc);
			ns = Namespaces.get(schemaURI);
			if (ns == null)
				return findNamespace(LOCAL_PREFIX);

			// set namespace description
			ns.referenceClassView
					.set_Description(xPath.evaluate("xs:schema/xs:annotation[1]/xs:documentation[1]", doc));
		} catch (NullPointerException re) {
			UmlCom.trace("importNamespaces: null pointer ");
		} catch (Exception e) {
			UmlCom.trace("importNamespaces: exception " + e.toString());
		}
		return ns;
	}

	// import NIEM reference model into HashMaps to support validation of NIEM
	// elements and types
	public static void importSchemaDir(String dir, Boolean includeEnums) throws IOException {

		// cache reference model
		cacheModel(referencePackage);
		setExternalSchemas();

		// import abstract types
		UmlClassView classView;
		if (referenceAbstractType == null) {
			String localUri = LOCAL_PREFIX;
			classView = addNamespace(referencePackage, LOCAL_PREFIX, localUri);
			referenceAbstractType = addReferenceType(classView, getURI(classView), ABSTRACT_TYPE_NAME, "abstract type",
					"");
			NiemTypes.put(getURI(referenceAbstractType), referenceAbstractType);
		}

		// import XML namspace
		classView = addNamespace(referencePackage, XML_PREFIX, XML_URI);

		// import XML schema namespace and simple types
		classView = addNamespace(referencePackage, XSD_PREFIX, XSD_URI);
		String[] xmlTypeNames = { "anyURI", "base64Binary", "blockSet", "boolean", "byte", "date", "dateTime",
				"DateTimeStamp", "dayTimeDuration", "decimal", "derivationControl", "derivationSet", "double",
				"duration", "ENTITIES", "ENTITY", "float", "formChoice", "fullDerivationSet", "gDay", "gMonth",
				"gMonthDay", "gYear", "gYearMonth", "hexBinary", "ID", "IDREF", "IDREFS", "int", "integer", "language",
				"long", "Name", "namespaceList", "NCName", "negativeInteger", "NMTOKEN", "NMTOKENS",
				"nonNegativeInteger", "nonPositiveInteger", "normalizedString", "NOTATION", "positiveInteger", "public",
				"QName", "short", "simpleDerivationSet", "string", "time", "token", "unsignedByte", "unsignedInt",
				"unsignedLong", "unsignedShort", "yearMonthDuration" };
		for (String typeName : xmlTypeNames) {
			// UmlClass c = UmlClass.create(cv, s);
			// NiemTypes.put(XMLConstants.W3C_XML_SCHEMA_NS_URI + hashDelimiter
			// + s, c);
			UmlClass typeClass = addReferenceType(classView, XSD_URI, typeName, "", "");
			if (typeClass != null) {
				NiemTypes.put(getURI(typeClass), typeClass);
				trace("importSchemaDir: added type " + getURI(typeClass));
			}
		}

		// import xs:any element
		if (referenceAnyElement == null) {
			referenceAnyElement = addReferenceElement(null, classView, XSD_URI, ANY_ELEMENT_NAME, null, "");
			if (referenceAnyElement != null)
				NiemElements.put(getURI(referenceAnyElement), referenceAnyElement);
		}

		// Configure DOM
		Path path = FileSystems.getDefault().getPath(dir);
		String importPath = path.toString();
		// String importPath = "";

		int passes = (includeEnums) ? 4 : 3;

		// Walk directory to import in passes (0: types, 1: elements, 2:
		// elements in types, 3: enumerations
		for (importPass = 0; importPass < passes; importPass++) {
			switch (NiemTools.importPass) {
			case 0:
				UmlCom.trace("\nImporting types");
				break;
			case 1:
				UmlCom.trace("\nImporting elements");
				break;
			case 2:
				UmlCom.trace("\nImporting elements and attributes in types");
				break;
			}
			Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
				@Override
				public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
					// Configure DOM
					DocumentBuilder db = null;
					DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
					docBuilderFactory.setNamespaceAware(true);
					try {
						db = docBuilderFactory.newDocumentBuilder();
					} catch (ParserConfigurationException e) {
						UmlCom.trace("importSchemaDir: could not configure parser " + e.toString());
					}

					String filename = file.toString();
					String filepath1 = filename.replaceFirst(java.util.regex.Matcher.quoteReplacement(importPath), "");
					String filepath = filepath1.replaceAll(java.util.regex.Matcher.quoteReplacement("\\"), "/");
					if (filename.endsWith(XSD_FILE_TYPE)) {
						UmlCom.trace("Importing " + filepath);
						switch (NiemTools.importPass) {
						case 0:
							Namespace ns = importTypes(db, filename);
							ns.referenceClassView.set_PropertyValue(FILE_PATH_PROPERTY, NIEM_DIR + filepath);
							break;
						case 1:
							importElements(db, filename);
							break;
						case 2:
							importElementsInTypes(db, filename);
							break;
						}
					}
					return FileVisitResult.CONTINUE;
				}
			});
		}

		// Sorting
		UmlCom.trace("Sorting namespaces");
		referencePackage.sort();

		UmlCom.trace("Namespaces: " + Namespaces.size());
		UmlCom.trace("Types: " + NiemTypes.size());
		UmlCom.trace("Elements: " + NiemElements.size());
	}

	// import NIEM reference model types into HashMaps
	private static Namespace importTypes(DocumentBuilder db, String filename) {
		trace("importTypes: importing types from schema " + filename);
		String filename2 = "\n" + filename + "\n";
		Namespace ns = null;
		try {
			// parse the schema
			Document doc = db.parse(new File(filename));
			xPath.setNamespaceContext(new NamespaceResolver(doc, true));
			ns = importNamespaces(doc);

			// compile XPath queries
			XPathExpression xe = xPath.compile("xs:annotation[1]/xs:documentation[1]");
			XPathExpression xe1 = xPath.compile("xs:restriction[1]/xs:enumeration");
			// XPathExpression xe2 = xPath.compile("xs:annotation[1]/xs:documentation[1]");

			// import types
			NodeList typeList = (NodeList) xPath.evaluate("xs:complexType|xs:simpleType[@name]",
					doc.getDocumentElement(), XPathConstants.NODESET);
			for (int i = 0; i < typeList.getLength(); i++) {
				Element typeElement = (Element) typeList.item(i);
				String nodeType = typeElement.getNodeName();
				String typeName = filterNameToken(typeElement.getAttribute("name"));
				try {
					UmlClass thisClass = addReferenceType(ns.referenceClassView, ns.schemaURI, typeName,
							xe.evaluate(typeElement), "");
					if (thisClass == null) {
						UmlCom.trace("importTypes: cannot create type " + typeName);
						continue;
					}
					NiemTypes.put(getURI(thisClass), thisClass);
					trace("importTypes: type added: " + getURI(thisClass));
					if (nodeType == "xs:simpleType") {
						thisClass.set_Stereotype("enum_pattern");
						// import enumerated values for simple types (codes)
						NodeList elist = (NodeList) xe1.evaluate(typeElement, XPathConstants.NODESET);
						String codeList = "";
						for (int j = 0; j < elist.getLength(); j++) {
							Element enumElement = (Element) elist.item(j);
							String value = filterEnum(filterUMLName(enumElement.getAttribute("value")));
							// value.replace(";", ",").replace("=", "-");
							String codeDescription = null;
							if (_IMPORT_CODE_DESCRIPTIONS)
								codeDescription = filterEnum(filterASCII(xe.evaluate(enumElement)));
							if (codeDescription != null && !codeDescription.equals("")) {
								// codeDescription.replace(";",",").replace("=", "-");
								codeList += value + CODELIST_DEFINITION_DELIMITER + codeDescription + CODELIST_DELIMITER
										+ " ";
							} else
								codeList += value + CODELIST_DELIMITER + " ";
						}
						if (!codeList.equals(""))
							thisClass.set_PropertyValue(CODELIST_PROPERTY, codeList);
					}
				} catch (NullPointerException re) {
					UmlCom.trace(filename2 + "importTypes: null pointer " + typeName);
					filename2 = "";
				} catch (Exception re) {
					UmlCom.trace(filename2 + "importTypes: cannot create type " + typeName + " " + re.toString());
					filename2 = "";
				}
			}

			// import attribute groups
			NodeList attributeGroupList = (NodeList) xPath.evaluate("xs:attributeGroup[@name]",
					doc.getDocumentElement(), XPathConstants.NODESET);
			for (int i = 0; i < attributeGroupList.getLength(); i++) {
				Element attributeGroupElement = (Element) attributeGroupList.item(i);
				String attributeGroupName = ATTRIBUTE_PREFIX
						+ filterNameToken(attributeGroupElement.getAttribute("name"));
				trace("importTypes: adding attribute group: " + attributeGroupName + " to schema " + ns.schemaURI);
				try {
					UmlClass thisClass = addReferenceType(ns.referenceClassView, ns.schemaURI, attributeGroupName,
							xe.evaluate(attributeGroupElement), "");
					if (thisClass == null) {
						UmlCom.trace("importTypes: cannot create attribute group " + attributeGroupName);
						continue;
					}
					NiemTypes.put(getURI(thisClass), thisClass);
				} catch (NullPointerException re) {
					UmlCom.trace(filename2 + "importTypes: null pointer " + attributeGroupName);
					filename2 = "";
				} catch (Exception re) {
					UmlCom.trace(filename2 + "importTypes: cannot create attribute group " + attributeGroupName + " "
							+ re.toString());
					filename2 = "";
				}
			}
		} catch (NullPointerException re) {
			UmlCom.trace(filename2 + "importTypes: null pointer ");
			filename2 = "";
		} catch (Exception re) {
			UmlCom.trace(filename2 + "importTypes: exception " + re.toString());
			filename2 = "";
		}

		return ns;
	}

	// identify UBL types and elements
	public static Boolean isExternalPrefix(String prefix) {
		// String prefix = getPrefix(tagName);
		if (prefix == null)
			return false;
		return externalPrefixes.contains(prefix);
	}

	// indicate whether an element exists in reference model
	private static Boolean isNiemElement(String elementName) {

		if ((elementName == null) || elementName.equals("") || elementName.equals("??")
				|| isExternalPrefix(getPrefix(elementName)))
			return false;

		// trace("isNiemElement: find element " + elementName);
		String prefix = getPrefix(elementName);
		String schemaURI = getURI(elementName);
		// String schemaURI = Prefixes.get(prefix);
		if (schemaURI == null) {
			UmlCom.trace("isNiemElement: Cannot find prefix " + prefix + " for element " + elementName);
			return false;
		}
		String elementName2 = getName(elementName);
		// elementName2 = elementName2.replace("-", "");
		// trace("isNiemElement Searching for element " + schemaURI + hashDelimiter +
		// filterHash(elementName2));
		return NiemElements.containsKey(schemaURI + HASH_DELIMITER + filterHash(elementName2));
	}

	// get type by prefix and tagname
	private static Boolean isNiemElementInType(String typeName, String elementName) {
		// trace("isNiemElementInType: is element " + elementName + " in type " +
		// typeName + "?");
		if (!isNiemType(typeName) || !isNiemElement(elementName))
			return false;

		// parse type
		String typePrefix = getPrefix(typeName);
		String typeSchemaURI = getURI(typeName);
		// String typeSchemaURI = Prefixes.get(typePrefix);
		if (typeSchemaURI == null) {
			UmlCom.trace("isNiemElementInType: Cannot find prefix " + typePrefix + "in element " + typeName);
			return false;
		}
		String typeTagName = getName(typeName);

		// parse property
		String elementPrefix = getPrefix(elementName);
		String elementSchemaURI = getURI(elementName);
		// String elementSchemaURI = Prefixes.get(elementPrefix);
		if (elementSchemaURI == null) {
			UmlCom.trace("isNiemElementInType: Cannot find prefix " + elementPrefix + "in element " + elementName);
			return false;
		}
		String elementName2 = getName(elementName);
		// String elementName3 = elementName2;
		// String elementName3 = filterUMLName(elementName2);
		// String tagName2 = tagName.replace("-", "");
		String uri = elementSchemaURI + HASH_DELIMITER + filterHash(elementName2);
		UmlClassInstance ci = (UmlClassInstance) NiemElements.get(uri);
		if (ci == null) {
			UmlCom.trace("isNiemElementInType: element not found: " + uri);
			return false;
		}
		List<UmlClassInstance> list = (List<UmlClassInstance>) (NiemElementsInType
				.get(typeSchemaURI + HASH_DELIMITER + filterHash(typeTagName)));
		if (list == null) {
			UmlCom.trace("isNiemElementInType: elements not found in type " + typeTagName);
			return false;
		}
		for (UmlClassInstance ci2 : list)
			if (ci.equals(ci2))
				return true;

		UmlCom.trace("isNiemElementInType: element " + elementName + " not found in type " + typeName);
		return false;
	}

	// identify UBL types and elements
	private static Boolean isNiemPrefix(String prefix) {
		if (prefix == null)
			return false;
		String schemaURI = Prefixes.get(prefix);
		Namespace ns = Namespaces.get(schemaURI);
		if (ns == null)
			return false;
		return ns.referenceClassView != null;
	}

	// indicate whether a type exists in reference model
	private static Boolean isNiemType(String typeName) {
		if ((typeName == null) || typeName.equals("") || typeName.equals("??") || isExternalPrefix(getPrefix(typeName)))
			return false;

		String prefix = getPrefix(typeName);
		String schemaURI = Prefixes.get(prefix);
		if (schemaURI == null)
			return false;
		String typeName2 = getName(typeName);
		// String typeName3 = typeName2;
		// String typeName3 = filterUMLName(typeName2);
		// String tagName2 = tagName.replace("-", "");
		return NiemTypes.containsKey(schemaURI + HASH_DELIMITER + filterHash(typeName2));
	}

	// output one line of the NIEM mapping spreadsheet in CSV format
	private static String[] itemCsv(UmlItem item) {
		String[] nextLine = new String[NIEM_STEREOTYPE_MAP.length];
		try {
			// Export Class and Property
			switch (item.kind().value()) {
			case anItemKind._aClass:
				nextLine[0] = item.pretty_name();
				nextLine[1] = "";
				nextLine[2] = "";
				break;
			case anItemKind._anAttribute:
				nextLine[0] = item.parent().pretty_name();
				nextLine[1] = item.pretty_name();
				UmlAttribute a = (UmlAttribute) item;
				nextLine[2] = a.multiplicity();
				break;
			case anItemKind._aRelation:
				nextLine[0] = item.parent().pretty_name();
				UmlRelation r = (UmlRelation) item;
				nextLine[1] = r.pretty_name();
				nextLine[2] = r.multiplicity();
				break;
			case anItemKind._aClassInstance:
				nextLine[0] = "";
				nextLine[1] = item.pretty_name();
				nextLine[2] = "";
				break;
			default:
				nextLine[0] = item.parent().pretty_name();
				nextLine[1] = item.pretty_name();
				nextLine[2] = "";
				break;
			}
		} catch (Exception e) {
			UmlCom.trace("itemCsv: error importing class, property multiplicity " + e.toString());
		}

		// Export Description
		nextLine[3] = item.description();

		// Export NIEM Mapping
		if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
			// String prefix =
			// getPrefix((String)(item.propertyValue(niemStereotype+":Type")));
			for (int p = 4; p < NIEM_STEREOTYPE_MAP.length; p++)
				nextLine[p] = item.propertyValue(niemProperty(p));

		return nextLine;
	}

	// output a JSON name value pair
	private static void jsonOut(FileWriter fw, String name, String value) {
		try {
			fw.write(" \"" + name + "\" : \"" + value + "\",\n");
		} catch (Exception e) {
			UmlCom.trace("jsonOut: exception " + e.toString());
		}
	}

	// output a JSON name value pair
	private static void jsonOutLast(FileWriter fw, String name, String value) {
		try {
			fw.write(" \"" + name + "\" : \"" + value + "\"\n");
		} catch (Exception e) {
			UmlCom.trace("jsonOut: exception " + e.toString());
		}
	}

	// return the NIEM stereotype associated with a column in the NIEM mapping
	// spreadsheet
	private static String niemProperty(int p) {
		return NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[p][1];
	}

	/*
	 * // indicate whether an XML prefix matches a NIEM namespace public static
	 * boolean isNiemSchema(String prefix) { if (prefix == null) return false;
	 * return (Prefixes.containsKey(prefix)); }
	 */

	// output one column of the NIEM mapping spreadsheet in HTML format
	// protected static String columnHtml(String newValue, String oldValue,
	// String container, String schema) throws IOException

	private static void setExternalSchemas() {
		String externalSchemas = getProperty(IEPD_EXTERNAL_SCHEMAS_PROPERTY);
		String[] external = externalSchemas.split(",");
		for (int i = 0; i < external.length; i++) {
			String[] part = external[i].split("=");
			if (part.length > 2) {
				String prefix = part[0].trim();
				String schemaURI = part[1].trim();
				String schemaLocation = part[2].trim();
				externalPrefixes.add(prefix);
				Prefixes.put(prefix, schemaURI);
				externalSchemaURL.put(schemaURI, schemaLocation);
			}
		}
	}

	private static void setPrefix(UmlItem item, String value) {
		item.set_PropertyValue(PREFIX_PROPERTY, value);
	}

	private static void setPropertyDefault(String propertyName, String propertyValue) {
		UmlPackage root = UmlBasePackage.getProject();
		if (root.propertyValue(propertyName) == null)
			root.set_PropertyValue(propertyName, propertyValue);
	}

	/*
	 * // (re-)associate the NIEM stereotype with all properties in the UML public
	 * static void resetStereotype() {
	 * 
	 * @SuppressWarnings("unchecked") Iterator<UmlItem> it = UmlItem.all.iterator();
	 * while (it.hasNext()) { UmlItem item = (UmlItem) it.next(); if
	 * (item.stereotype().equals(niemStereotypeLabel)) {
	 * item.set_Stereotype(niemStereotype); item.applyStereotype(); } } }
	 */

	private static void setURI(UmlItem item, String value) {
		item.set_PropertyValue(URI_PROPERTY, value);
	}

	// output debugging information
	private static void trace(String output) {
		if (_TRACE)
			UmlCom.trace(output);
	}

	// verify reference model exists (NIEM)
	public static boolean verifyNIEM(UmlPackage root) {
		UmlPackage pimPackage = null;

		trace("verifyNIEM: creating NIEM folders");
		// Find NIEM package
		for (UmlItem ch : root.children()) {
			if (ch.pretty_name().equals("NIEM"))
				if ((ch.kind().value() == anItemKind._aPackage)) {
					pimPackage = (UmlPackage) ch;
					break;
				}
		}
		if (pimPackage != null)
			// Find package "NIEMReference"
			for (UmlItem ch : pimPackage.children()) {
				if (ch.pretty_name().equals("NIEMReference"))
					if ((ch.kind().value() == anItemKind._aPackage)) {
						referencePackage = (UmlPackage) ch;
						return true;
					}
			}

		UmlCom.trace("NIEM reference model does not exist.  Import NIEM reference schemas first.");
		return false;

	}

	// output a column of the NIEM mapping spreadsheet in HTML format
	private static void writeItemHtml(FileWriter fw, UmlItem item) throws IOException {
		if (item.known) {
			fw.write("<a href=\"");
			if (!UmlItem.flat && (item.parent() != null) && (item.parent().kind() == anItemKind.aClass)) {
				fw.write("class");
				fw.write(String.valueOf(item.parent().getIdentifier()));
			} else
				fw.write("index");
			fw.write(HTML_FILE_TYPE + "#ref");
			fw.write(String.valueOf(item.kind().value()));
			fw.write('_');
			fw.write(String.valueOf(item.getIdentifier()));
			fw.write("\"><b>");
			fw.write(item.pretty_name());
			fw.write("</b></a>");
		} else
			fw.write(item.pretty_name());
	}

	// output a line of the NIEM mapping spreadhseet in HTML format
	private static void writeLineHtml(FileWriter fw, UmlItem item) {
		try {
			// Export Class, Property and Multiplicity
			// trace("writeLineHtml: " + item.pretty_name());
			switch (item.kind().value()) {
			case anItemKind._aClass: {
				fw.write("<tr bgcolor=\"#f0f0f0\"><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item);
				fw.write("</td><td>");
				fw.write("</td><td>");
			}
				break;
			case anItemKind._anAttribute: {
				fw.write("<tr><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item.parent());
				fw.write("</td><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item);
				fw.write("</td><td>");
				UmlAttribute a = (UmlAttribute) item;
				fw.write(a.multiplicity());
			}
				break;
			case anItemKind._aRelation: {
				UmlRelation rel = (UmlRelation) item;
				if ((rel.relationKind() == aRelationKind.aGeneralisation)
						|| (rel.relationKind() == aRelationKind.aRealization))
					return;
				else {
					fw.write("<tr><td style=\"word-wrap: break-word\">");
					writeItemHtml(fw, item.parent());
					fw.write("</td><td style=\"word-wrap: break-word\">");
					writeItemHtml(fw, item);
					fw.write("</td><td>");
					fw.write(rel.multiplicity());
				}
			}
				break;
			default:
				return;
			}
			fw.write("</td><td>");

			// Export Description
			if (item.description() != null)
				fw.write(item.description());
			fw.write("</td>");

			// Export NIEM Mapping
			int p;
			// String oldValue, container;
			String[] column = new String[NIEM_STEREOTYPE_MAP.length];
			String extensionBGColor = "#ffd700";
			String defaultBGColor = "#ffffff";
			String invalidFGColor = "#ff0000"; // invalid NIEM mappings are red
			String changedFGColor = "#0000ff"; // changes from the previous
			// version are blue
			String defaultFGColor = "#000000";
			String fgcolor, bgcolor;

			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
				for (p = 4; p < NIEM_STEREOTYPE_MAP.length; p++) {
					column[p] = (String) (item.propertyValue(niemProperty(p)));
					column[p] = (column[p] != null) ? column[p].trim() : "";
				}

				// determine if this is an extension
				/*
				 * Boolean extension = false; String[] xPathElements = column[4].split("/"); for
				 * (String element : xPathElements) { String prefix = getPrefix(element); if
				 * (!prefix.equals("") && !isNiemSchema(prefix) &&
				 * !isExternalPrefix(getPrefix(element.trim()))) { extension = true; continue; }
				 * }
				 */

				// export XPath
				String XPath = column[4].trim();
				String oldXPath = column[9].trim();
				// bgcolor = (extension) ? extensionBGColor : defaultBGColor;
				bgcolor = defaultBGColor;
				fgcolor = (XPath.equals(oldXPath)) ? defaultFGColor : changedFGColor;
				fw.write(columnHtml(XPath, bgcolor, fgcolor, true));

				// export Type
				String typeName = column[5].trim();
				String typePrefix = getPrefix(typeName);
				bgcolor = defaultBGColor;
				fgcolor = defaultFGColor;
				if (!typeName.equals("")) {
					if (isNiemPrefix(getPrefix(typeName)) && !isNiemType(typeName))
						fgcolor = invalidFGColor;
					if (!isNiemPrefix(typePrefix) && !isExternalPrefix(typePrefix))
						bgcolor = extensionBGColor;
				}
				fw.write(columnHtml(typeName, bgcolor, fgcolor, true));

				// export Property
				String elementLine = column[6];
				fgcolor = defaultFGColor;
				bgcolor = defaultBGColor;
				if (!elementLine.equals("")) {
					String[] elementNames = elementLine.split(",");
					for (String elementName : elementNames) {
						elementName = elementName.trim();
						Matcher mat = Pattern.compile("\\((.*?)\\)").matcher(elementName);
						if (!mat.find()) {
							String prefix = getPrefix(elementName);
							if (isNiemPrefix(typePrefix) && isNiemPrefix(prefix)
									&& !isNiemElementInType(typeName, elementName))
								fgcolor = invalidFGColor;
							prefix = getPrefix(elementLine);
							if (!isNiemPrefix(prefix) && !isExternalPrefix(prefix))
								bgcolor = extensionBGColor;
						}
					}
				}
				fw.write(columnHtml(elementLine, bgcolor, fgcolor, true));

				// export BaseType
				String baseType = column[7].trim();
				String basePrefix = getPrefix(baseType);
				bgcolor = defaultBGColor;
				fgcolor = defaultFGColor;
				if (!baseType.equals("") && !baseType.equals(ABSTRACT_TYPE_NAME)) {
					if (!isNiemPrefix(basePrefix) && !isExternalPrefix(basePrefix))
						bgcolor = extensionBGColor;
					if (isNiemPrefix(basePrefix) && !isNiemType(baseType))
						fgcolor = invalidFGColor;
				}
				fw.write(columnHtml(baseType, bgcolor, fgcolor, true));

				// export Multiplicity
				bgcolor = defaultBGColor;
				String multiplicity = column[8];
				fgcolor = (multiplicity.equals(column[10])) ? defaultFGColor : changedFGColor;
				String minoccurs, maxoccurs;
				if ((multiplicity.equals("")))
					minoccurs = maxoccurs = "1";
				else if (multiplicity.contains(",")) {
					String[] occurs = multiplicity.split(",");
					minoccurs = occurs[0];
					maxoccurs = occurs[1];
				} else
					minoccurs = maxoccurs = multiplicity;
				try {
					if (Integer.parseInt(minoccurs) < 0)
						throw new NumberFormatException();
					if (!maxoccurs.equals("unbounded") && (Integer.parseInt(maxoccurs) < 1))
						throw new NumberFormatException();
				} catch (NumberFormatException e) {
					fgcolor = invalidFGColor;
				}
				fw.write(columnHtml(column[8], bgcolor, fgcolor, false));

				// export Old XPath
				bgcolor = defaultBGColor;
				fgcolor = defaultFGColor;
				fw.write(columnHtml(column[9], bgcolor, fgcolor, true));

				// export Old Multiplicity
				bgcolor = defaultBGColor;
				fw.write(columnHtml(column[10], bgcolor, fgcolor, false));

				// export NIEM Mapping Notes
				bgcolor = defaultBGColor;
				fw.write(columnHtml(column[11], bgcolor, fgcolor, true));

				// export code list
				bgcolor = defaultBGColor;
				fw.write(columnHtml(column[12], bgcolor, fgcolor, true));
			}

			fw.write("</tr>");
		} catch (Exception e) {
			UmlCom.trace("writeLineHtml: exception " + e.toString());
		}
	}

	// output an XML name value pair
	private static void xmlAttribute(FileWriter fw, String name, String value) {
		try {
			fw.write(" " + name + "=\"" + value + "\"");
		} catch (Exception e) {
			UmlCom.trace("xmlAttribute: exception " + e.toString());
		}
	}

	// output an XML namespace attribute
	private static void xmlNS(FileWriter fw, String prefix, String value) {
		try {
			if (prefix.equals(""))
				fw.write(" " + NAMESPACE_ATTRIBUTE + "=\"" + value + "\"");
			else
				fw.write(" " + NAMESPACE_ATTRIBUTE + ":" + prefix + "=\"" + value + "\"");
		} catch (Exception e) {
			UmlCom.trace("xmlNS: exception " + e.toString());
		}
	}

	public NiemTools() {
		super();

		// set IEPD configuraion defaults
		setPropertyDefault(IEPD_URI_PROPERTY, IEPD_URI_DEFAULT);
		setPropertyDefault(IEPD_NAME_PROPERTY, IEPD_NAME_DEFAULT);
		setPropertyDefault(IEPD_VERSION_PROPERTY, IEPD_VERSION_DEFAULT);
		setPropertyDefault(IEPD_STATUS_PROPERTY, IEPD_STATUS_DEFAULT);
		setPropertyDefault(IEPD_ORGANIZATION_PROPERTY, IEPD_ORGANIZATION_DEFAULT);
		setPropertyDefault(IEPD_CONTACT_PROPERTY, IEPD_CONTACT_DEFAULT);
		setPropertyDefault(IEPD_READ_ME_FILE_PROPERTY, IEPD_READ_ME_FILE_DEFAULT);
		setPropertyDefault(IEPD_CHANGE_LOG_FILE_PROPERTY, IEPD_CHANGE_LOG_FILE_DEFAULT);
		setPropertyDefault(IEPD_EXTERNAL_SCHEMAS_PROPERTY, IEPD_EXTERNAL_SCHEMAS_DEFAULT);
	}
}
