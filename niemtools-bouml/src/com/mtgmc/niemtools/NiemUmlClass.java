package com.mtgmc.niemtools;


/*
 *   NIEMtools - This is a plug_out that extends the BOUML UML tool with support for the National Information Exchange Model (NIEM) defined at http://niem.gov.
 *   Specifically, it enables a UML Common Information Model (CIM), an abstract class mode, to be mapped into a
 *   UML Platform Specific Model (PSM), the NIEM reference/subset/extension model, and a UML Platform Specific Model (NIEM), NIEM XML Schema.
 *
 *   NOTE: This plug_out requires that the BOUML project include a simple NIEM profile that provides the stereotypes required for mapping.
 *   
 *   Copyright (C) 2017 James E. Cabral Jr., MTG Management Consultants LLC, jcabral@mtgmc.com, http://github.com/cabralje
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitResult;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
//import java.util.concurrent.ThreadLocalRandom;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.XMLConstants;
// DOM
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

//OpenCSV library
import com.opencsv.CSVReader;
import com.opencsv.CSVWriter;

import fr.bouml.UmlAttribute;
import fr.bouml.UmlClass;
import fr.bouml.UmlClassInstance;
import fr.bouml.UmlClassView;
import fr.bouml.UmlCom;
import fr.bouml.UmlItem;
import fr.bouml.UmlOperation;
import fr.bouml.UmlPackage;
import fr.bouml.UmlParameter;
import fr.bouml.UmlRelation;
import fr.bouml.aRelationKind;
import fr.bouml.anItemKind;

public class NiemUmlClass {

	static final String ERROR_RESPONSE = "cbrn:MessageStatus";
	// Debugging options
	//private static Boolean _TRACE = true;
	private static final Boolean _TRACE = false;
	static final String XSD_PREFIX = "xs";
	static final String XSD_URI = XMLConstants.W3C_XML_SCHEMA_NS_URI;
	static final String XSD_FILE_TYPE = ".xsd";
	static final String XML_FILE_TYPE = ".xml";
	private static final String HTML_FILE_TYPE = ".html";
	static final String XML_HEADER = "<?xml version=\"1.0\" encoding=\"US-ASCII\"?>\n";
	static final String XML_ATTRIBUTION = "<!-- Generated by BOUML niemtools plug_out (https://github.com/cabralje/niem-tools) -->\n";
	static final String CODELIST_APPINFO_PREFIX = "clsa";
	static final String CODELIST_APPINFO_URI = "http://reference.niem.gov/niem/specification/code-lists/1.0/code-lists-schema-appinfo/";
	static final String STRUCTURES_PREFIX = "structures";
	private static final String NIEM_VERSION_DEFAULT = "4.0";
	// NIEM conformance targets
	static final String CT_PREFIX = "ct";
	static final String CT_URI = "http://release.niem.gov/niem/conformanceTargets/3.0/";
	// NIEM terms
	static final String TERM_PREFIX = "term";
	static final String TERM_URI = "http://release.niem.gov/niem/localTerminology/3.0/";
	// NIEM subset schema generation tool (SSGT)
	private static final String WANTLIST_URI = "http://niem.gov/niem/wantlist/2.2";
	// Niem-tools UML modeling
	private static final String NIEM_PACKAGE = "NIEM";
	private static final String NIEM_REFERENCE_PACKAGE = "NIEMReference";
	private static final String NIEM_SUBSET_PACKAGE = "NIEMSubset";
	private static final String NIEM_EXTENSION_PACKAGE = "NIEMExtension";
	private static final String MAPPING_SPREADSHEET_TITLE = "NIEM Mapping";
	static final String ATTRIBUTE_PREFIX = "@";
	private static final String REFERENCE_PREFIX = "^";
	private static final String HASH_DELIMITER = ",";
	static final String CODELIST_DELIMITER = ";";
	static final String CODELIST_DEFINITION_DELIMITER = "=";
	static final String NOTES_PROPERTY = "Notes";
	static final String NILLABLE_PROPERTY = "isNillable";
	static final String URI_PROPERTY = "URI";
	static final String PREFIX_PROPERTY = "prefix";
	static final String SUBSTITUTION_PROPERTY = "substitutesFor";
	static final String CODELIST_PROPERTY = "codeList";
	static final String FILE_PATH_PROPERTY = "path";
	static final String MESSAGE_ELEMENT_PROPERTY = "messageElement";
	static final String LOCAL_PREFIX = "local";
	static final String LOCAL_URI = "local";
	static final String ABSTRACT_TYPE_NAME = "abstract";
	static final String ANY_ELEMENT_NAME = "any";
	// IEPD Properties
	public static final String IEPD_EXTERNAL_SCHEMAS_PROPERTY = "externalSchemas";
	public static final String IEPD_CHANGE_LOG_FILE_PROPERTY = "IEPDChangeLogFile";
	public static final String IEPD_READ_ME_FILE_PROPERTY = "IEPDReadMeFile";
	public static final String IEPD_CONTACT_PROPERTY = "IEPDContact";
	public static final String IEPD_EMAIL_PROPERTY = "IEPDEmail";
	public static final String IEPD_LICENSE_URL_PROPERTY = "IEPDLicense";
	public static final String IEPD_TERMS_URL_PROPERTY = "IEPDTermsOfService";
	public static final String IEPD_ORGANIZATION_PROPERTY = "IEPDOrganization";
	public static final String IEPD_STATUS_PROPERTY = "IEPDStatus";
	public static final String IEPD_VERSION_PROPERTY = "IEPDVersion";
	public static final String IEPD_NAME_PROPERTY = "IEPDName";
	public static final String IEPD_URI_PROPERTY = "IEPDURI";
	public static final String IEPD_CHANGE_LOG_FILE_DEFAULT = "changelog.txt";
	public static final String IEPD_READ_ME_FILE_DEFAULT = "readme.txt";
	public static final String IEPD_CONTACT_DEFAULT = "Contact";
	public static final String IEPD_EMAIL_DEFAULT = "email@example.com";
	public static final String IEPD_LICENSE_URL_DEFAULT = "https://opensource.org/licenses/BSD-3-Clause";
	public static final String IEPD_TERMS_URL_DEFAULT = "example.com/terms";
	public static final String IEPD_ORGANIZATION_DEFAULT = "Organization";
	public static final String IEPD_STATUS_DEFAULT = "Draft";
	public static final String IEPD_VERSION_DEFAULT = "1.0";
	public static final String IEPD_NAME_DEFAULT = "IEPD";
	public static final String IEPD_URI_DEFAULT = "http://local";
	public static final String IEPD_EXTERNAL_SCHEMAS_DEFAULT = "cac=urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2=http://docs.oasis-open.org/ubl/os-UBL-2.1/xsd/common/UBL-CommonAggregateComponents-2.1.xsd,"
			+ "cbc=urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2=http://docs.oasis-open.org/ubl/os-UBL-2.1/xsd/common/UBL-CommonBasicComponents-2.1.xsd,"
			+ "ds=http://www.w3.org/2000/09/xmldsig#=https://www.w3.org/TR/xmldsig-core/xmldsig-core-schema.xsd";
	// File locations
	static final String NIEM_DIR = "niem";
	// Niem stereotype configuration
	public static final String NIEM_STEREOTYPE_TYPE = "niem-profile:niem";
	public static final String WEBSERVICE_STEREOTYPE_TYPE = "niem-profile:webservice";

	static final String STEREOTYPE_DELIMITER = ":";
	// private static final String NIEM_STEREOTYPE_LABEL = "niem:niem";
	// NIEM mapping spreadsheet column headings, NIEM profile profile stereotype
	private static final String[][] NIEM_STEREOTYPE_MAP = { { "Model Class", "", }, // 0
			{ "Model Attribute", "", }, // 1
			{ "Model Multiplicity", "", }, // 2
			{ "Model Definition", "", }, // 3
			{ "NIEM XPath", "XPath" }, // 4
			{ "NIEM Type", "Type" }, // 5
			{ "NIEM Property, " + REFERENCE_PREFIX + "Reference, (Representation)", "Property" }, // 6
			{ "NIEM Base Type", "BaseType" }, // 7
			{ "NIEM Multiplicity", "Multiplicity" }, // 8
			{ "Old XPath", "OldXPath" }, // 9
			{ "Old Multiplicity", "OldMultiplicity" }, // 10
			{ "NIEM Mapping Notes", "Notes" }, // 11
			{ "Code List Code=Definition;", "CodeList" } }; // 12

	// private static final String NIEM_STEREOTYPE_CLASS = NIEM_STEREOTYPE_TYPE +
	// STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[0][1];
	// private static final String NIEM_STEREOTYPE_ATTRIBUTE = NIEM_STEREOTYPE_TYPE
	// + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[1][1];
	// private static final String NIEM_STEREOTYPE_MODEL_MULTIPLICITY =
	// NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[2][1];
	// private static final String NIEM_STEREOTYPE_DEFINITION = NIEM_STEREOTYPE_TYPE
	// + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[3][1];
	static final String NIEM_STEREOTYPE_XPATH = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[4][1];
	private static final String NIEM_STEREOTYPE_TYPENAME = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[5][1];
	private static final String NIEM_STEREOTYPE_PROPERTY = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[6][1];
	private static final String NIEM_STEREOTYPE_BASE_TYPE = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[7][1];
	private static final String NIEM_STEREOTYPE_MULTIPLICITY = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[8][1];
	// private static final String NIEM_STEREOTYPE_OLD_XPATH = NIEM_STEREOTYPE_TYPE
	// + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[9][1];
	// private static final String NIEM_STEREOTYPE_OLD_MULTIPLICITY =
	// NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[10][1];
	private static final String NIEM_STEREOTYPE_NOTES = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[11][1];
	private static final String NIEM_STEREOTYPE_CODE_LIST = NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER
			+ NIEM_STEREOTYPE_MAP[12][1];

	public static int importPass;
	public static String importPath;
	
	static Set<String> CodeListNamespaces = new HashSet<String>();

	static NiemModel ReferenceModel = new NiemModel();
	static NiemModel SubsetModel = new NiemModel();
	static NiemModel ExtensionModel = new NiemModel();
	
	/** return attribute name with prefix filtered */
	static String filterAttributePrefix(String attributeName) {
		return attributeName.replaceAll(ATTRIBUTE_PREFIX, "");
	}

	/** returns the html for a column */
	private static String getColumnHtml(String value, String bgcolor, String fgcolor, Boolean wordwrap) {
		String style = wordwrap ? "word-wrap: break-word" : "";
		return "<td  style=\"" + style + "\" bgcolor=\"" + bgcolor + "\"><font color = \"" + fgcolor + "\">" + value
				+ "</font></td>";
	}

	

	/** filter whitespace */
	// private static String filterToken(String string) {
	// return string.replaceAll("\\s", "");
	// }

	

	/** filter illegal characters in XML names */
	// private static String filterNameToken(String string) {
	// return string.replaceAll("[^-._:A-Za-z0-9]", "");
	// }

	/** returns an extension schema URI */
	static String getExtensionSchema(String prefix) {
		return getProperty(IEPD_URI_PROPERTY) + prefix;
	}

	/** returns a line of the NIEM mapping spreadsheet in CSV format */
	private static String[] getItemCsv(UmlItem item) {
		String[] nextLine = new String[NIEM_STEREOTYPE_MAP.length];
		try {
			// Export Class and Property
			switch (item.kind().value()) {
			case anItemKind._aClass:
				nextLine[0] = item.name();
				nextLine[1] = "";
				nextLine[2] = "";
				break;
			case anItemKind._anAttribute:
				nextLine[0] = item.parent().name();
				nextLine[1] = item.name();
				UmlAttribute a = (UmlAttribute) item;
				nextLine[2] = a.multiplicity();
				break;
			case anItemKind._aRelation:
				nextLine[0] = item.parent().name();
				UmlRelation r = (UmlRelation) item;
				nextLine[1] = r.name();
				nextLine[2] = r.multiplicity();
				break;
			case anItemKind._aClassInstance:
				nextLine[0] = "";
				nextLine[1] = item.name();
				nextLine[2] = "";
				break;
			default:
				nextLine[0] = item.parent().name();
				nextLine[1] = item.name();
				nextLine[2] = "";
				break;
			}
		} catch (Exception e) {
			UmlCom.trace("itemCsv: error importing class, property multiplicity " + e.toString());
		}

		// Export Description
		nextLine[3] = item.description();

		// Export NIEM Mapping
		if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
			for (int column = 4; column < NIEM_STEREOTYPE_MAP.length; column++)
				nextLine[column] = item.propertyValue(getNiemProperty(column));

		return nextLine;
	}

	/** return XML maxOccurs from multiplicity */
	static String getMaxOccurs(String multiplicity) {
		String maxOccurs = null;
		if (multiplicity.equals(""))
			maxOccurs = "1";
		else if (multiplicity.contains(","))
			maxOccurs = multiplicity.split(",")[1];
		else
			maxOccurs = multiplicity;
		try {
			if (!maxOccurs.equals("unbounded") && (Integer.parseInt(maxOccurs) < 1))
				throw new NumberFormatException();
		} catch (NumberFormatException e) {
			UmlCom.trace("getMaxOccurs: error - invalid multiplicity " + multiplicity);
		}
		return maxOccurs;
	}

	/** return XML minOccurs from multiplicity */
	static String getMinOccurs(String multiplicity) {
		String minOccurs = null;
		if (multiplicity.equals(""))
			minOccurs = "1";
		else if (multiplicity.contains(","))
			minOccurs = multiplicity.split(",")[0];
		else
			minOccurs = multiplicity;
		try {
			if (Integer.parseInt(minOccurs) < 0)
				throw new NumberFormatException();
		} catch (NumberFormatException e) {
			UmlCom.trace("getMinOccurs: error - invalid multiplicity " + multiplicity);
		}
		return minOccurs;
	}

	/**
	 * return the NIEM stereotype associated with a column in the NIEM mapping
	 * spreadsheet
	 */
	private static String getNiemProperty(int p) {
		return NIEM_STEREOTYPE_TYPE + STEREOTYPE_DELIMITER + NIEM_STEREOTYPE_MAP[p][1];
	}

	/** return NIEM version */
	private static String getNiemVersion() {
		String niemVersion = NIEM_VERSION_DEFAULT;

		String schemaURI = NamespaceModel.Prefixes.get("nc");
		// UmlCom.trace("NIEM URI: " + schemaURI);
		Matcher mat = Pattern.compile(".*niem-core/(.*)/").matcher(schemaURI);
		if (mat.find())
			niemVersion = mat.group(1);
		UmlCom.trace("NIEM version: " + niemVersion);
		return niemVersion;
	}

	/**
	 * return child package with name packageName in parentPackage; if it doesn't
	 * exist and create is true, create it
	 */
	private static UmlPackage getPackage(UmlPackage parentPackage, String packageName, boolean create) {
		for (UmlItem item : parentPackage.children()) {
			if (item.name().equals(packageName))
				if ((item.kind() == anItemKind.aPackage))
					return (UmlPackage) item;
		}
		if (create) {
			trace("getPackage: Creating " + packageName);
			return UmlPackage.create(parentPackage, packageName);
		}
		return null;
	}

	/** return project property with name propertyName */
	public static String getProperty(String propertyName) {
		return UmlPackage.getProject().propertyValue(propertyName);
	}

	/** return schemaURI for type or element with name tagname */
	static String getSchemaURI(String tagName) {
		String prefix = NamespaceModel.getPrefix(tagName);
		if (prefix == null)
			// prefix = LOCAL_PREFIX;
			return null;
		String schemaURI = NamespaceModel.Prefixes.get(prefix);
		if (schemaURI == null)
			schemaURI = getExtensionSchema(prefix);
		return schemaURI;
	}

	/** return URI of a item in schemaURI with name itemName */
	static String getURI(String schemaURI, String itemName) {
		itemName.replaceAll("[^-._:A-Za-z0-9]", "");
		return schemaURI + HASH_DELIMITER + NamespaceModel.getName(itemName).replaceAll(HASH_DELIMITER, "");
	}

	/** return URI of an item */
	static String getURI(UmlItem item) {
		return item.propertyValue(URI_PROPERTY);
	}

	/** hide item from documentation */
	private static void hideItem(UmlItem item) {
		item.known = false;
		for (UmlItem child : item.children())
			hideItem(child);
	}

	/** hide reference model from documentation */
	public static void hideReferenceModel() {
		hideItem(ReferenceModel.modelPackage);
	}

	/** returns true if the UML item is an attribute or attribute group */
	static boolean isAttribute(UmlItem item) {
		return NamespaceModel.getName(item).startsWith(ATTRIBUTE_PREFIX);
	}

	/** return true if an element exists in reference model */
	static Boolean isNiemElement(String elementName) {
		if ((elementName == null) || elementName.equals("") || elementName.equals("??")
				|| NamespaceModel.isExternalPrefix(NamespaceModel.getPrefix(elementName)))
			return false;
		String schemaURI = NamespaceModel.Prefixes.get(NamespaceModel.getPrefix(elementName));
		if (schemaURI == null)
			return false;
		return ReferenceModel.elements.containsKey(getURI(schemaURI, elementName));
	}

	/** return true if an element in type exists in reference model */
	private static Boolean isNiemElementInType(String typeName, String elementName) {
		if (!isNiemType(typeName) || !isNiemElement(elementName))
			return false;
		UmlClassInstance element = ReferenceModel.getElement(getSchemaURI(elementName), elementName);
		List<UmlClassInstance> elementList = ReferenceModel.getElementsInType(getURI(getSchemaURI(typeName), typeName));
		for (UmlClassInstance element2 : elementList)
			if (element.equals(element2))
				return true;
		UmlCom.trace("isNiemElementInType: error - element " + elementName + " not in type " + typeName);
		return false;
	}

	/** returns true if type exists in reference model */
	private static Boolean isNiemType(String typeName) {
		if ((typeName == null) || typeName.equals("") || typeName.equals("??") || NamespaceModel.isExternalPrefix(NamespaceModel.getPrefix(typeName)))
			return false;
		String schemaURI = NamespaceModel.Prefixes.get(NamespaceModel.getPrefix(typeName));
		if (schemaURI == null)
			return false;
		return ReferenceModel.types.containsKey(getURI(schemaURI, typeName));
	}

	/** sets a project property */
	private static void setPropertyDefault(String propertyName, String propertyValue) {
		UmlPackage root = UmlPackage.getProject();
		if (root.propertyValue(propertyName) == null)
			root.set_PropertyValue(propertyName, propertyValue);
	}

	/** outputs debugging information */
	static void trace(String output) {
		if (_TRACE)
			UmlCom.trace(output);
	}

	/** writes a column of the NIEM mapping spreadsheet in HTML format to a file */
	private static void writeItemHtml(FileWriter fw, UmlItem item) throws IOException {
		if (item.known) {
			fw.write("<a href=\"");
			if (!UmlItem.flat && (item.parent() != null) && (item.parent().kind() == anItemKind.aClass)) {
				fw.write("class");
				fw.write(String.valueOf(item.parent().getIdentifier()));
			} else
				fw.write("index");
			fw.write(HTML_FILE_TYPE + "#ref");
			fw.write(String.valueOf(item.kind().value()));
			fw.write('_');
			fw.write(String.valueOf(item.getIdentifier()));
			fw.write("\"><b>");
			fw.write(item.name());
			fw.write("</b></a>");
		} else
			fw.write(item.name());
	}

	/** writes a line of the NIEM mapping spreadsheet in HTML format to a file */
	private static void writeLineHtml(FileWriter fw, UmlItem item) {
		try {
			// Export Class, Property and Multiplicity
			// trace("writeLineHtml: " + item.name());
			switch (item.kind().value()) {
			case anItemKind._aClass: {
				fw.write("<tr bgcolor=\"#f0f0f0\"><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item);
				fw.write("</td><td>");
				fw.write("</td><td>");
			}
				break;
			case anItemKind._anAttribute: {
				fw.write("<tr><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item.parent());
				fw.write("</td><td style=\"word-wrap: break-word\">");
				writeItemHtml(fw, item);
				fw.write("</td><td>");
				UmlAttribute a = (UmlAttribute) item;
				fw.write(a.multiplicity());
			}
				break;
			case anItemKind._aRelation: {
				UmlRelation rel = (UmlRelation) item;
				if ((rel.relationKind() == aRelationKind.aGeneralisation)
						|| (rel.relationKind() == aRelationKind.aRealization))
					return;
				else {
					fw.write("<tr><td style=\"word-wrap: break-word\">");
					writeItemHtml(fw, item.parent());
					fw.write("</td><td style=\"word-wrap: break-word\">");
					writeItemHtml(fw, item);
					fw.write("</td><td>");
					fw.write(rel.multiplicity());
				}
			}
				break;
			default:
				return;
			}
			fw.write("</td><td>");

			// Export Description
			if (item.description() != null)
				fw.write(item.description());
			fw.write("</td>");

			// Export NIEM Mapping
			int columnIndex;
			// String oldValue, container;
			String[] column = new String[NIEM_STEREOTYPE_MAP.length];
			String extensionBGColor = "#ffd700";
			String defaultBGColor = "#ffffff";
			String invalidFGColor = "#ff0000"; // invalid NIEM mappings are red
			String changedFGColor = "#0000ff"; // changes from the previous
			// version are blue
			String defaultFGColor = "#000000";
			String fgcolor, bgcolor;

			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
				for (columnIndex = 4; columnIndex < NIEM_STEREOTYPE_MAP.length; columnIndex++) {
					column[columnIndex] = (item.propertyValue(getNiemProperty(columnIndex)));
					column[columnIndex] = (column[columnIndex] != null) ? column[columnIndex].trim() : "";
				}

				// determine if this is an extension
				/*
				 * Boolean extension = false; String[] xPathElements = column[4].split("/"); for
				 * (String element : xPathElements) { String prefix = getPrefix(element); if
				 * (!prefix.equals("") && !isNiemSchema(prefix) &&
				 * !isExternalPrefix(getPrefix(element.trim()))) { extension = true; continue; }
				 * }
				 */

				// export XPath
				String XPath = column[4].trim();
				String oldXPath = column[9].trim();
				// bgcolor = (extension) ? extensionBGColor : defaultBGColor;
				bgcolor = defaultBGColor;
				fgcolor = (XPath.equals(oldXPath)) ? defaultFGColor : changedFGColor;
				fw.write(getColumnHtml(XPath, bgcolor, fgcolor, true));

				// export Type
				String typeName = column[5].trim();
				String typePrefix = NamespaceModel.getPrefix(typeName);
				bgcolor = defaultBGColor;
				fgcolor = defaultFGColor;
				if (!typeName.equals("")) {
					if (NamespaceModel.isNiemPrefix(NamespaceModel.getPrefix(typeName)) && !isNiemType(typeName))
						fgcolor = invalidFGColor;
					if (!NamespaceModel.isNiemPrefix(typePrefix) && !NamespaceModel.isExternalPrefix(typePrefix))
						bgcolor = extensionBGColor;
				}
				fw.write(getColumnHtml(typeName, bgcolor, fgcolor, true));

				// export Property
				String elementLine = column[6];
				fgcolor = defaultFGColor;
				bgcolor = defaultBGColor;
				if (!elementLine.equals("")) {
					String[] elementNames = elementLine.split(",");
					for (String elementName : elementNames) {
						elementName = elementName.trim();
						Matcher mat = Pattern.compile("\\((.*?)\\)").matcher(elementName);
						if (!mat.find()) {
							String prefix = NamespaceModel.getPrefix(elementName);
							if (NamespaceModel.isNiemPrefix(typePrefix) && NamespaceModel.isNiemPrefix(prefix)
									&& !isNiemElementInType(typeName, elementName))
								fgcolor = invalidFGColor;
							prefix = NamespaceModel.getPrefix(elementLine);
							if (!NamespaceModel.isNiemPrefix(prefix) && !NamespaceModel.isExternalPrefix(prefix))
								bgcolor = extensionBGColor;
						}
					}
				}
				fw.write(getColumnHtml(elementLine, bgcolor, fgcolor, true));

				// export BaseType
				String baseType = column[7].trim();
				String basePrefix = NamespaceModel.getPrefix(baseType);
				bgcolor = defaultBGColor;
				fgcolor = defaultFGColor;
				if (!baseType.equals("") && !baseType.equals(ABSTRACT_TYPE_NAME)) {
					if (!NamespaceModel.isNiemPrefix(basePrefix) && !NamespaceModel.isExternalPrefix(basePrefix))
						bgcolor = extensionBGColor;
					if (NamespaceModel.isNiemPrefix(basePrefix) && !isNiemType(baseType))
						fgcolor = invalidFGColor;
				}
				fw.write(getColumnHtml(baseType, bgcolor, fgcolor, true));

				// export Multiplicity
				bgcolor = defaultBGColor;
				String multiplicity = column[8];
				fgcolor = (multiplicity.equals(column[10])) ? defaultFGColor : changedFGColor;
				String minOccurs = getMinOccurs(multiplicity);
				String maxOccurs = getMaxOccurs(multiplicity);
				try {
					if (Integer.parseInt(minOccurs) < 0)
						throw new NumberFormatException();
					if (!maxOccurs.equals("unbounded") && (Integer.parseInt(maxOccurs) < 1))
						throw new NumberFormatException();
				} catch (NumberFormatException e) {
					fgcolor = invalidFGColor;
				}
				fw.write(getColumnHtml(column[8], bgcolor, fgcolor, false));

				// export Old XPath, Multiplicity, Mapping Notes, code list
				fgcolor = defaultFGColor;
				fw.write(getColumnHtml(column[9], bgcolor, fgcolor, true));
				fw.write(getColumnHtml(column[10], bgcolor, fgcolor, false));
				fw.write(getColumnHtml(column[11], bgcolor, fgcolor, true));
				fw.write(getColumnHtml(column[12], bgcolor, fgcolor, true));
			}
			fw.write("</tr>");
		} catch (Exception e) {
			UmlCom.trace("writeLineHtml: error " + e.toString());
		}
	}

	/** initialize NiemTools project */
	public NiemUmlClass() {
		super();

		// set IEPD configuration defaults
		setPropertyDefault(IEPD_URI_PROPERTY, IEPD_URI_DEFAULT);
		setPropertyDefault(IEPD_NAME_PROPERTY, IEPD_NAME_DEFAULT);
		setPropertyDefault(IEPD_VERSION_PROPERTY, IEPD_VERSION_DEFAULT);
		setPropertyDefault(IEPD_STATUS_PROPERTY, IEPD_STATUS_DEFAULT);
		setPropertyDefault(IEPD_ORGANIZATION_PROPERTY, IEPD_ORGANIZATION_DEFAULT);
		setPropertyDefault(IEPD_CONTACT_PROPERTY, IEPD_CONTACT_DEFAULT);
		setPropertyDefault(IEPD_EMAIL_PROPERTY, IEPD_EMAIL_DEFAULT);
		setPropertyDefault(IEPD_LICENSE_URL_PROPERTY, IEPD_LICENSE_URL_DEFAULT);
		setPropertyDefault(IEPD_TERMS_URL_PROPERTY, IEPD_TERMS_URL_DEFAULT);
		setPropertyDefault(IEPD_READ_ME_FILE_PROPERTY, IEPD_READ_ME_FILE_DEFAULT);
		setPropertyDefault(IEPD_CHANGE_LOG_FILE_PROPERTY, IEPD_CHANGE_LOG_FILE_DEFAULT);
		setPropertyDefault(IEPD_EXTERNAL_SCHEMAS_PROPERTY, IEPD_EXTERNAL_SCHEMAS_DEFAULT);
		
	}

	/** caches namespaces and prefixes for external schemas */
	public void cacheModels() {
		UmlCom.message("Generating extension schema ...");
		UmlCom.trace("Generating extension schema");
		NamespaceModel.cacheExternalSchemas();
		ReferenceModel.cacheModel();
		SubsetModel.cacheModel();
		ExtensionModel.cacheModel();
		trace("Done generating extension schemas");
	}

	/** creates Platform Independent Model (NIEM) */
	public void createNIEM() {
		UmlCom.message("Resetting NIEM models");
		UmlCom.trace("Resetting NIEM models");
		UmlPackage pimPackage = null;
		// Find or create NIEM packages
		pimPackage = getPackage(UmlPackage.getProject(), NIEM_PACKAGE, true);
		SubsetModel.modelPackage = getPackage(pimPackage, NIEM_SUBSET_PACKAGE, true);
		ExtensionModel.modelPackage = getPackage(pimPackage, NIEM_EXTENSION_PACKAGE, true);
		ReferenceModel.modelPackage = getPackage(pimPackage, NIEM_REFERENCE_PACKAGE, true);
		ReferenceModel.modelPackage.set_Stereotype("framework");
	}

	/** creates NIEM subset and extension models */
	@SuppressWarnings("unchecked")
	public void createSubsetAndExtension() {

		UmlCom.message("Generating NIEM subset and extension models");
		UmlCom.trace("Generating NIEM subset and extension models");

		Iterator<UmlItem> it = (UmlItem.all.iterator());
		// add types to subset and extension
		trace("createSubsetAndExtension: copy subset types and create extension types");
		it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				continue;
			String typeName = item.propertyValue(NIEM_STEREOTYPE_TYPENAME).trim();
			String elementName = item.propertyValue(NIEM_STEREOTYPE_PROPERTY).trim();
			String notes = item.propertyValue(NIEM_STEREOTYPE_NOTES).trim();
			String baseTypeName = item.propertyValue(NIEM_STEREOTYPE_BASE_TYPE).trim();
			if (baseTypeName.equals(ABSTRACT_TYPE_NAME))
				continue;
			// trace("createSubsetAndExtension: adding type " + typeName + " and base type "
			// + baseTypeName);
			String description = null;
			if (elementName.equals(""))
				if (typeName.endsWith(NiemModel.AUGMENTATION_TYPE_NAME))
					description = "An augmentation type";
				else
					description = item.description().trim();

			// add base type
			if (!baseTypeName.equals(""))
				if (isNiemType(baseTypeName))
					SubsetModel.copyType(baseTypeName);
				else
					ExtensionModel.addType(getSchemaURI(baseTypeName), baseTypeName, null, null);

			// add type
			if (!typeName.equals(""))
				if (isNiemType(typeName))
					SubsetModel.copyType(typeName);
				else
					ExtensionModel.addType(getSchemaURI(typeName), typeName, description, notes);
		}

		// relate extension types to base types and attribute groups
		trace("createSubsetAndExtension: copy subset base types and create extension base types");
		it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				continue;
			String typeName = item.propertyValue(NIEM_STEREOTYPE_TYPENAME).trim();
			String elementName = item.propertyValue(NIEM_STEREOTYPE_PROPERTY).trim();
			String baseTypeName = item.propertyValue(NIEM_STEREOTYPE_BASE_TYPE).trim();
			if (typeName.equals("") || isNiemType(typeName))
				continue;
			NiemModel model = NamespaceModel.isNiemPrefix(NamespaceModel.getPrefix(typeName)) ? NiemUmlClass.SubsetModel : NiemUmlClass.ExtensionModel;
			UmlClass type = model.getType(getSchemaURI(typeName), typeName);
			if (type == null)
				continue;
			UmlClass baseType = null;
			if (baseTypeName.equals("") || typeName.endsWith(NiemModel.AUGMENTATION_TYPE_NAME))
				baseType = SubsetModel.augmentationType;
			else {
				if (!elementName.equals(""))
					continue;
				if (baseTypeName.equals("")) {
					UmlCom.trace("createSubsetAndExtension: base type not defined for type " + typeName
							+ "; using default base type.");
					baseType = SubsetModel.objectType;
				} else {
					NiemModel baseModel = NamespaceModel.isNiemPrefix(NamespaceModel.getPrefix(baseTypeName)) ? NiemUmlClass.SubsetModel : NiemUmlClass.ExtensionModel;
					baseType = baseModel.getType(getSchemaURI(baseTypeName), baseTypeName);
				}
				if (baseType == null) {
					UmlCom.trace("createSubsetAndExtension: base type " + baseTypeName + " not found.");
					continue;
				}
			}

			// relate type to base type
			ExtensionModel.relateBaseType(type, baseType);

			// If type is based on simple type, add attribute group
			String baseTypePrefix = NamespaceModel.getPrefix(baseType);
			if (baseTypePrefix != null && baseTypePrefix.equals(XSD_PREFIX))
				ExtensionModel.relateAttributeGroup(type, SubsetModel.simpleObjectAttributeGroup);
		}

		// Copy subset elements and create extension elements
		trace("createSubsetAndExtension: copy subset elements and create extension elements");
		it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				continue;
			String typeName = item.propertyValue(NIEM_STEREOTYPE_TYPENAME).trim();
			String elementList = item.propertyValue(NIEM_STEREOTYPE_PROPERTY).trim();
			String baseTypeName = item.propertyValue(NIEM_STEREOTYPE_BASE_TYPE).trim();
			String multiplicity = item.propertyValue(NIEM_STEREOTYPE_MULTIPLICITY).trim();
			String description = item.description().trim();
			String mappingNotes = item.propertyValue(NIEM_STEREOTYPE_NOTES).trim();
			String codeList = item.propertyValue(NIEM_STEREOTYPE_CODE_LIST).trim();

			boolean substitution = elementList.contains("(");
			String headElement = null;
			String[] elementNames = elementList.split(",");
			for (String elementName : elementNames) {
				boolean representation = false;
				if (elementName.contains("(")) {
					elementName = elementName.replaceAll("\\(|\\)", "");
					representation = true;
				}
				elementName = elementName.trim();
				if (elementName.equals(""))
					continue;
				if (elementName.contains("Augmentation") && description.equals(""))
					description = "An augmentation";
				Boolean isNillable = elementName.startsWith(REFERENCE_PREFIX);
				if (isNillable)
					elementName = elementName.substring(1);
				// trace("createSubsetAndExtension: adding element " + elementName + " in type "
				// + typeName);
				if (substitution && !representation && headElement == null)
					headElement = elementName;
				String baseTypeName2 = baseTypeName;
				if (baseTypeName.equals(ABSTRACT_TYPE_NAME) || (substitution && !representation))
					baseTypeName2 = NamespaceModel.getPrefixedName(LOCAL_PREFIX, ABSTRACT_TYPE_NAME);

				// copy NIEM element or add extension element
				NiemModel model = NamespaceModel.isNiemPrefix(NamespaceModel.getPrefix(baseTypeName2)) ? NiemUmlClass.SubsetModel : NiemUmlClass.ExtensionModel;
				UmlClass baseType = model.getType(getSchemaURI(baseTypeName2), baseTypeName2);
				if (baseType == null && !baseTypeName.equals(""))
					UmlCom.trace("createSubsetAndExtension: error - base type " + baseTypeName2 + " not in model with URI "+ getSchemaURI(baseTypeName2));
				UmlClassInstance element = (isNiemElement(elementName)) ? SubsetModel.copyElement(elementName)
						: ExtensionModel.addElement(getSchemaURI(elementName), elementName, baseType, description, mappingNotes);
				if (element == null)
					continue;

				// copy element in type
				if ((!substitution || !representation) && !typeName.equals("")) {
					NiemModel model2 = NamespaceModel.isNiemPrefix(NamespaceModel.getPrefix(typeName)) ? NiemUmlClass.SubsetModel : NiemUmlClass.ExtensionModel;
					UmlClass type = model2.getType(getSchemaURI(typeName), typeName);
					if (type != null)
						if (isNiemType(typeName))
							SubsetModel.copyElementInType(type, element, multiplicity);
						else
							ExtensionModel.addElementInType(type, element, multiplicity);
				}

				if (isNillable)
					element.set_PropertyValue(NILLABLE_PROPERTY, "true");
				if (headElement != null && substitution && representation)
					element.set_PropertyValue(SUBSTITUTION_PROPERTY, headElement);
				if (codeList != null && !codeList.equals("") && (!substitution || !representation))
					element.set_PropertyValue(CODELIST_PROPERTY, codeList);
			}
		}

		// Sorting
		trace("createSubsetAndExtension: sorting namespaces");
		SubsetModel.modelPackage.sort();
		ExtensionModel.modelPackage.sort();
	}

	/** deletes NIEM mappings */
	@SuppressWarnings("unchecked")
	public void deleteMapping() {
		UmlCom.trace("Deleting NIEM Mapping");
		Iterator<UmlItem> it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE) && item.kind() != anItemKind.aClassInstance)
				for (int property = 4; property < NIEM_STEREOTYPE_MAP.length; property++)
					item.set_PropertyValue(getNiemProperty(property), "");
		}
	}

	/** deletes NIEM models */
	public void deleteNIEM(boolean deleteReferenceModel) {

		// Find NIEM package
		UmlPackage pimPackage = getPackage(UmlPackage.getProject(), NIEM_PACKAGE, true);

		// delete reference model
		if (deleteReferenceModel) {
			trace("deleteSubset: deleting reference model");
			ReferenceModel.modelPackage = getPackage(pimPackage, NIEM_REFERENCE_PACKAGE, false);
			if (ReferenceModel.modelPackage != null) {
				ReferenceModel.modelPackage.deleteIt();
				ReferenceModel.modelPackage.unload(true, true);
			}
		}

		// delete subset and extension models
		trace("deleteSubset: deleting subset and extension model");
		SubsetModel.modelPackage = getPackage(pimPackage, NIEM_SUBSET_PACKAGE, false);
		if (SubsetModel.modelPackage != null) {
			SubsetModel.modelPackage.deleteIt();
			SubsetModel.modelPackage.unload(true, true);
		}
		ExtensionModel.modelPackage = getPackage(pimPackage, NIEM_EXTENSION_PACKAGE, false);
		if (ExtensionModel.modelPackage != null) {
			ExtensionModel.modelPackage.deleteIt();
			SubsetModel.modelPackage.unload(true, true);
		}
	}

	/**
	 * exports a NIEM mapping spreadsheet in CSV format
	 * 
	 * roundtripping is supported with importCsv()
	 */
	@SuppressWarnings("unchecked")
	
	public void exportCsv(String dir, String filename) {

		UmlCom.message("Generating NIEM Mapping CSV ...");
		UmlCom.trace("Generating NIEM Mapping CSV");
		NamespaceModel.cacheExternalSchemas();

		UmlItem.directory = dir;
		File file = Paths.get(dir, filename).toFile();

		try {
			File parentFile = file.getParentFile();
			if (parentFile != null)
				parentFile.mkdirs();
			FileWriter fw = new FileWriter(file);
			trace("exportCsv: open CSV " + file.toString());
			CSVWriter writer = new CSVWriter(fw);

			// Write header
			String[] nextLine = new String[NIEM_STEREOTYPE_MAP.length];
			for (int column = 0; column < NIEM_STEREOTYPE_MAP.length; column++)
				nextLine[column] = NIEM_STEREOTYPE_MAP[column][0];
			writer.writeNext(nextLine);

			// Export NIEM Mappings for Classes
			Iterator<UmlItem> it = (UmlClass.classes.iterator());
			while (it.hasNext()) {
				UmlItem thisClass = it.next();
				trace("exportCsv: " + thisClass.name());
				if (!thisClass.stereotype().equals(NIEM_STEREOTYPE_TYPE))
					continue;
				nextLine = getItemCsv(thisClass);
				writer.writeNext(nextLine);

				// Export NIEM Mapping for Attributes and Relations
				for (UmlItem item : thisClass.children()) {
					if (!item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
						continue;
					nextLine = getItemCsv(item);
					if (nextLine != null)
						writer.writeNext(nextLine);
				}
			}
			writer.close();
			trace("exportCsv: CSV file created " + file.toString());

		} catch (Exception e) {
			UmlCom.trace("exportCsv: error " + e.toString());
		}
	}

	/** exports a NIEM mapping spreadsheet in HTML format */
	@SuppressWarnings("unchecked")
	public void exportHtml(String dir, String filename) {

		UmlCom.message ("Generating NIEM Mapping HTML ...");
		UmlCom.trace("Generating NIEM Mapping HTML");
		NamespaceModel.cacheExternalSchemas();
		// cache NIEM namespaces, elements and types
		// cacheModel(referencePackage);
		try {
			// Write rest of header
			File file = Paths.get(dir, filename + HTML_FILE_TYPE).toFile();
			File parentFile = file.getParentFile();
			if (parentFile != null)
				parentFile.mkdirs();
			FileWriter fw = new FileWriter(file);
			fw.write("<html>");
			fw.write("<head><title>" + MAPPING_SPREADSHEET_TITLE
					+ "</title><link rel=\"stylesheet\" href=\"style.css\" type=\"text/css\" /></head>"
					+ "<body><div class = \"title\">" + MAPPING_SPREADSHEET_TITLE + "</div>"
					+ "<table style=\"table-layout: fixed; width: 100%\"><tr bgcolor=\"#f0f0f0\">");
			for (int column = 0; column < NIEM_STEREOTYPE_MAP.length; column++)
				fw.write("<td style=\"word-wrap: break-word\">" + NIEM_STEREOTYPE_MAP[column][0] + "</td>");
			fw.write("</tr>\n");

			// Show NIEM Mappings for Classes
			Iterator<UmlItem> it = (UmlClass.classes.iterator());
			while (it.hasNext()) {
				UmlItem thisClass = it.next();
				if (thisClass.stereotype().equals(NIEM_STEREOTYPE_TYPE)) {
					writeLineHtml(fw, thisClass);

					// Show NIEM Mapping for Attributes and Relations
					for (UmlItem item : thisClass.children())
						if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
							writeLineHtml(fw, item);
				}
			}
			fw.write("</table>\n");
			fw.write("</body></html>");
			fw.close();
		} catch (Exception e) {
			UmlCom.trace("exportHtml: error " + e.toString());
		}
	}

	/** exports a NIEM IEPD including extension and exchange schema */
	@SuppressWarnings("unchecked")
	public void exportIEPD(String xmlDir, String wsdlDir, String jsonDir, String openapiDir) {

		/*
		 * cacheExternalSchemas(); cacheModel(referencePackage);
		 * cacheModel(subsetPackage); cacheModel(extensionPackage);
		 */

		// export code lists for extension elements
		CodeListNamespaces = new HashSet<String>();
		if (xmlDir != null) {
			XmlWriter.exportCodeLists(ExtensionModel, xmlDir);
			XmlWriter.exportCodeLists(SubsetModel, xmlDir);
		}

		try {
			if (xmlDir != null) {
				// export catalog file
				XmlWriter.exportXMLCatalog(xmlDir, CodeListNamespaces);
			}
		} catch (Exception e) {
			UmlCom.trace("exportIEPD: error creating XML catalog file " + e.toString());
		}

		// cache list of ports and message elements
		trace("exportIEPD: cache ports and message elements");
		Map<String, UmlClass> ports = new TreeMap<String, UmlClass>();
		Set<String> messages = new TreeSet<String>();
		Set<String> messageNamespaces = new TreeSet<String>();
		messageNamespaces.add(XSD_PREFIX);
		Iterator<UmlItem> it = (UmlClass.classes.iterator());
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (!item.stereotype().equals("interface"))
				continue;
			UmlClass port = (UmlClass) item;
			String portName = port.name();
			ports.put(portName, port);
			trace("exportIEPD: port: " + port.name());
			for (UmlItem item2 : port.children()) {
				if (item2.kind() != anItemKind.anOperation)
					continue;
				UmlOperation operation = (UmlOperation) item2;
				String operationName = operation.name();
				trace("exportIEPD: operation: " + operationName);
				// operations.put(operationName, operation);
				UmlClass outputType = null, inputType = null;
				UmlParameter[] params = operation.params();
				if (params != null)
					for (UmlParameter param : params) {
						// ignore RESTful parameters
						if (!param.name.equals("") && !param.name.equals("body"))
							continue;
						trace("exportIEPD: param " + param.name);
						try {
							inputType = param.type.type;
							// String mult = param.multiplicity;
						} catch (Exception e) {
							UmlCom.trace("exportIEPD: error - no input message for " + operationName);
						}
						if (inputType == null || !inputType.stereotype().equals(NIEM_STEREOTYPE_TYPE))
							continue;
						String inputMessage = inputType.propertyValue(NIEM_STEREOTYPE_XPATH);
						if (inputMessage == null || inputMessage.equals(""))
							continue;
						trace("exportIEPD: input Message: " + inputMessage + " from operation " + operationName);
						messageNamespaces.add(NamespaceModel.getPrefix(inputMessage));
						NiemModel model = (SubsetModel.elements.containsKey(NiemUmlClass.getURI(getSchemaURI(inputMessage), inputMessage))) ? SubsetModel : ExtensionModel;
						UmlClassInstance element = model.getElementByURI(NiemUmlClass.getURI(getSchemaURI(inputMessage), inputMessage));
						if (element != null)
							element.set_PropertyValue(MESSAGE_ELEMENT_PROPERTY, operationName);
					}
				try {
					outputType = operation.returnType().type;
				} catch (Exception e) {
					UmlCom.trace("exportIEPD: error - no output message for " + operationName + " " + e.toString());
				}
				if (outputType == null || !outputType.stereotype().equals(NIEM_STEREOTYPE_TYPE))
					continue;
				String outputMessage = outputType.propertyValue(NIEM_STEREOTYPE_XPATH);
				if (outputMessage == null || outputMessage.equals(""))
					continue;
				trace("exportIEPD: output Message: " + outputMessage + " from operation " + operationName);
				messageNamespaces.add(NamespaceModel.getPrefix(outputMessage));
				NiemModel model = (SubsetModel.elements.containsKey(NiemUmlClass.getURI(getSchemaURI(outputMessage), outputMessage))) ? SubsetModel : ExtensionModel;
				UmlClassInstance element = model.getElementByURI(NiemUmlClass.getURI(getSchemaURI(outputMessage), outputMessage));
				if (element != null)
					element.set_PropertyValue(MESSAGE_ELEMENT_PROPERTY, operationName);
			}
		}

		if (jsonDir != null)
			XmlWriter.exportSchemas(SubsetModel, null, Paths.get(jsonDir, NIEM_DIR).toString());
		XmlWriter.exportSchemas(ExtensionModel, xmlDir, jsonDir);

		if (xmlDir != null)
			try {
				XmlWriter.exportMPDCatalog(xmlDir, CodeListNamespaces, messages);
				if (wsdlDir != null)
					XmlWriter.exportWSDL(xmlDir, wsdlDir, ports, messageNamespaces);
			} catch (Exception e) {
				UmlCom.trace("exportIEPD: error exporting MPD catalog or WSDL " + e.toString());
			}

		if (jsonDir != null)
			try {
				if (openapiDir != null)
					JsonWriter.exportOpenAPI(jsonDir, openapiDir, ports, messageNamespaces);
			} catch (Exception e) {
				UmlCom.trace("exportIEPD: error exporting OpenAPI files " + e.toString());
			}
	}

	/**
	 * exports a NIEM wantlist for import into Subset Schema Generator Tool (SSGT)
	 */
	public void exportWantlist(String dir, String filename) {

		UmlCom.message("Generating NIEM Wantlist ...");
		UmlCom.trace("Generating NIEM Wantlist");
		// createSubset();
		NamespaceModel.cacheExternalSchemas();

		UmlItem.directory = dir;
		try {
			// Export schema
			trace("exportWantlist: create header");
			File file = Paths.get(dir, filename).toFile();
			File parentFile = file.getParentFile();
			if (parentFile != null)
				parentFile.mkdirs();
			FileWriter fw = new FileWriter(file);
			fw.write(XML_HEADER);
			fw.write(XML_ATTRIBUTION);
			fw.write("<w:WantList w:release=\"" + getNiemVersion()
					+ "\" w:product=\"NIEM\" w:nillableDefault=\"true\" ");
			for (UmlItem item : SubsetModel.modelPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					String prefix = item.propertyValue(PREFIX_PROPERTY);
					String schemaURI = NamespaceModel.Prefixes.get(prefix);
					if (!prefix.equals(LOCAL_PREFIX) && (!prefix.equals(XSD_PREFIX)))
						XmlWriter.writeXmlNs(fw, prefix, schemaURI);
				}
			XmlWriter.writeXmlNs(fw, "w", WANTLIST_URI);
			fw.write(">");

			// export elements
			for (UmlItem item : SubsetModel.modelPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					String prefix = classView.propertyValue(PREFIX_PROPERTY);
					String anyElement = NamespaceModel.getPrefixedName(XSD_PREFIX, ANY_ELEMENT_NAME);
					if (prefix.equals(LOCAL_PREFIX) || prefix.equals(XSD_PREFIX) || prefix.equals(STRUCTURES_PREFIX))
						continue;
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClassInstance) {
							UmlClassInstance element = (UmlClassInstance) item2;
							String elementName = NamespaceModel.getPrefixedName(element);
							if (elementName.equals(anyElement))
								continue;
							if (isAttribute(element)) {
								elementName = NamespaceModel.getPrefixedAttributeName(NamespaceModel.getPrefix(elementName), elementName);
								trace("exportWantlist: export attribute " + elementName);
								// fw.write("<w:Attribute w:name=\"" + elementName + "\"/>\n");
								continue;
							}
							trace("exportWantlist: export element " + elementName);
							String isNillable = element.propertyValue(NILLABLE_PROPERTY);
							if (isNillable == null)
								isNillable = "false";
							fw.write("<w:Element w:name=\"" + elementName + "\" w:isReference=\"false\" w:nillable=\""
									+ isNillable + "\"/>\n");
						}
				}

			// export types
			for (UmlItem item : SubsetModel.modelPackage.children())
				if (item.kind() == anItemKind.aClassView) {
					UmlClassView classView = (UmlClassView) item;
					String prefix = classView.propertyValue(PREFIX_PROPERTY);
					if (prefix.equals(LOCAL_PREFIX) || prefix.equals(XSD_PREFIX) || prefix.equals(STRUCTURES_PREFIX))
						continue;
					for (UmlItem item2 : classView.children())
						if (item2.kind() == anItemKind.aClass) {
							UmlClass type = (UmlClass) item2;
							String typeName = NamespaceModel.getPrefixedName(type);
							trace("exportWantlist: export type " + typeName);

							// do not export structures:AugmentationType
							// if (type == SubsetModel.augmentationType)
							// continue;

							// attribute groups are not supported in wantlists
							if (isAttribute(type))
								continue;

							fw.write("<w:Type w:name=\"" + typeName + "\" w:isRequested=\"true\">\n");

							for (UmlItem item3 : type.children())
								if (item3.kind() == anItemKind.anAttribute) {
									UmlAttribute attribute = (UmlAttribute) item3;
									String elementName = attribute.name();
									// trace("exportWantlist: adding element " + elementName);
									String multiplicity = attribute.multiplicity();
									String minOccurs = getMinOccurs(multiplicity);
									String maxOccurs = getMaxOccurs(multiplicity);
									try {
										if (Integer.parseInt(minOccurs) < 0)
											throw new NumberFormatException();
										if (!maxOccurs.equals("unbounded") && (Integer.parseInt(maxOccurs) < 1))
											throw new NumberFormatException();
									} catch (NumberFormatException e) {
										UmlCom.trace("exportWantlist: error - invalid multiplicity " + multiplicity
												+ " for " + typeName + "/" + elementName);
									}

									if (isAttribute(attribute)) {
										elementName = NamespaceModel.getPrefixedName(NamespaceModel.getPrefix(elementName),
												filterAttributePrefix(NamespaceModel.getName(elementName)));
										trace("exportWantlist: export attribute " + elementName);
										// fw.write("<w:AttributeInType w:name=\"" + elementName + "\" w:minOccurs=\""
										// + minOccurs + "\" w:maxOccurs=\"" + maxOccurs + "\"/>\n");
										continue;
									}
									// trace("exportWantlist: export element " + elementName + " in type " +
									// typeName);
									fw.write("\t<w:ElementInType w:name=\"" + elementName
											+ "\" w:isReference=\"false\" w:minOccurs=\"" + minOccurs
											+ "\" w:maxOccurs=\"" + maxOccurs + "\"/>\n");
								}

							// export enumerations
							/*
							 * String codeList = type.propertyValue(CODELIST_PROPERTY); if (codeList !=
							 * null) { // trace("exportWantlist: exporting enumerations for " +
							 * getPrefixedName(type)); if (codeList.trim().contains(CODELIST_DELIMITER)) {
							 * String[] codes = codeList.split(CODELIST_DELIMITER); for (String code :
							 * codes) { String[] pairs = code.split(CODELIST_DEFINITION_DELIMITER); String
							 * value = pairs[0].trim(); if (!value.equals(""))
							 * fw.write("<w:Facet w:facet=\"enumeration\" w:value=\"" + filterQuotes(value)
							 * + "\"/>"); } } }
							 */
							fw.write("</w:Type>");
						}
				}

			fw.write("</w:WantList>");
			fw.close();

		} catch (IOException e) {
			UmlCom.trace("exportWantlist: IO exception: " + e.toString());
		}
	}

	/** import NIEM mapping spreadsheet in CSV format */
	@SuppressWarnings("unchecked")
	public void importCsv(String filename) {

		UmlCom.trace("Importing NIEM Mapping");
		NamespaceModel.cacheExternalSchemas();
		// cache UML classes
		Map<String, UmlClass> UMLClasses = new HashMap<String, UmlClass>();
		Map<String, UmlClassInstance> UMLInstances = new HashMap<String, UmlClassInstance>();
		Iterator<UmlItem> it = UmlItem.all.iterator();
		while (it.hasNext()) {
			UmlItem item = it.next();
			if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE))
				if (item.kind() == anItemKind.aClass) {
					UmlClass c = (UmlClass) item;
					if (!UMLClasses.containsKey(c.name()))
						UMLClasses.put(c.name(), c);
				} else if (item.kind() == anItemKind.aClassInstance) {
					UmlClassInstance ci = (UmlClassInstance) item;
					if (!UMLInstances.containsKey(ci.name()))
						UMLInstances.put(ci.name(), ci);
				}
		}
		try {

			CSVReader reader = new CSVReader(new FileReader(filename));
			String[] nextLine;

			// read header
			reader.readNext();

			// read mappings
			while ((nextLine = reader.readNext()) != null) {
				String className = nextLine[0].trim();
				String attributeName = nextLine[1].trim();

				if (!className.equals("")) {
					UmlClass type = UMLClasses.get(className);
					if (type != null) {
						if (attributeName.equals("")) {
							// import NIEM mapping to class
							trace("importCsv: importing NIEM mapping for " + className);
							for (int column = 4; column < NIEM_STEREOTYPE_MAP.length
									&& column < nextLine.length; column++)
								type.set_PropertyValue(getNiemProperty(column), nextLine[column]);
						} else {
							// import NIEM Mapping to attribute
							for (UmlItem item : type.children())
								if (item.stereotype().equals(NIEM_STEREOTYPE_TYPE)
										&& (item.name().equals(attributeName)))
									for (int column = 4; column < NIEM_STEREOTYPE_MAP.length
											&& column < nextLine.length; column++)
										item.set_PropertyValue(getNiemProperty(column), nextLine[column]);
						}
					}
				} else if (!attributeName.equals("")) {
					UmlClassInstance element = UMLInstances.get(attributeName);
					if (element != null) {
						// import NIEM mapping to class
						trace("importCsv: importing NIEM mapping for " + attributeName);
						for (int column = 4; column < NIEM_STEREOTYPE_MAP.length && column < nextLine.length; column++)
							element.set_PropertyValue(getNiemProperty(column), nextLine[column]);
					}
				}
			}
			reader.close();
		} catch (FileNotFoundException e) {
			UmlCom.trace("importCsv: error - file not found" + e.toString());
		} catch (IOException e) {
			UmlCom.trace("importCsv: error - IO exception" + e.toString());
		}
	}

	/**
	 * import NIEM reference model into HashMaps to support validation of NIEM
	 * elements and types
	 */
	public void importSchemaDir(String dir, Boolean includeEnums) throws IOException {

		UmlCom.message("Importing NIEM schema");

		// Configure DOM
		Path path = FileSystems.getDefault().getPath(dir);
		String importPath = path.toString();

		int passes = (includeEnums) ? 4 : 3;

		// Walk directory to import in passes (0: types, 1: elements, 2:
		// elements in types, 3: enumerations
		for (importPass = 0; importPass < passes; importPass++) {
			switch (NiemUmlClass.importPass) {
			case 0:
				UmlCom.trace("\nImporting types");
				break;
			case 1:
				UmlCom.trace("\nImporting elements");
				break;
			case 2:
				UmlCom.trace("\nImporting elements and attributes in types");
				break;
			}
			Files.walkFileTree(path, new SimpleFileVisitor<Path>() {
				@Override
				public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
					// Configure DOM
					DocumentBuilder db = null;
					DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory.newInstance();
					docBuilderFactory.setNamespaceAware(true);
					try {
						db = docBuilderFactory.newDocumentBuilder();
					} catch (ParserConfigurationException e) {
						UmlCom.trace("importSchemaDir: error configuring parser " + e.toString());
					}

					String filename = file.toString();
					String filepath1 = filename.replaceFirst(java.util.regex.Matcher.quoteReplacement(importPath), "");
					String filepath = filepath1.replaceAll(java.util.regex.Matcher.quoteReplacement("\\"), "/");
					if (filename.endsWith(XSD_FILE_TYPE)) {
						UmlCom.trace("Importing " + filepath);
						switch (NiemUmlClass.importPass) {
						case 0:
							Namespace ns = ReferenceModel.importTypes(db, filename);
							ns.referenceClassView.set_PropertyValue(FILE_PATH_PROPERTY, NIEM_DIR + filepath);
							break;
						case 1:
							ReferenceModel.importElements(db, filename);
							break;
						case 2:
							ReferenceModel.importElementsInTypes(db, filename);
							break;
						}
					}
					return FileVisitResult.CONTINUE;
				}
			});
		}

		// Sorting
		UmlCom.trace("Sorting namespaces");
		ReferenceModel.modelPackage.sort();

		UmlCom.trace("Namespaces: " + NamespaceModel.Namespaces.size());
		UmlCom.trace("Types: " + ReferenceModel.types.size());
		UmlCom.trace("Elements: " + ReferenceModel.elements.size());
	}

	/** verifies NIEM reference model exists */
	public boolean verifyNIEM() {
		trace("verifyNIEM: verifying NIEM folders");
		UmlPackage pimPackage = getPackage(UmlPackage.getProject(), NIEM_PACKAGE, false);
		if (pimPackage != null) {
			ReferenceModel.modelPackage = getPackage(pimPackage, NIEM_REFERENCE_PACKAGE, false);
			if (ReferenceModel.modelPackage != null)
				return true;
		}

		UmlCom.trace("NIEM reference model does not exist.  Import NIEM reference schemas first.");
		return false;
	}
}
